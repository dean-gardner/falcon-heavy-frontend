var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import * as sodium from 'libsodium-wrappers';
import BigNumber from 'bignumber.js';
import { getHexHash, toHex, sealCryptobox, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from './utils/crypto';
import { MatrixClient } from './matrix-client/MatrixClient';
import { MatrixClientEventType } from './matrix-client/models/MatrixClientEvent';
import { MatrixMessageType } from './matrix-client/models/MatrixMessage';
export class P2PCommunicationClient {
    constructor(name, keyPair, replicationCount, debug = false) {
        this.name = name;
        this.keyPair = keyPair;
        this.replicationCount = replicationCount;
        this.debug = debug;
        this.clients = [];
        this.KNOWN_RELAY_SERVERS = [
            'matrix.papers.tech'
            // 'matrix.tez.ie',
            // 'matrix-dev.papers.tech',
            // "matrix.stove-labs.com",
            // "yadayada.cryptonomic-infra.tech"
        ];
        this.activeListeners = new Map();
    }
    getHandshakeInfo() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                name: this.name,
                publicKey: yield this.getPublicKey(),
                relayServer: yield this.getRelayServer()
            };
        });
    }
    getRelayServer(publicKeyHash, nonce = '') {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.keyPair) {
                throw new Error('KeyPair not available');
            }
            const hash = publicKeyHash || (yield getHexHash(this.keyPair.publicKey));
            return this.KNOWN_RELAY_SERVERS.reduce((prevPromise, curr) => __awaiter(this, void 0, void 0, function* () {
                const prev = yield prevPromise;
                const prevRelayServerHash = yield getHexHash(prev + nonce);
                const currRelayServerHash = yield getHexHash(curr + nonce);
                const prevBigInt = yield this.getAbsoluteBigIntDifference(hash, prevRelayServerHash);
                const currBigInt = yield this.getAbsoluteBigIntDifference(hash, currRelayServerHash);
                return prevBigInt.isLessThan(currBigInt) ? prev : curr;
            }), Promise.resolve(this.KNOWN_RELAY_SERVERS[0]));
        });
    }
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.log('starting client');
            yield sodium.ready;
            const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));
            const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);
            yield this.log(`connecting to ${this.replicationCount} servers`);
            for (let i = 0; i < this.replicationCount; i++) {
                // TODO: Parallel
                const client = MatrixClient.create({
                    baseUrl: `https://${yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString())}`
                });
                client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter(this, void 0, void 0, function* () {
                    yield client.joinRooms(event.content.roomId);
                }));
                yield this.log('login', yield this.getPublicKeyHash(), 'on', yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString()));
                yield client
                    .start({
                    id: yield this.getPublicKeyHash(),
                    password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,
                    deviceId: toHex(this.keyPair.publicKey)
                })
                    .catch((error) => this.log(error));
                yield client.joinRooms(...client.invitedRooms).catch((error) => this.log(error));
                this.clients.push(client);
            }
        });
    }
    listenForEncryptedMessage(senderPublicKey, messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.keyPair) {
                throw new Error('KeyPair not available');
            }
            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);
            if (this.activeListeners.has(senderPublicKey)) {
                return;
            }
            const callbackFunction = (event) => __awaiter(this, void 0, void 0, function* () {
                if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {
                    const payload = Buffer.from(event.content.message.content, 'hex');
                    if (payload.length >=
                        sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {
                        try {
                            messageCallback(yield decryptCryptoboxPayload(payload, sharedRx));
                        }
                        catch (decryptionError) {
                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                        }
                    }
                }
            });
            this.activeListeners.set(senderPublicKey, callbackFunction);
            for (const client of this.clients) {
                client.subscribe(MatrixClientEventType.MESSAGE, callbackFunction);
            }
        });
    }
    unsubscribeFromEncryptedMessage(senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const listener = this.activeListeners.get(senderPublicKey);
            if (!listener) {
                return;
            }
            for (const client of this.clients) {
                client.unsubscribe(MatrixClientEventType.MESSAGE, listener);
            }
            this.activeListeners.delete(senderPublicKey);
        });
    }
    unsubscribeFromEncryptedMessages() {
        return __awaiter(this, void 0, void 0, function* () {
            for (const client of this.clients) {
                client.unsubscribe(MatrixClientEventType.MESSAGE);
            }
            this.activeListeners.clear();
        });
    }
    sendMessage(recipientPublicKey, message) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.keyPair) {
                throw new Error('KeyPair not available');
            }
            const { sharedTx } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);
            for (let i = 0; i < this.replicationCount; i++) {
                const recipientHash = yield getHexHash(Buffer.from(recipientPublicKey, 'hex'));
                const recipient = recipientString(recipientHash, yield this.getRelayServer(recipientHash, i.toString()));
                for (const client of this.clients) {
                    const room = yield this.getRelevantRoom(client, recipient);
                    client
                        .sendTextMessage(room.id, yield encryptCryptoboxPayload(message, sharedTx))
                        .catch((error) => this.log(error));
                }
            }
        });
    }
    listenForChannelOpening(messageCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            for (const client of this.clients) {
                client.subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter(this, void 0, void 0, function* () {
                    yield this.log('channel opening', event);
                    if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {
                        if (!this.keyPair) {
                            throw new Error('KeyPair not available');
                        }
                        yield this.log('new channel open event!');
                        const splits = event.content.message.content.split(':');
                        const payload = Buffer.from(splits[splits.length - 1], 'hex');
                        if (payload.length >=
                            sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {
                            try {
                                messageCallback(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));
                            }
                            catch (decryptionError) {
                                /* NO-OP. We try to decode every message, but some might not be addressed to us. */
                            }
                        }
                    }
                }));
            }
        });
    }
    openChannel(recipientPublicKey, relayServer) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.log('open channel');
            const recipientHash = yield getHexHash(Buffer.from(recipientPublicKey, 'hex'));
            const recipient = recipientString(recipientHash, relayServer);
            yield this.log(`currently there are ${this.clients.length} clients open`);
            for (const client of this.clients) {
                const room = yield this.getRelevantRoom(client, recipient);
                const encryptedMessage = yield sealCryptobox(yield this.getPublicKey(), Buffer.from(recipientPublicKey, 'hex'));
                client
                    .sendTextMessage(room.id, ['@channel-open', recipient, encryptedMessage].join(':'))
                    .catch((error) => this.log(error));
            }
        });
    }
    isTextMessage(content) {
        return content.message.type === MatrixMessageType.TEXT;
    }
    isChannelOpenMessage(content) {
        return __awaiter(this, void 0, void 0, function* () {
            return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);
        });
    }
    isSender(event, senderPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);
        });
    }
    getPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.keyPair) {
                throw new Error('KeyPair not available');
            }
            return toHex(this.keyPair.publicKey);
        });
    }
    getPublicKeyHash() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.keyPair) {
                throw new Error('KeyPair not available');
            }
            return getHexHash(this.keyPair.publicKey);
        });
    }
    getAbsoluteBigIntDifference(firstHash, secondHash) {
        return __awaiter(this, void 0, void 0, function* () {
            const difference = new BigNumber(`0x${firstHash}`).minus(`0x${secondHash}`);
            return difference.absoluteValue();
        });
    }
    createCryptoBox(otherPublicKey, selfPrivateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            // TODO: Don't calculate it every time?
            const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes
            const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes
            const kxOtherPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes
            return [
                Buffer.from(kxSelfPublicKey),
                Buffer.from(kxSelfPrivateKey),
                Buffer.from(kxOtherPublicKey)
            ];
        });
    }
    createCryptoBoxServer(otherPublicKey, selfPrivateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);
            return sodium.crypto_kx_server_session_keys(...keys);
        });
    }
    createCryptoBoxClient(otherPublicKey, selfPrivateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);
            return sodium.crypto_kx_client_session_keys(...keys);
        });
    }
    getRelevantRoom(client, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            const joinedRooms = client.joinedRooms;
            const relevantRooms = joinedRooms.filter((roomElement) => roomElement.members.some((member) => member === recipient));
            let room;
            if (relevantRooms.length === 0) {
                yield this.log(`no relevant rooms found`);
                const roomId = yield client.createTrustedPrivateRoom(recipient);
                room = client.getRoomById(roomId);
            }
            else {
                room = relevantRooms[0];
                yield this.log(`channel already open, reusing room ${room.id}`);
            }
            return room;
        });
    }
    log(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.debug) {
                console.log(`--- [P2PCommunicationClient]:${this.name}: `, ...args);
            }
        });
    }
}
//# sourceMappingURL=P2PCommunicationClient.js.map