import { Transport } from './transports/Transport';
import { ConnectionContext } from './types/ConnectionContext';
import { P2PPairInfo, AccountInfo, BeaconErrorMessage, PermissionResponseOutput, OperationResponseOutput, BroadcastResponseOutput, SignPayloadResponseOutput, Network } from '.';
export declare enum BeaconEvent {
    PERMISSION_REQUEST_SENT = "PERMISSION_REQUEST_SENT",
    PERMISSION_REQUEST_SUCCESS = "PERMISSION_REQUEST_SUCCESS",
    PERMISSION_REQUEST_ERROR = "PERMISSION_REQUEST_ERROR",
    OPERATION_REQUEST_SENT = "OPERATION_REQUEST_SENT",
    OPERATION_REQUEST_SUCCESS = "OPERATION_REQUEST_SUCCESS",
    OPERATION_REQUEST_ERROR = "OPERATION_REQUEST_ERROR",
    SIGN_REQUEST_SENT = "SIGN_REQUEST_SENT",
    SIGN_REQUEST_SUCCESS = "SIGN_REQUEST_SUCCESS",
    SIGN_REQUEST_ERROR = "SIGN_REQUEST_ERROR",
    BROADCAST_REQUEST_SENT = "BROADCAST_REQUEST_SENT",
    BROADCAST_REQUEST_SUCCESS = "BROADCAST_REQUEST_SUCCESS",
    BROADCAST_REQUEST_ERROR = "BROADCAST_REQUEST_ERROR",
    LOCAL_RATE_LIMIT_REACHED = "LOCAL_RATE_LIMIT_REACHED",
    NO_PERMISSIONS = "NO_PERMISSIONS",
    ACTIVE_ACCOUNT_SET = "ACTIVE_ACCOUNT_SET",
    ACTIVE_TRANSPORT_SET = "ACTIVE_TRANSPORT_SET",
    P2P_CHANNEL_CONNECT_SUCCESS = "P2P_CHANNEL_CONNECT_SUCCESS",
    P2P_LISTEN_FOR_CHANNEL_OPEN = "P2P_LISTEN_FOR_CHANNEL_OPEN",
    INTERNAL_ERROR = "INTERNAL_ERROR",
    UNKNOWN = "UNKNOWN"
}
export interface BeaconEventType {
    [BeaconEvent.PERMISSION_REQUEST_SENT]: undefined;
    [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: {
        account: AccountInfo;
        output: PermissionResponseOutput;
        connectionContext: ConnectionContext;
    };
    [BeaconEvent.PERMISSION_REQUEST_ERROR]: BeaconErrorMessage;
    [BeaconEvent.OPERATION_REQUEST_SENT]: undefined;
    [BeaconEvent.OPERATION_REQUEST_SUCCESS]: {
        account: AccountInfo;
        output: OperationResponseOutput;
        connectionContext: ConnectionContext;
    };
    [BeaconEvent.OPERATION_REQUEST_ERROR]: BeaconErrorMessage;
    [BeaconEvent.SIGN_REQUEST_SENT]: undefined;
    [BeaconEvent.SIGN_REQUEST_SUCCESS]: {
        output: SignPayloadResponseOutput;
        connectionContext: ConnectionContext;
    };
    [BeaconEvent.SIGN_REQUEST_ERROR]: BeaconErrorMessage;
    [BeaconEvent.BROADCAST_REQUEST_SENT]: undefined;
    [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: {
        network: Network;
        output: BroadcastResponseOutput;
        connectionContext: ConnectionContext;
    };
    [BeaconEvent.BROADCAST_REQUEST_ERROR]: BeaconErrorMessage;
    [BeaconEvent.PERMISSION_REQUEST_SENT]: undefined;
    [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: undefined;
    [BeaconEvent.NO_PERMISSIONS]: undefined;
    [BeaconEvent.ACTIVE_ACCOUNT_SET]: AccountInfo;
    [BeaconEvent.ACTIVE_TRANSPORT_SET]: Transport;
    [BeaconEvent.P2P_CHANNEL_CONNECT_SUCCESS]: P2PPairInfo;
    [BeaconEvent.P2P_LISTEN_FOR_CHANNEL_OPEN]: P2PPairInfo;
    [BeaconEvent.INTERNAL_ERROR]: string;
    [BeaconEvent.UNKNOWN]: undefined;
}
export declare type BeaconEventHandlerFunction<T = unknown> = (data: T) => void | Promise<void>;
export declare const defaultEventCallbacks: {
    [key in BeaconEvent]: BeaconEventHandlerFunction<BeaconEventType[key]>;
};
export declare class BeaconEventHandler {
    private readonly callbackMap;
    constructor(eventsToOverride?: {
        [key in BeaconEvent]?: {
            handler: BeaconEventHandlerFunction<BeaconEventType[key]>;
        };
    });
    on<K extends BeaconEvent>(event: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;
    emit<K extends BeaconEvent>(event: K, data?: BeaconEventType[K]): Promise<void>;
    private overrideDefaults;
}
