var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { MatrixClientStore } from './MatrixClientStore';
import { MatrixHttpClient } from './MatrixHttpClient';
import { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';
import { MatrixRoomService } from './services/MatrixRoomService';
import { MatrixUserService } from './services/MatrixUserService';
import { MatrixEventService } from './services/MatrixEventService';
import { MatrixClientEventEmitter } from './MatrixClientEventEmitter';
const MAX_POLLING_RETRIES = 3;
export class MatrixClient {
    constructor(store, eventEmitter, userService, roomService, eventService) {
        this.store = store;
        this.eventEmitter = eventEmitter;
        this.userService = userService;
        this.roomService = roomService;
        this.eventService = eventService;
        this.store.onStateChanged((oldState, newState, stateChange) => {
            this.eventEmitter.onStateChanged(oldState, newState, stateChange);
        }, 'rooms');
    }
    static create(config) {
        const store = MatrixClientStore.createLocal();
        const eventEmitter = new MatrixClientEventEmitter();
        const httpClient = new MatrixHttpClient(config.baseUrl);
        const accountService = new MatrixUserService(httpClient);
        const roomService = new MatrixRoomService(httpClient);
        const eventService = new MatrixEventService(httpClient);
        return new MatrixClient(store, eventEmitter, accountService, roomService, eventService);
    }
    get joinedRooms() {
        return Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.JOINED);
    }
    get invitedRooms() {
        return Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.INVITED);
    }
    get leftRooms() {
        return Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.LEFT);
    }
    start(user) {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.userService.login(user.id, user.password, user.deviceId);
            this.store.update({
                accessToken: response.access_token
            });
            return new Promise((resolve, reject) => {
                this.poll(0, (pollingResponse) => {
                    if (!this.store.get('isRunning')) {
                        resolve();
                    }
                    this.store.update({
                        isRunning: true,
                        syncToken: pollingResponse.next_batch,
                        pollingTimeout: 30000,
                        pollingRetries: 0,
                        rooms: MatrixRoom.fromSync(pollingResponse.rooms)
                    });
                }, (error) => {
                    if (!this.store.get('isRunning')) {
                        reject(error);
                    }
                    this.store.update({
                        isRunning: false,
                        pollingRetries: this.store.get('pollingRetries') + 1
                    });
                });
            });
        });
    }
    subscribe(event, listener) {
        this.eventEmitter.on(event, listener);
    }
    unsubscribe(event, listener) {
        if (listener) {
            this.eventEmitter.removeListener(event, listener);
        }
        else {
            this.eventEmitter.removeAllListeners(event);
        }
    }
    getRoomById(id) {
        return this.store.getRoom(id);
    }
    createTrustedPrivateRoom(...members) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requiresAuthorization('createRoom', (accessToken) => __awaiter(this, void 0, void 0, function* () {
                const response = yield this.roomService.createRoom(accessToken, {
                    invite: members,
                    preset: 'trusted_private_chat',
                    is_direct: true
                });
                return response.room_id;
            }));
        });
    }
    inviteToRooms(user, ...roomsOrIds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requiresAuthorization('invite', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {
                const room = this.store.getRoom(roomOrId);
                this.roomService
                    .inviteToRoom(accessToken, user, room)
                    .catch((error) => console.warn(error));
            })));
        });
    }
    joinRooms(...roomsOrIds) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.requiresAuthorization('join', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {
                const room = this.store.getRoom(roomOrId);
                return this.roomService.joinRoom(accessToken, room).catch((error) => console.warn(error));
            })));
        });
    }
    sendTextMessage(roomOrId, message) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.requiresAuthorization('send', (accessToken) => __awaiter(this, void 0, void 0, function* () {
                    const room = this.store.getRoom(roomOrId);
                    const txnId = this.createTxnId();
                    return this.eventService.sendMessage(accessToken, room, {
                        msgtype: 'm.text',
                        body: message
                    }, txnId);
                }));
            }
            catch (error) {
                console.error(error);
            }
        });
    }
    poll(interval, onSyncSuccess, onSyncError) {
        const store = this.store;
        const sync = this.sync.bind(this);
        const pollSync = () => __awaiter(this, void 0, void 0, function* () {
            let continueSyncing = false;
            try {
                const response = yield sync();
                onSyncSuccess(response);
                continueSyncing = true;
            }
            catch (error) {
                onSyncError(error);
                continueSyncing = store.get('pollingRetries') < MAX_POLLING_RETRIES;
                console.warn('Could not sync:', error);
                if (continueSyncing) {
                    console.log('Retry syncing...');
                }
            }
            finally {
                if (continueSyncing) {
                    setTimeout(pollSync, interval);
                }
                else {
                    throw new Error(`Max polling retries exeeded: ${MAX_POLLING_RETRIES}`);
                }
            }
        });
        pollSync();
    }
    sync() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.requiresAuthorization('sync', (accessToken) => __awaiter(this, void 0, void 0, function* () {
                return this.eventService.sync(accessToken, {
                    pollingTimeout: this.store.get('pollingTimeout'),
                    syncToken: this.store.get('syncToken')
                });
            }));
        });
    }
    requiresAuthorization(name, action) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.store.get('accessToken')) {
                return Promise.reject(`${name} requires authorization but no access token has been provided.`);
            }
            return action(this.store.get('accessToken'));
        });
    }
    createTxnId() {
        const timestamp = new Date().getTime();
        const counter = this.store.get('txnNo');
        this.store.update({
            txnNo: counter + 1
        });
        return `m${timestamp}.${counter}`;
    }
}
//# sourceMappingURL=MatrixClient.js.map