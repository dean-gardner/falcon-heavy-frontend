var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { openToast } from './alert/Toast';
import { openAlert } from './alert/Alert';
import { getQrData } from './utils/qr';
import { Logger } from './utils/Logger';
import { BeaconError } from './errors/BeaconError';
import { getAccountBlockExplorerLinkForNetwork, getTransactionBlockExplorerLinkForNetwork } from './utils/block-explorer';
import { UnknownBeaconError } from '.';
const logger = new Logger('BeaconEvents');
export var BeaconEvent;
(function (BeaconEvent) {
    BeaconEvent["PERMISSION_REQUEST_SENT"] = "PERMISSION_REQUEST_SENT";
    BeaconEvent["PERMISSION_REQUEST_SUCCESS"] = "PERMISSION_REQUEST_SUCCESS";
    BeaconEvent["PERMISSION_REQUEST_ERROR"] = "PERMISSION_REQUEST_ERROR";
    BeaconEvent["OPERATION_REQUEST_SENT"] = "OPERATION_REQUEST_SENT";
    BeaconEvent["OPERATION_REQUEST_SUCCESS"] = "OPERATION_REQUEST_SUCCESS";
    BeaconEvent["OPERATION_REQUEST_ERROR"] = "OPERATION_REQUEST_ERROR";
    BeaconEvent["SIGN_REQUEST_SENT"] = "SIGN_REQUEST_SENT";
    BeaconEvent["SIGN_REQUEST_SUCCESS"] = "SIGN_REQUEST_SUCCESS";
    BeaconEvent["SIGN_REQUEST_ERROR"] = "SIGN_REQUEST_ERROR";
    BeaconEvent["BROADCAST_REQUEST_SENT"] = "BROADCAST_REQUEST_SENT";
    BeaconEvent["BROADCAST_REQUEST_SUCCESS"] = "BROADCAST_REQUEST_SUCCESS";
    BeaconEvent["BROADCAST_REQUEST_ERROR"] = "BROADCAST_REQUEST_ERROR";
    BeaconEvent["LOCAL_RATE_LIMIT_REACHED"] = "LOCAL_RATE_LIMIT_REACHED";
    BeaconEvent["NO_PERMISSIONS"] = "NO_PERMISSIONS";
    BeaconEvent["ACTIVE_ACCOUNT_SET"] = "ACTIVE_ACCOUNT_SET";
    BeaconEvent["ACTIVE_TRANSPORT_SET"] = "ACTIVE_TRANSPORT_SET";
    BeaconEvent["P2P_CHANNEL_CONNECT_SUCCESS"] = "P2P_CHANNEL_CONNECT_SUCCESS";
    BeaconEvent["P2P_LISTEN_FOR_CHANNEL_OPEN"] = "P2P_LISTEN_FOR_CHANNEL_OPEN";
    BeaconEvent["INTERNAL_ERROR"] = "INTERNAL_ERROR";
    BeaconEvent["UNKNOWN"] = "UNKNOWN";
})(BeaconEvent || (BeaconEvent = {}));
const showSentToast = () => __awaiter(void 0, void 0, void 0, function* () {
    openToast({ body: 'Request sent', timer: 3000 }).catch((toastError) => console.error(toastError));
});
const showNoPermissionAlert = () => __awaiter(void 0, void 0, void 0, function* () {
    yield openAlert({
        title: 'No Permission',
        body: 'Please allow the wallet to handle this type of request.'
    });
});
const showErrorAlert = (beaconError) => __awaiter(void 0, void 0, void 0, function* () {
    const error = beaconError.errorType
        ? BeaconError.getError(beaconError.errorType)
        : new UnknownBeaconError();
    yield openAlert({
        title: error.title,
        body: error.description
    });
});
const showRateLimitReached = () => __awaiter(void 0, void 0, void 0, function* () {
    openToast({
        body: 'Rate limit reached. Please slow down',
        timer: 3000
    }).catch((toastError) => console.error(toastError));
});
const showBeaconConnectedAlert = () => __awaiter(void 0, void 0, void 0, function* () {
    yield openAlert({
        title: 'Success',
        body: 'A wallet has been paired over the beacon network.',
        confirmButtonText: 'Done',
        timer: 1500
    });
});
const showInternalErrorAlert = (data) => __awaiter(void 0, void 0, void 0, function* () {
    const alertConfig = {
        title: 'Internal Error',
        confirmButtonText: 'Done',
        body: `${data}`,
        confirmCallback: () => undefined
    };
    yield openAlert(alertConfig);
});
const showQrCode = (data) => __awaiter(void 0, void 0, void 0, function* () {
    const dataString = JSON.stringify(data);
    console.log(dataString);
    const alertConfig = {
        title: 'Pair with Wallet',
        confirmButtonText: 'Done',
        body: `${getQrData(dataString, 'svg')}<p>Connect wallet by scanning the QR code or clicking the link button <a href="https://docs.walletbeacon.io/supported-wallets.html" target="_blank">Learn&nbsp;more</a></p>`,
        confirmCallback: () => undefined
    };
    yield openAlert(alertConfig);
});
const showPermissionSuccessAlert = (data) => __awaiter(void 0, void 0, void 0, function* () {
    const { account, output } = data;
    const alertConfig = {
        title: 'Permission Granted',
        body: `We received permissions for the address <strong>${output.address}</strong>
    <br>
    <br>
    Network: <strong>${output.network.type}</strong>
    <br>
    Permissions: <strong>${output.scopes}</strong>`,
        confirmButtonText: 'Done',
        confirmCallback: () => undefined,
        actionButtonText: 'Open Blockexplorer',
        actionCallback: () => __awaiter(void 0, void 0, void 0, function* () {
            const link = yield getAccountBlockExplorerLinkForNetwork(account.network, output.address);
            window.open(link, '_blank');
        })
    };
    yield openAlert(alertConfig);
});
const showOperationSuccessAlert = (data) => __awaiter(void 0, void 0, void 0, function* () {
    const { account, output } = data;
    const alertConfig = {
        title: 'Operation Broadcasted',
        body: `The transaction has successfully been broadcasted to the network with the following hash. <strong>${output.transactionHash}</strong>`,
        confirmButtonText: 'Done',
        confirmCallback: () => undefined,
        actionButtonText: 'Open Blockexplorer',
        actionCallback: () => __awaiter(void 0, void 0, void 0, function* () {
            const link = yield getTransactionBlockExplorerLinkForNetwork(account.network, output.transactionHash);
            window.open(link, '_blank');
        })
    };
    yield openAlert(alertConfig);
});
const showSignSuccessAlert = (data) => __awaiter(void 0, void 0, void 0, function* () {
    const output = data.output;
    const alertConfig = {
        title: 'Payload signed',
        body: `The payload has successfully been signed.
    <br>
    Signature: <strong>${output.signature}</strong>`,
        confirmButtonText: 'Done',
        confirmCallback: () => undefined
    };
    yield openAlert(alertConfig);
});
const showBroadcastSuccessAlert = (data) => __awaiter(void 0, void 0, void 0, function* () {
    const { network, output } = data;
    const alertConfig = {
        title: 'Broadcasted',
        body: `The transaction has successfully been broadcasted to the network with the following hash. <strong>${output.transactionHash}</strong>`,
        confirmButtonText: 'Done',
        confirmCallback: () => undefined,
        actionButtonText: 'Open Blockexplorer',
        actionCallback: () => __awaiter(void 0, void 0, void 0, function* () {
            const link = yield getTransactionBlockExplorerLinkForNetwork(network, output.transactionHash);
            window.open(link, '_blank');
        })
    };
    yield openAlert(alertConfig);
});
const emptyHandler = (eventType) => (data) => __awaiter(void 0, void 0, void 0, function* () {
    logger.log('emptyHandler', eventType, data);
});
export const defaultEventCallbacks = {
    [BeaconEvent.PERMISSION_REQUEST_SENT]: showSentToast,
    [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: showPermissionSuccessAlert,
    [BeaconEvent.PERMISSION_REQUEST_ERROR]: showErrorAlert,
    [BeaconEvent.OPERATION_REQUEST_SENT]: showSentToast,
    [BeaconEvent.OPERATION_REQUEST_SUCCESS]: showOperationSuccessAlert,
    [BeaconEvent.OPERATION_REQUEST_ERROR]: showErrorAlert,
    [BeaconEvent.SIGN_REQUEST_SENT]: showSentToast,
    [BeaconEvent.SIGN_REQUEST_SUCCESS]: showSignSuccessAlert,
    [BeaconEvent.SIGN_REQUEST_ERROR]: showErrorAlert,
    [BeaconEvent.BROADCAST_REQUEST_SENT]: showSentToast,
    [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: showBroadcastSuccessAlert,
    [BeaconEvent.BROADCAST_REQUEST_ERROR]: showErrorAlert,
    [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: showRateLimitReached,
    [BeaconEvent.NO_PERMISSIONS]: showNoPermissionAlert,
    [BeaconEvent.ACTIVE_ACCOUNT_SET]: emptyHandler(BeaconEvent.ACTIVE_ACCOUNT_SET),
    [BeaconEvent.ACTIVE_TRANSPORT_SET]: emptyHandler(BeaconEvent.ACTIVE_TRANSPORT_SET),
    [BeaconEvent.P2P_CHANNEL_CONNECT_SUCCESS]: showBeaconConnectedAlert,
    [BeaconEvent.P2P_LISTEN_FOR_CHANNEL_OPEN]: showQrCode,
    [BeaconEvent.INTERNAL_ERROR]: showInternalErrorAlert,
    [BeaconEvent.UNKNOWN]: emptyHandler(BeaconEvent.UNKNOWN)
};
export class BeaconEventHandler {
    constructor(eventsToOverride = {}) {
        this.callbackMap = {
            [BeaconEvent.PERMISSION_REQUEST_SENT]: [defaultEventCallbacks.PERMISSION_REQUEST_SENT],
            [BeaconEvent.PERMISSION_REQUEST_SUCCESS]: [defaultEventCallbacks.PERMISSION_REQUEST_SUCCESS],
            [BeaconEvent.PERMISSION_REQUEST_ERROR]: [defaultEventCallbacks.PERMISSION_REQUEST_ERROR],
            [BeaconEvent.OPERATION_REQUEST_SENT]: [defaultEventCallbacks.OPERATION_REQUEST_SENT],
            [BeaconEvent.OPERATION_REQUEST_SUCCESS]: [defaultEventCallbacks.OPERATION_REQUEST_SUCCESS],
            [BeaconEvent.OPERATION_REQUEST_ERROR]: [defaultEventCallbacks.OPERATION_REQUEST_ERROR],
            [BeaconEvent.SIGN_REQUEST_SENT]: [defaultEventCallbacks.SIGN_REQUEST_SENT],
            [BeaconEvent.SIGN_REQUEST_SUCCESS]: [defaultEventCallbacks.SIGN_REQUEST_SUCCESS],
            [BeaconEvent.SIGN_REQUEST_ERROR]: [defaultEventCallbacks.SIGN_REQUEST_ERROR],
            [BeaconEvent.BROADCAST_REQUEST_SENT]: [defaultEventCallbacks.BROADCAST_REQUEST_SENT],
            [BeaconEvent.BROADCAST_REQUEST_SUCCESS]: [defaultEventCallbacks.BROADCAST_REQUEST_SUCCESS],
            [BeaconEvent.BROADCAST_REQUEST_ERROR]: [defaultEventCallbacks.BROADCAST_REQUEST_ERROR],
            [BeaconEvent.LOCAL_RATE_LIMIT_REACHED]: [defaultEventCallbacks.LOCAL_RATE_LIMIT_REACHED],
            [BeaconEvent.NO_PERMISSIONS]: [defaultEventCallbacks.NO_PERMISSIONS],
            [BeaconEvent.ACTIVE_ACCOUNT_SET]: [defaultEventCallbacks.ACTIVE_ACCOUNT_SET],
            [BeaconEvent.ACTIVE_TRANSPORT_SET]: [defaultEventCallbacks.ACTIVE_TRANSPORT_SET],
            [BeaconEvent.P2P_CHANNEL_CONNECT_SUCCESS]: [defaultEventCallbacks.P2P_CHANNEL_CONNECT_SUCCESS],
            [BeaconEvent.P2P_LISTEN_FOR_CHANNEL_OPEN]: [defaultEventCallbacks.P2P_LISTEN_FOR_CHANNEL_OPEN],
            [BeaconEvent.INTERNAL_ERROR]: [defaultEventCallbacks.INTERNAL_ERROR],
            [BeaconEvent.UNKNOWN]: [defaultEventCallbacks.UNKNOWN]
        };
        this.overrideDefaults(eventsToOverride).catch((overrideError) => {
            logger.error('constructor', overrideError);
        });
    }
    on(event, eventCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const listeners = this.callbackMap[event] || [];
            listeners.push(eventCallback);
            this.callbackMap[event] = listeners;
        });
    }
    emit(event, data) {
        return __awaiter(this, void 0, void 0, function* () {
            const listeners = this.callbackMap[event];
            if (listeners && listeners.length > 0) {
                listeners.forEach((listener) => __awaiter(this, void 0, void 0, function* () {
                    try {
                        yield listener(data);
                    }
                    catch (listenerError) {
                        logger.error(`error handling event ${event}`, listenerError);
                    }
                }));
            }
        });
    }
    overrideDefaults(eventsToOverride) {
        return __awaiter(this, void 0, void 0, function* () {
            Object.keys(eventsToOverride).forEach((untypedEvent) => {
                const eventType = untypedEvent;
                const event = eventsToOverride[eventType];
                if (event) {
                    this.callbackMap[eventType] = [event.handler];
                }
            });
        });
    }
}
//# sourceMappingURL=events.js.map