var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ExposedPromise } from '../../utils/exposed-promise';
import { generateGUID } from '../../utils/generate-uuid';
import { getKeypairFromSeed, toHex } from '../../utils/crypto';
import { StorageKey } from '../..';
import { BeaconEventHandler } from '../../events';
import { SDK_VERSION } from '../../constants';
export class BeaconClient {
    constructor(config) {
        this._beaconId = new ExposedPromise();
        this.events = new BeaconEventHandler();
        this._keyPair = new ExposedPromise();
        this.name = config.name;
        this.storage = config.storage;
        this.initSDK().catch(console.error);
    }
    get beaconId() {
        return this._beaconId.promise;
    }
    get keyPair() {
        return this._keyPair.promise;
    }
    resetSDK() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.removeBeaconEntriesFromStorage();
        });
    }
    initSDK() {
        return __awaiter(this, void 0, void 0, function* () {
            this.storage.set(StorageKey.BEACON_SDK_VERSION, SDK_VERSION).catch(console.error);
            this.loadOrCreateBeaconSecret().catch(console.error);
            return this.keyPair.then((keyPair) => {
                this._beaconId.resolve(toHex(keyPair.publicKey));
            });
        });
    }
    removeBeaconEntriesFromStorage() {
        return __awaiter(this, void 0, void 0, function* () {
            const allKeys = Object.values(StorageKey);
            yield Promise.all(allKeys.map((key) => this.storage.delete(key)));
        });
    }
    loadOrCreateBeaconSecret() {
        return __awaiter(this, void 0, void 0, function* () {
            const storageValue = yield this.storage.get(StorageKey.BEACON_SDK_SECRET_SEED);
            if (storageValue && typeof storageValue === 'string') {
                this._keyPair.resolve(yield getKeypairFromSeed(storageValue));
            }
            else {
                const key = generateGUID();
                yield this.storage.set(StorageKey.BEACON_SDK_SECRET_SEED, key);
                this._keyPair.resolve(yield getKeypairFromSeed(key));
            }
        });
    }
}
//# sourceMappingURL=BeaconClient.js.map