var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ExposedPromise, ExposedPromiseStatus } from '../../utils/exposed-promise';
import { Serializer, PostMessageTransport, P2PTransport, TransportType, TransportStatus } from '../..';
import { BeaconEventHandler, BeaconEvent } from '../../events';
import { isChromeExtensionInstalled } from '../../utils/is-extension-installed';
import { BeaconClient } from '../beacon-client/BeaconClient';
import { AccountManager } from '../../managers/AccountManager';
export class Client extends BeaconClient {
    constructor(config) {
        super({ name: config.name, storage: config.storage });
        this.requestCounter = [];
        this.rateLimit = 2;
        this.rateLimitWindowInSeconds = 5;
        this._transport = new ExposedPromise();
        this._isConnected = new ExposedPromise();
        this.events = new BeaconEventHandler(config.eventHandlers);
        this.accountManager = new AccountManager(config.storage);
        this.handleResponse = (message, connectionInfo) => {
            throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);
        };
    }
    get transport() {
        return this._transport.promise;
    }
    get isConnected() {
        return this._isConnected.promise;
    }
    get ready() {
        return this.transport.then(() => undefined);
    }
    getAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.getAccounts();
        });
    }
    getAccount(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.getAccount(accountIdentifier);
        });
    }
    removeAccount(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.removeAccount(accountIdentifier);
        });
    }
    removeAllAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.accountManager.removeAllAccounts();
        });
    }
    addRequestAndCheckIfRateLimited() {
        return __awaiter(this, void 0, void 0, function* () {
            const now = new Date().getTime();
            this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1000 > now);
            this.requestCounter.push(now);
            return this.requestCounter.length > this.rateLimit;
        });
    }
    init(isDapp = true, transport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {
                return (yield this.transport).type;
            }
            if (transport) {
                yield this.setTransport(transport); // Let users define their own transport
                return transport.type;
            }
            else {
                return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                    const keyPair = yield this.keyPair; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues
                    const setTransport = (newTransport) => __awaiter(this, void 0, void 0, function* () {
                        yield this.setTransport(newTransport);
                        resolve(newTransport.type);
                    });
                    const setBeaconTransport = () => __awaiter(this, void 0, void 0, function* () {
                        const newTransport = new P2PTransport(this.name, keyPair, this.storage, this.events, isDapp);
                        return setTransport(newTransport);
                    });
                    const setBeaconTransportTimeout = setTimeout(setBeaconTransport, 200);
                    return isChromeExtensionInstalled.then((postMessageAvailable) => __awaiter(this, void 0, void 0, function* () {
                        if (postMessageAvailable) {
                            if (setBeaconTransportTimeout) {
                                clearTimeout(setBeaconTransportTimeout);
                            }
                            return setTransport(new PostMessageTransport(this.name));
                        }
                    }));
                }));
            }
        });
    }
    getPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.transport).type === TransportType.P2P) {
                return (yield this.transport).getPeers();
            }
            else {
                return [];
            }
        });
    }
    addPeer(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.transport).type === TransportType.P2P) {
                return (yield this.transport).addPeer(id);
            }
        });
    }
    _connect() {
        return __awaiter(this, void 0, void 0, function* () {
            const transport = yield this.transport;
            if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {
                yield transport.connect();
                transport
                    .addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {
                    if (typeof message === 'string') {
                        const deserializedMessage = (yield new Serializer().deserialize(message));
                        this.handleResponse(deserializedMessage, connectionInfo);
                    }
                }))
                    .catch((error) => console.log(error));
                this._isConnected.resolve(true);
            }
            else if (transport.connectionStatus === TransportStatus.CONNECTING) {
                yield transport.reconnect();
            }
            else {
                // NO-OP
            }
            return this._isConnected.promise;
        });
    }
    setTransport(transport) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._transport.isSettled()) {
                // If the promise has already been resolved we need to create a new one.
                this._transport = ExposedPromise.resolve(transport);
            }
            else {
                this._transport.resolve(transport);
            }
            yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);
        });
    }
}
//# sourceMappingURL=Client.js.map