var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Serializer, Client, LocalStorage, TransportType } from '../..';
import { PermissionManager } from '../../managers/PermissionManager';
import { AppMetadataManager } from '../../managers/AppMetadataManager';
import { IncomingBeaconMessageInterceptor } from '../../interceptors/IncomingBeaconMessageInterceptor';
import { OutgoingBeaconMessageInterceptor } from '../../interceptors/OutgoingBeaconMessageInterceptor';
export class WalletClient extends Client {
    constructor(config) {
        super({ name: config.name, storage: new LocalStorage() });
        this.pendingRequests = [];
        this.permissionManager = new PermissionManager(new LocalStorage());
        this.appMetadataManager = new AppMetadataManager(new LocalStorage());
    }
    init() {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super.init.call(this, false);
        });
    }
    connect(newMessageCallback) {
        const _super = Object.create(null, {
            _connect: { get: () => super._connect }
        });
        return __awaiter(this, void 0, void 0, function* () {
            this.handleResponse = (message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {
                if (!this.pendingRequests.some((request) => request.id === message.id)) {
                    this.pendingRequests.push(message);
                    yield IncomingBeaconMessageInterceptor.intercept({
                        message,
                        connectionInfo,
                        appMetadataManager: this.appMetadataManager,
                        interceptorCallback: newMessageCallback
                    });
                }
            });
            return _super._connect.call(this);
        });
    }
    respond(message) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log('responding to message', message);
            const request = this.pendingRequests.find((pendingRequest) => pendingRequest.id === message.id);
            if (!request) {
                throw new Error('No matching request found!');
            }
            this.pendingRequests = this.pendingRequests.filter((pendingRequest) => pendingRequest.id !== message.id);
            yield OutgoingBeaconMessageInterceptor.intercept({
                beaconId: yield this.beaconId,
                request,
                message,
                permissionManager: this.permissionManager,
                appMetadataManager: this.appMetadataManager,
                interceptorCallback: (response) => __awaiter(this, void 0, void 0, function* () {
                    yield this.respondToMessage(response);
                })
            });
        });
    }
    getAppMetadataList() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.getAppMetadataList();
        });
    }
    getAppMetadata(beaconId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.getAppMetadata(beaconId);
        });
    }
    removeAppMetadata(beaconId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.removeAppMetadata(beaconId);
        });
    }
    removeAllAppMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.appMetadataManager.removeAllAppMetadata();
        });
    }
    getPermissions() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.getPermissions();
        });
    }
    getPermission(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.getPermission(accountIdentifier);
        });
    }
    removePermission(accountIdentifier) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.removePermission(accountIdentifier);
        });
    }
    removeAllPermissions() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.permissionManager.removeAllPermissions();
        });
    }
    removePeer(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.transport).type === TransportType.P2P) {
                const removePeerResult = (yield this.transport).removePeer(id);
                yield this.removePermissionsForPeers([id]);
                return removePeerResult;
            }
        });
    }
    removeAllPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.transport).type === TransportType.P2P) {
                const peers = yield (yield this.transport).getPeers();
                const removePeerResult = (yield this.transport).removeAllPeers();
                yield this.removePermissionsForPeers(peers);
                return removePeerResult;
            }
        });
    }
    removePermissionsForPeers(peersToRemove) {
        return __awaiter(this, void 0, void 0, function* () {
            const permissions = yield this.permissionManager.getPermissions();
            const peerIdsToRemove = peersToRemove.map((peer) => peer.publicKey);
            // Remove all permissions with origin of the specified peer
            const permissionsToRemove = permissions.filter((permission) => peerIdsToRemove.includes(permission.appMetadata.beaconId));
            const permissionIdentifiersToRemove = permissionsToRemove.map((permissionInfo) => permissionInfo.accountIdentifier);
            yield this.permissionManager.removePermissions(permissionIdentifiersToRemove);
        });
    }
    respondToMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const serializedMessage = yield new Serializer().serialize(message);
            yield (yield this.transport).send(serializedMessage);
        });
    }
}
//# sourceMappingURL=WalletClient.js.map