var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ExposedPromise } from '../../utils/exposed-promise';
import { Logger } from '../../utils/Logger';
import { generateGUID } from '../../utils/generate-uuid';
import { BeaconEvent } from '../../events';
import { BEACON_VERSION } from '../../constants';
import { getAddressFromPublicKey } from '../../utils/crypto';
import { Client, TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Serializer, LocalStorage, BeaconError } from '../..';
import { messageEvents } from '../../beacon-message-events';
import { checkPermissions } from '../../utils/check-permissions';
import { getAccountIdentifier } from '../../utils/get-account-identifier';
const logger = new Logger('DAppClient');
export class DAppClient extends Client {
    constructor(config) {
        super(Object.assign({ storage: config.storage ? config.storage : new LocalStorage() }, config));
        this.openRequests = new Map();
        this._activeAccount = new ExposedPromise();
        this.iconUrl = config.iconUrl;
        this.storage
            .get(StorageKey.ACTIVE_ACCOUNT)
            .then((activeAccountIdentifier) => __awaiter(this, void 0, void 0, function* () {
            if (activeAccountIdentifier) {
                yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));
            }
            else {
                yield this.setActiveAccount(undefined);
            }
        }))
            .catch((storageError) => __awaiter(this, void 0, void 0, function* () {
            yield this.setActiveAccount(undefined);
            console.error(storageError);
        }));
        this.handleResponse = (event, connectionInfo) => {
            const openRequest = this.openRequests.get(event.id);
            if (openRequest) {
                logger.log('handleResponse', 'found openRequest', event.id);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                const errorMessage = event;
                if (errorMessage.errorType) {
                    openRequest.reject(errorMessage);
                }
                else {
                    openRequest.resolve({ message: event, connectionInfo });
                }
                this.openRequests.delete(event.id);
            }
            else {
                logger.error('handleResponse', 'no request found for id ', event.id);
            }
        };
    }
    get isConnected() {
        return this._isConnected.promise;
    }
    addOpenRequest(id, promise) {
        logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);
        this.openRequests.set(id, promise);
    }
    init(_isDapp, transport) {
        const _super = Object.create(null, {
            init: { get: () => super.init }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const initResponse = yield _super.init.call(this, true, transport);
            return initResponse;
        });
    }
    getActiveAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._activeAccount.promise;
        });
    }
    setActiveAccount(account) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._activeAccount.isSettled()) {
                // If the promise has already been resolved we need to create a new one.
                this._activeAccount = ExposedPromise.resolve(account);
            }
            else {
                this._activeAccount.resolve(account);
            }
            yield this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);
            yield this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);
            return;
        });
    }
    getAppMetadata() {
        return __awaiter(this, void 0, void 0, function* () {
            return {
                beaconId: yield this.beaconId,
                name: this.name,
                icon: this.iconUrl
            };
        });
    }
    connect() {
        const _super = Object.create(null, {
            _connect: { get: () => super._connect }
        });
        return __awaiter(this, void 0, void 0, function* () {
            return _super._connect.call(this);
        });
    }
    removeAccount(accountIdentifier) {
        const _super = Object.create(null, {
            removeAccount: { get: () => super.removeAccount }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);
            const activeAccount = yield this.getActiveAccount();
            if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {
                yield this.setActiveAccount(undefined);
            }
            return removeAccountResult;
        });
    }
    removeAllAccounts() {
        const _super = Object.create(null, {
            removeAllAccounts: { get: () => super.removeAllAccounts }
        });
        return __awaiter(this, void 0, void 0, function* () {
            yield _super.removeAllAccounts.call(this);
            yield this.setActiveAccount(undefined);
        });
    }
    removePeer(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.transport).type === TransportType.P2P) {
                const removePeerResult = (yield this.transport).removePeer(id);
                yield this.removeAccountsForPeers([id]);
                return removePeerResult;
            }
        });
    }
    removeAllPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            if ((yield this.transport).type === TransportType.P2P) {
                const peers = yield (yield this.transport).getPeers();
                const removePeerResult = (yield this.transport).removeAllPeers();
                yield this.removeAccountsForPeers(peers);
                return removePeerResult;
            }
        });
    }
    subscribeToEvent(internalEvent, eventCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.events.on(internalEvent, eventCallback);
        });
    }
    checkPermissions(type) {
        return __awaiter(this, void 0, void 0, function* () {
            if (type === BeaconMessageType.PermissionRequest) {
                return true;
            }
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount) {
                throw this.sendInternalError('No active account set!');
            }
            const permissions = activeAccount.scopes;
            return checkPermissions(type, permissions);
        });
    }
    /**
     * Permission request
     */
    requestPermissions(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const request = {
                appMetadata: yield this.getAppMetadata(),
                type: BeaconMessageType.PermissionRequest,
                network: input && input.network ? input.network : { type: NetworkType.MAINNET },
                scopes: input && input.scopes
                    ? input.scopes
                    : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw this.handleRequestError(request, requestError);
            }));
            // TODO: Migration code. Remove before 1.0.0 release.
            const publicKey = message.publicKey || message.pubkey || message.pubKey;
            const address = yield getAddressFromPublicKey(publicKey);
            const accountInfo = {
                accountIdentifier: yield getAccountIdentifier(address, message.network),
                beaconId: message.beaconId,
                origin: {
                    type: connectionInfo.origin,
                    id: connectionInfo.id
                },
                address,
                publicKey,
                network: message.network,
                scopes: message.scopes,
                connectedAt: new Date().getTime()
            };
            yield this.accountManager.addAccount(accountInfo);
            yield this.setActiveAccount(accountInfo);
            const { beaconId, network, scopes } = message;
            const output = { beaconId, publicKey, address, network, scopes };
            yield this.notifySuccess(request, {
                account: accountInfo,
                output,
                connectionContext: connectionInfo
            });
            return output;
        });
    }
    /**
     * Sign request
     */
    requestSignPayload(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!input.payload) {
                throw this.sendInternalError('Payload must be provided');
            }
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount) {
                throw this.sendInternalError('No active account!');
            }
            const request = {
                type: BeaconMessageType.SignPayloadRequest,
                payload: input.payload,
                sourceAddress: input.sourceAddress || activeAccount.address
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw this.handleRequestError(request, requestError);
            }));
            const { beaconId, signature } = message;
            const output = { beaconId, signature };
            yield this.notifySuccess(request, {
                account: activeAccount,
                output,
                connectionContext: connectionInfo
            });
            return output;
        });
    }
    /**
     * Operation request
     */
    requestOperation(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!input.operationDetails) {
                throw this.sendInternalError('Operation details must be provided');
            }
            const activeAccount = yield this.getActiveAccount();
            if (!activeAccount) {
                throw this.sendInternalError('No active account!');
            }
            const request = {
                type: BeaconMessageType.OperationRequest,
                network: input.network || activeAccount.network || { type: NetworkType.MAINNET },
                operationDetails: input.operationDetails,
                sourceAddress: activeAccount.address || ''
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw this.handleRequestError(request, requestError);
            }));
            const { beaconId, transactionHash } = message;
            const output = { beaconId, transactionHash };
            yield this.notifySuccess(request, {
                account: activeAccount,
                output,
                connectionContext: connectionInfo
            });
            return { beaconId, transactionHash };
        });
    }
    /**
     * Broadcast request
     */
    requestBroadcast(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!input.signedTransaction) {
                throw this.sendInternalError('Signed transaction must be provided');
            }
            const network = input.network || { type: NetworkType.MAINNET };
            const request = {
                type: BeaconMessageType.BroadcastRequest,
                network,
                signedTransaction: input.signedTransaction
            };
            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {
                throw this.handleRequestError(request, requestError);
            }));
            const { beaconId, transactionHash } = message;
            const output = { beaconId, transactionHash };
            yield this.notifySuccess(request, { network, output, connectionContext: connectionInfo });
            return { beaconId, transactionHash };
        });
    }
    sendInternalError(errorMessage) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.events.emit(BeaconEvent.INTERNAL_ERROR, errorMessage);
            throw new Error(errorMessage);
        });
    }
    removeAccountsForPeers(peersToRemove) {
        return __awaiter(this, void 0, void 0, function* () {
            const accounts = yield this.accountManager.getAccounts();
            const peerIdsToRemove = peersToRemove.map((peer) => peer.publicKey);
            // Remove all accounts with origin of the specified peer
            const accountsToRemove = accounts.filter((account) => peerIdsToRemove.includes(account.origin.id));
            const accountIdentifiersToRemove = accountsToRemove.map((accountInfo) => accountInfo.accountIdentifier);
            yield this.accountManager.removeAccounts(accountIdentifiersToRemove);
            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined
            const activeAccount = yield this.getActiveAccount();
            if (activeAccount) {
                if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {
                    yield this.setActiveAccount(undefined);
                }
            }
        });
    }
    handleRequestError(request, beaconError) {
        return __awaiter(this, void 0, void 0, function* () {
            if (beaconError.errorType) {
                this.events
                    .emit(messageEvents[request.type].error, beaconError)
                    .catch((emitError) => console.warn(emitError));
                throw BeaconError.getError(beaconError.errorType);
            }
            console.error('requestError', beaconError);
            throw beaconError;
        });
    }
    notifySuccess(request, response) {
        return __awaiter(this, void 0, void 0, function* () {
            this.events
                .emit(messageEvents[request.type].success, response)
                .catch((emitError) => console.warn(emitError));
        });
    }
    makeRequest(requestInput, account) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('makeRequest');
            yield this.init();
            logger.log('makeRequest', 'after init');
            yield this.connect();
            logger.log('makeRequest', 'after connecting');
            if (yield this.addRequestAndCheckIfRateLimited()) {
                this.events
                    .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                    .catch((emitError) => console.warn(emitError));
                throw new Error('rate limit reached');
            }
            if (!(yield this.checkPermissions(requestInput.type))) {
                this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError));
                throw new Error('No permissions to send this request to wallet!');
            }
            if (!this.beaconId) {
                throw this.sendInternalError('BeaconID not defined');
            }
            const request = Object.assign({ id: generateGUID(), version: BEACON_VERSION, beaconId: yield this.beaconId }, requestInput);
            const exposed = new ExposedPromise();
            this.addOpenRequest(request.id, exposed);
            const payload = yield new Serializer().serialize(request);
            let origin;
            if (account) {
                origin = account.origin.id;
            }
            yield (yield this.transport).send(payload, origin);
            this.events
                .emit(messageEvents[requestInput.type].sent)
                .catch((emitError) => console.warn(emitError));
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            return exposed.promise; // TODO: fix type
        });
    }
}
//# sourceMappingURL=DAppClient.js.map