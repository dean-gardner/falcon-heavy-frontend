var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Logger } from '../utils/Logger';
import { StorageKey, TransportStatus, Transport, TransportType, P2PCommunicationClient, Origin } from '..';
import { BeaconEvent } from '../events';
import { PeerManager } from '../managers/PeerManager';
const logger = new Logger('Transport');
export class P2PTransport extends Transport {
    constructor(name, keyPair, storage, events, isDapp) {
        super(name);
        this.type = TransportType.P2P;
        this.isDapp = true;
        // Make sure we only listen once
        this.listeningForChannelOpenings = false;
        this.keyPair = keyPair;
        this.storage = storage;
        this.events = events;
        this.isDapp = isDapp;
        this.client = new P2PCommunicationClient(this.name, this.keyPair, 1, false);
        this.peerManager = new PeerManager(storage);
    }
    static isAvailable() {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(true);
        });
    }
    connect() {
        const _super = Object.create(null, {
            connect: { get: () => super.connect }
        });
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('connect');
            this._isConnected = TransportStatus.CONNECTING;
            yield this.client.start();
            const knownPeers = yield this.peerManager.getPeers();
            if (knownPeers.length > 0) {
                logger.log('connect', `connecting to ${knownPeers.length} peers`);
                const connectionPromises = knownPeers.map((peer) => __awaiter(this, void 0, void 0, function* () { return this.listen(peer.publicKey); }));
                yield Promise.all(connectionPromises);
            }
            else {
                if (this.isDapp) {
                    yield this.connectNewPeer();
                }
            }
            yield _super.connect.call(this);
        });
    }
    reconnect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.isDapp) {
                yield this.connectNewPeer();
            }
        });
    }
    connectNewPeer() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('connectNewPeer');
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (!this.listeningForChannelOpenings) {
                    yield this.client.listenForChannelOpening((publicKey) => __awaiter(this, void 0, void 0, function* () {
                        logger.log('connectNewPeer', `new publicKey ${publicKey}`);
                        const newPeer = { name: '', publicKey, relayServer: '' };
                        if (!(yield this.peerManager.hasPeer(publicKey))) {
                            yield this.peerManager.addPeer(newPeer);
                            yield this.listen(publicKey);
                        }
                        this.events
                            .emit(BeaconEvent.P2P_CHANNEL_CONNECT_SUCCESS, newPeer)
                            .catch((emitError) => console.warn(emitError));
                        resolve();
                    }));
                    this.listeningForChannelOpenings = true;
                }
                this.events
                    .emit(BeaconEvent.P2P_LISTEN_FOR_CHANNEL_OPEN, yield this.client.getHandshakeInfo())
                    .catch((emitError) => console.warn(emitError));
            }));
        });
    }
    getPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.peerManager.getPeers();
        });
    }
    addPeer(newPeer) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!(yield this.peerManager.hasPeer(newPeer.publicKey))) {
                logger.log('addPeer', newPeer);
                yield this.peerManager.addPeer({
                    name: newPeer.name,
                    publicKey: newPeer.publicKey,
                    relayServer: newPeer.relayServer
                });
                yield this.client.openChannel(newPeer.publicKey, newPeer.relayServer); // TODO: Should we have a confirmation here?
                yield this.listen(newPeer.publicKey); // TODO: Prevent channels from being opened multiple times
            }
            else {
                logger.log('addPeer', 'peer already added, skipping', newPeer);
            }
        });
    }
    removePeer(peerToBeRemoved) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('removePeer', peerToBeRemoved);
            yield this.peerManager.removePeer(peerToBeRemoved.publicKey);
            if (this.client) {
                yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);
            }
        });
    }
    removeAllPeers() {
        return __awaiter(this, void 0, void 0, function* () {
            logger.log('removeAllPeers');
            yield this.peerManager.removeAllPeers();
            yield this.client.unsubscribeFromEncryptedMessages();
        });
    }
    send(message, recipient) {
        return __awaiter(this, void 0, void 0, function* () {
            const knownPeers = yield this.storage.get(StorageKey.TRANSPORT_P2P_PEERS);
            if (recipient) {
                if (!knownPeers.some((peer) => peer.publicKey === recipient)) {
                    throw new Error('Recipient unknown');
                }
                return this.client.sendMessage(recipient, message);
            }
            else {
                // A broadcast request has to be sent everywhere.
                const promises = knownPeers.map((peer) => this.client.sendMessage(peer.publicKey, message));
                return (yield Promise.all(promises))[0];
            }
        });
    }
    listen(publicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.client
                .listenForEncryptedMessage(publicKey, (message) => {
                const connectionContext = {
                    origin: Origin.P2P,
                    id: publicKey
                };
                this.notifyListeners(message, connectionContext).catch((error) => {
                    throw error;
                });
            })
                .catch((error) => {
                throw error;
            });
        });
    }
}
//# sourceMappingURL=P2PTransport.js.map