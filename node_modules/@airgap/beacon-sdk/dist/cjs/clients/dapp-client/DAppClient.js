"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DAppClient = void 0;
var exposed_promise_1 = require("../../utils/exposed-promise");
var Logger_1 = require("../../utils/Logger");
var generate_uuid_1 = require("../../utils/generate-uuid");
var events_1 = require("../../events");
var constants_1 = require("../../constants");
var crypto_1 = require("../../utils/crypto");
var __1 = require("../..");
var beacon_message_events_1 = require("../../beacon-message-events");
var check_permissions_1 = require("../../utils/check-permissions");
var get_account_identifier_1 = require("../../utils/get-account-identifier");
var logger = new Logger_1.Logger('DAppClient');
var DAppClient = /** @class */ (function (_super) {
    __extends(DAppClient, _super);
    function DAppClient(config) {
        var _this = _super.call(this, __assign({ storage: config.storage ? config.storage : new __1.LocalStorage() }, config)) || this;
        _this.openRequests = new Map();
        _this._activeAccount = new exposed_promise_1.ExposedPromise();
        _this.iconUrl = config.iconUrl;
        _this.storage
            .get(__1.StorageKey.ACTIVE_ACCOUNT)
            .then(function (activeAccountIdentifier) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!activeAccountIdentifier) return [3 /*break*/, 3];
                        _a = this.setActiveAccount;
                        return [4 /*yield*/, this.accountManager.getAccount(activeAccountIdentifier)];
                    case 1: return [4 /*yield*/, _a.apply(this, [_b.sent()])];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 5];
                    case 3: return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 4:
                        _b.sent();
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        }); })
            .catch(function (storageError) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 1:
                        _a.sent();
                        console.error(storageError);
                        return [2 /*return*/];
                }
            });
        }); });
        _this.handleResponse = function (event, connectionInfo) {
            var openRequest = _this.openRequests.get(event.id);
            if (openRequest) {
                logger.log('handleResponse', 'found openRequest', event.id);
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                var errorMessage = event;
                if (errorMessage.errorType) {
                    openRequest.reject(errorMessage);
                }
                else {
                    openRequest.resolve({ message: event, connectionInfo: connectionInfo });
                }
                _this.openRequests.delete(event.id);
            }
            else {
                logger.error('handleResponse', 'no request found for id ', event.id);
            }
        };
        return _this;
    }
    Object.defineProperty(DAppClient.prototype, "isConnected", {
        get: function () {
            return this._isConnected.promise;
        },
        enumerable: false,
        configurable: true
    });
    DAppClient.prototype.addOpenRequest = function (id, promise) {
        logger.log('addOpenRequest', this.name, "adding request " + id + " and waiting for answer");
        this.openRequests.set(id, promise);
    };
    DAppClient.prototype.init = function (_isDapp, transport) {
        return __awaiter(this, void 0, void 0, function () {
            var initResponse;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, _super.prototype.init.call(this, true, transport)];
                    case 1:
                        initResponse = _a.sent();
                        return [2 /*return*/, initResponse];
                }
            });
        });
    };
    DAppClient.prototype.getActiveAccount = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this._activeAccount.promise];
            });
        });
    };
    DAppClient.prototype.setActiveAccount = function (account) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this._activeAccount.isSettled()) {
                            // If the promise has already been resolved we need to create a new one.
                            this._activeAccount = exposed_promise_1.ExposedPromise.resolve(account);
                        }
                        else {
                            this._activeAccount.resolve(account);
                        }
                        return [4 /*yield*/, this.storage.set(__1.StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.ACTIVE_ACCOUNT_SET, account)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.getAppMetadata = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = {};
                        return [4 /*yield*/, this.beaconId];
                    case 1: return [2 /*return*/, (_a.beaconId = _b.sent(),
                            _a.name = this.name,
                            _a.icon = this.iconUrl,
                            _a)];
                }
            });
        });
    };
    DAppClient.prototype.connect = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype._connect.call(this)];
            });
        });
    };
    DAppClient.prototype.removeAccount = function (accountIdentifier) {
        return __awaiter(this, void 0, void 0, function () {
            var removeAccountResult, activeAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        removeAccountResult = _super.prototype.removeAccount.call(this, accountIdentifier);
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _a.sent();
                        if (!(activeAccount && activeAccount.accountIdentifier === accountIdentifier)) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [2 /*return*/, removeAccountResult];
                }
            });
        });
    };
    DAppClient.prototype.removeAllAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, _super.prototype.removeAllAccounts.call(this)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 2:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.removePeer = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            var removePeerResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        if (!((_a.sent()).type === __1.TransportType.P2P)) return [3 /*break*/, 4];
                        return [4 /*yield*/, this.transport];
                    case 2:
                        removePeerResult = (_a.sent()).removePeer(id);
                        return [4 /*yield*/, this.removeAccountsForPeers([id])];
                    case 3:
                        _a.sent();
                        return [2 /*return*/, removePeerResult];
                    case 4: return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.removeAllPeers = function () {
        return __awaiter(this, void 0, void 0, function () {
            var peers, removePeerResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.transport];
                    case 1:
                        if (!((_a.sent()).type === __1.TransportType.P2P)) return [3 /*break*/, 6];
                        return [4 /*yield*/, this.transport];
                    case 2: return [4 /*yield*/, (_a.sent()).getPeers()];
                    case 3:
                        peers = _a.sent();
                        return [4 /*yield*/, this.transport];
                    case 4:
                        removePeerResult = (_a.sent()).removeAllPeers();
                        return [4 /*yield*/, this.removeAccountsForPeers(peers)];
                    case 5:
                        _a.sent();
                        return [2 /*return*/, removePeerResult];
                    case 6: return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.subscribeToEvent = function (internalEvent, eventCallback) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.on(internalEvent, eventCallback)];
                    case 1:
                        _a.sent();
                        return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.checkPermissions = function (type) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, permissions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (type === __1.BeaconMessageType.PermissionRequest) {
                            return [2 /*return*/, true];
                        }
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _a.sent();
                        if (!activeAccount) {
                            throw this.sendInternalError('No active account set!');
                        }
                        permissions = activeAccount.scopes;
                        return [2 /*return*/, check_permissions_1.checkPermissions(type, permissions)];
                }
            });
        });
    };
    /**
     * Permission request
     */
    DAppClient.prototype.requestPermissions = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var request, _a, _b, message, connectionInfo, publicKey, address, accountInfo, _c, beaconId, network, scopes, output;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = {};
                        return [4 /*yield*/, this.getAppMetadata()];
                    case 1:
                        request = (_a.appMetadata = _d.sent(),
                            _a.type = __1.BeaconMessageType.PermissionRequest,
                            _a.network = input && input.network ? input.network : { type: __1.NetworkType.MAINNET },
                            _a.scopes = input && input.scopes
                                ? input.scopes
                                : [__1.PermissionScope.OPERATION_REQUEST, __1.PermissionScope.SIGN],
                            _a);
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    throw this.handleRequestError(request, requestError);
                                });
                            }); })
                            // TODO: Migration code. Remove before 1.0.0 release.
                        ];
                    case 2:
                        _b = _d.sent(), message = _b.message, connectionInfo = _b.connectionInfo;
                        publicKey = message.publicKey || message.pubkey || message.pubKey;
                        return [4 /*yield*/, crypto_1.getAddressFromPublicKey(publicKey)];
                    case 3:
                        address = _d.sent();
                        _c = {};
                        return [4 /*yield*/, get_account_identifier_1.getAccountIdentifier(address, message.network)];
                    case 4:
                        accountInfo = (_c.accountIdentifier = _d.sent(),
                            _c.beaconId = message.beaconId,
                            _c.origin = {
                                type: connectionInfo.origin,
                                id: connectionInfo.id
                            },
                            _c.address = address,
                            _c.publicKey = publicKey,
                            _c.network = message.network,
                            _c.scopes = message.scopes,
                            _c.connectedAt = new Date().getTime(),
                            _c);
                        return [4 /*yield*/, this.accountManager.addAccount(accountInfo)];
                    case 5:
                        _d.sent();
                        return [4 /*yield*/, this.setActiveAccount(accountInfo)];
                    case 6:
                        _d.sent();
                        beaconId = message.beaconId, network = message.network, scopes = message.scopes;
                        output = { beaconId: beaconId, publicKey: publicKey, address: address, network: network, scopes: scopes };
                        return [4 /*yield*/, this.notifySuccess(request, {
                                account: accountInfo,
                                output: output,
                                connectionContext: connectionInfo
                            })];
                    case 7:
                        _d.sent();
                        return [2 /*return*/, output];
                }
            });
        });
    };
    /**
     * Sign request
     */
    DAppClient.prototype.requestSignPayload = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, request, _a, message, connectionInfo, beaconId, signature, output;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!input.payload) {
                            throw this.sendInternalError('Payload must be provided');
                        }
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _b.sent();
                        if (!activeAccount) {
                            throw this.sendInternalError('No active account!');
                        }
                        request = {
                            type: __1.BeaconMessageType.SignPayloadRequest,
                            payload: input.payload,
                            sourceAddress: input.sourceAddress || activeAccount.address
                        };
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    throw this.handleRequestError(request, requestError);
                                });
                            }); })];
                    case 2:
                        _a = _b.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        beaconId = message.beaconId, signature = message.signature;
                        output = { beaconId: beaconId, signature: signature };
                        return [4 /*yield*/, this.notifySuccess(request, {
                                account: activeAccount,
                                output: output,
                                connectionContext: connectionInfo
                            })];
                    case 3:
                        _b.sent();
                        return [2 /*return*/, output];
                }
            });
        });
    };
    /**
     * Operation request
     */
    DAppClient.prototype.requestOperation = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var activeAccount, request, _a, message, connectionInfo, beaconId, transactionHash, output;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!input.operationDetails) {
                            throw this.sendInternalError('Operation details must be provided');
                        }
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 1:
                        activeAccount = _b.sent();
                        if (!activeAccount) {
                            throw this.sendInternalError('No active account!');
                        }
                        request = {
                            type: __1.BeaconMessageType.OperationRequest,
                            network: input.network || activeAccount.network || { type: __1.NetworkType.MAINNET },
                            operationDetails: input.operationDetails,
                            sourceAddress: activeAccount.address || ''
                        };
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    throw this.handleRequestError(request, requestError);
                                });
                            }); })];
                    case 2:
                        _a = _b.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        beaconId = message.beaconId, transactionHash = message.transactionHash;
                        output = { beaconId: beaconId, transactionHash: transactionHash };
                        return [4 /*yield*/, this.notifySuccess(request, {
                                account: activeAccount,
                                output: output,
                                connectionContext: connectionInfo
                            })];
                    case 3:
                        _b.sent();
                        return [2 /*return*/, { beaconId: beaconId, transactionHash: transactionHash }];
                }
            });
        });
    };
    /**
     * Broadcast request
     */
    DAppClient.prototype.requestBroadcast = function (input) {
        return __awaiter(this, void 0, void 0, function () {
            var network, request, _a, message, connectionInfo, beaconId, transactionHash, output;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!input.signedTransaction) {
                            throw this.sendInternalError('Signed transaction must be provided');
                        }
                        network = input.network || { type: __1.NetworkType.MAINNET };
                        request = {
                            type: __1.BeaconMessageType.BroadcastRequest,
                            network: network,
                            signedTransaction: input.signedTransaction
                        };
                        return [4 /*yield*/, this.makeRequest(request).catch(function (requestError) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    throw this.handleRequestError(request, requestError);
                                });
                            }); })];
                    case 1:
                        _a = _b.sent(), message = _a.message, connectionInfo = _a.connectionInfo;
                        beaconId = message.beaconId, transactionHash = message.transactionHash;
                        output = { beaconId: beaconId, transactionHash: transactionHash };
                        return [4 /*yield*/, this.notifySuccess(request, { network: network, output: output, connectionContext: connectionInfo })];
                    case 2:
                        _b.sent();
                        return [2 /*return*/, { beaconId: beaconId, transactionHash: transactionHash }];
                }
            });
        });
    };
    DAppClient.prototype.sendInternalError = function (errorMessage) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.events.emit(events_1.BeaconEvent.INTERNAL_ERROR, errorMessage)];
                    case 1:
                        _a.sent();
                        throw new Error(errorMessage);
                }
            });
        });
    };
    DAppClient.prototype.removeAccountsForPeers = function (peersToRemove) {
        return __awaiter(this, void 0, void 0, function () {
            var accounts, peerIdsToRemove, accountsToRemove, accountIdentifiersToRemove, activeAccount;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.accountManager.getAccounts()];
                    case 1:
                        accounts = _a.sent();
                        peerIdsToRemove = peersToRemove.map(function (peer) { return peer.publicKey; });
                        accountsToRemove = accounts.filter(function (account) {
                            return peerIdsToRemove.includes(account.origin.id);
                        });
                        accountIdentifiersToRemove = accountsToRemove.map(function (accountInfo) { return accountInfo.accountIdentifier; });
                        return [4 /*yield*/, this.accountManager.removeAccounts(accountIdentifiersToRemove)
                            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined
                        ];
                    case 2:
                        _a.sent();
                        return [4 /*yield*/, this.getActiveAccount()];
                    case 3:
                        activeAccount = _a.sent();
                        if (!activeAccount) return [3 /*break*/, 5];
                        if (!accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) return [3 /*break*/, 5];
                        return [4 /*yield*/, this.setActiveAccount(undefined)];
                    case 4:
                        _a.sent();
                        _a.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    DAppClient.prototype.handleRequestError = function (request, beaconError) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (beaconError.errorType) {
                    this.events
                        .emit(beacon_message_events_1.messageEvents[request.type].error, beaconError)
                        .catch(function (emitError) { return console.warn(emitError); });
                    throw __1.BeaconError.getError(beaconError.errorType);
                }
                console.error('requestError', beaconError);
                throw beaconError;
            });
        });
    };
    DAppClient.prototype.notifySuccess = function (request, response) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.events
                    .emit(beacon_message_events_1.messageEvents[request.type].success, response)
                    .catch(function (emitError) { return console.warn(emitError); });
                return [2 /*return*/];
            });
        });
    };
    DAppClient.prototype.makeRequest = function (requestInput, account) {
        return __awaiter(this, void 0, void 0, function () {
            var request, _a, exposed, payload, origin;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        logger.log('makeRequest');
                        return [4 /*yield*/, this.init()];
                    case 1:
                        _b.sent();
                        logger.log('makeRequest', 'after init');
                        return [4 /*yield*/, this.connect()];
                    case 2:
                        _b.sent();
                        logger.log('makeRequest', 'after connecting');
                        return [4 /*yield*/, this.addRequestAndCheckIfRateLimited()];
                    case 3:
                        if (_b.sent()) {
                            this.events
                                .emit(events_1.BeaconEvent.LOCAL_RATE_LIMIT_REACHED)
                                .catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('rate limit reached');
                        }
                        return [4 /*yield*/, this.checkPermissions(requestInput.type)];
                    case 4:
                        if (!(_b.sent())) {
                            this.events.emit(events_1.BeaconEvent.NO_PERMISSIONS).catch(function (emitError) { return console.warn(emitError); });
                            throw new Error('No permissions to send this request to wallet!');
                        }
                        if (!this.beaconId) {
                            throw this.sendInternalError('BeaconID not defined');
                        }
                        _a = { id: generate_uuid_1.generateGUID(), version: constants_1.BEACON_VERSION };
                        return [4 /*yield*/, this.beaconId];
                    case 5:
                        request = __assign.apply(void 0, [(_a.beaconId = _b.sent(), _a), requestInput]);
                        exposed = new exposed_promise_1.ExposedPromise();
                        this.addOpenRequest(request.id, exposed);
                        return [4 /*yield*/, new __1.Serializer().serialize(request)];
                    case 6:
                        payload = _b.sent();
                        if (account) {
                            origin = account.origin.id;
                        }
                        return [4 /*yield*/, this.transport];
                    case 7: return [4 /*yield*/, (_b.sent()).send(payload, origin)];
                    case 8:
                        _b.sent();
                        this.events
                            .emit(beacon_message_events_1.messageEvents[requestInput.type].sent)
                            .catch(function (emitError) { return console.warn(emitError); });
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        return [2 /*return*/, exposed.promise]; // TODO: fix type
                }
            });
        });
    };
    return DAppClient;
}(__1.Client));
exports.DAppClient = DAppClient;
//# sourceMappingURL=DAppClient.js.map