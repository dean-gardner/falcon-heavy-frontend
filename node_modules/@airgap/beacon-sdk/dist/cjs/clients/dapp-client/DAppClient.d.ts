import { ExposedPromise } from '../../utils/exposed-promise';
import { BeaconEvent, BeaconEventHandlerFunction, BeaconEventType } from '../../events';
import { ConnectionContext } from '../../types/ConnectionContext';
import { AccountInfo, Client, TransportType, Transport, BeaconMessageType, BeaconErrorMessage, BeaconMessage, RequestPermissionInput, RequestSignPayloadInput, RequestOperationInput, RequestBroadcastInput, AppMetadata, PermissionResponseOutput, SignPayloadResponseOutput, OperationResponseOutput, BroadcastResponseOutput, P2PPairInfo } from '../..';
import { DAppClientOptions } from './DAppClientOptions';
export declare class DAppClient extends Client {
    private readonly openRequests;
    private readonly iconUrl?;
    private _activeAccount;
    get isConnected(): Promise<boolean>;
    constructor(config: DAppClientOptions);
    addOpenRequest(id: string, promise: ExposedPromise<{
        message: BeaconMessage;
        connectionInfo: ConnectionContext;
    }, BeaconErrorMessage>): void;
    init(_isDapp?: boolean, transport?: Transport): Promise<TransportType>;
    getActiveAccount(): Promise<AccountInfo | undefined>;
    setActiveAccount(account?: AccountInfo): Promise<void>;
    getAppMetadata(): Promise<AppMetadata>;
    connect(): Promise<boolean>;
    removeAccount(accountIdentifier: string): Promise<void>;
    removeAllAccounts(): Promise<void>;
    removePeer(id: P2PPairInfo): Promise<void>;
    removeAllPeers(): Promise<void>;
    subscribeToEvent<K extends BeaconEvent>(internalEvent: K, eventCallback: BeaconEventHandlerFunction<BeaconEventType[K]>): Promise<void>;
    checkPermissions(type: BeaconMessageType): Promise<boolean>;
    /**
     * Permission request
     */
    requestPermissions(input?: RequestPermissionInput): Promise<PermissionResponseOutput>;
    /**
     * Sign request
     */
    requestSignPayload(input: RequestSignPayloadInput): Promise<SignPayloadResponseOutput>;
    /**
     * Operation request
     */
    requestOperation(input: RequestOperationInput): Promise<OperationResponseOutput>;
    /**
     * Broadcast request
     */
    requestBroadcast(input: RequestBroadcastInput): Promise<BroadcastResponseOutput>;
    private sendInternalError;
    private removeAccountsForPeers;
    private handleRequestError;
    private notifySuccess;
    private makeRequest;
}
