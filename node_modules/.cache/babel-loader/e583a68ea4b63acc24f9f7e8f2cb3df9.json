{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst MAX_POLLING_RETRIES = 3;\nexport class MatrixClient {\n  constructor(store, eventEmitter, userService, roomService, eventService) {\n    this.store = store;\n    this.eventEmitter = eventEmitter;\n    this.userService = userService;\n    this.roomService = roomService;\n    this.eventService = eventService;\n    this.store.onStateChanged((oldState, newState, stateChange) => {\n      this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n    }, 'rooms');\n  }\n\n  static create(config) {\n    const store = MatrixClientStore.createLocal();\n    const eventEmitter = new MatrixClientEventEmitter();\n    const httpClient = new MatrixHttpClient(config.baseUrl);\n    const accountService = new MatrixUserService(httpClient);\n    const roomService = new MatrixRoomService(httpClient);\n    const eventService = new MatrixEventService(httpClient);\n    return new MatrixClient(store, eventEmitter, accountService, roomService, eventService);\n  }\n\n  get joinedRooms() {\n    return Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.JOINED);\n  }\n\n  get invitedRooms() {\n    return Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.INVITED);\n  }\n\n  get leftRooms() {\n    return Object.values(this.store.get('rooms')).filter(room => room.status === MatrixRoomStatus.LEFT);\n  }\n\n  start(user) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const response = yield this.userService.login(user.id, user.password, user.deviceId);\n      this.store.update({\n        accessToken: response.access_token\n      });\n      return new Promise((resolve, reject) => {\n        this.poll(0, pollingResponse => {\n          if (!this.store.get('isRunning')) {\n            resolve();\n          }\n\n          this.store.update({\n            isRunning: true,\n            syncToken: pollingResponse.next_batch,\n            pollingTimeout: 30000,\n            pollingRetries: 0,\n            rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n          });\n        }, error => {\n          if (!this.store.get('isRunning')) {\n            reject(error);\n          }\n\n          this.store.update({\n            isRunning: false,\n            pollingRetries: this.store.get('pollingRetries') + 1\n          });\n        });\n      });\n    });\n  }\n\n  subscribe(event, listener) {\n    this.eventEmitter.on(event, listener);\n  }\n\n  unsubscribe(event, listener) {\n    if (listener) {\n      this.eventEmitter.removeListener(event, listener);\n    } else {\n      this.eventEmitter.removeAllListeners(event);\n    }\n  }\n\n  getRoomById(id) {\n    return this.store.getRoom(id);\n  }\n\n  createTrustedPrivateRoom() {\n    for (var _len = arguments.length, members = new Array(_len), _key = 0; _key < _len; _key++) {\n      members[_key] = arguments[_key];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.requiresAuthorization('createRoom', accessToken => __awaiter(this, void 0, void 0, function* () {\n        const response = yield this.roomService.createRoom(accessToken, {\n          invite: members,\n          preset: 'trusted_private_chat',\n          is_direct: true\n        });\n        return response.room_id;\n      }));\n    });\n  }\n\n  inviteToRooms(user) {\n    for (var _len2 = arguments.length, roomsOrIds = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      roomsOrIds[_key2 - 1] = arguments[_key2];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requiresAuthorization('invite', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        this.roomService.inviteToRoom(accessToken, user, room).catch(error => console.warn(error));\n      })));\n    });\n  }\n\n  joinRooms() {\n    for (var _len3 = arguments.length, roomsOrIds = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      roomsOrIds[_key3] = arguments[_key3];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.requiresAuthorization('join', accessToken => Promise.all(roomsOrIds.map(roomOrId => {\n        const room = this.store.getRoom(roomOrId);\n        return this.roomService.joinRoom(accessToken, room).catch(error => console.warn(error));\n      })));\n    });\n  }\n\n  sendTextMessage(roomOrId, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.requiresAuthorization('send', accessToken => __awaiter(this, void 0, void 0, function* () {\n          const room = this.store.getRoom(roomOrId);\n          const txnId = this.createTxnId();\n          return this.eventService.sendMessage(accessToken, room, {\n            msgtype: 'm.text',\n            body: message\n          }, txnId);\n        }));\n      } catch (error) {\n        console.error(error);\n      }\n    });\n  }\n\n  poll(interval, onSyncSuccess, onSyncError) {\n    const store = this.store;\n    const sync = this.sync.bind(this);\n\n    const pollSync = () => __awaiter(this, void 0, void 0, function* () {\n      let continueSyncing = false;\n\n      try {\n        const response = yield sync();\n        onSyncSuccess(response);\n        continueSyncing = true;\n      } catch (error) {\n        onSyncError(error);\n        continueSyncing = store.get('pollingRetries') < MAX_POLLING_RETRIES;\n        console.warn('Could not sync:', error);\n\n        if (continueSyncing) {\n          console.log('Retry syncing...');\n        }\n      } finally {\n        if (continueSyncing) {\n          setTimeout(pollSync, interval);\n        } else {\n          throw new Error(`Max polling retries exeeded: ${MAX_POLLING_RETRIES}`);\n        }\n      }\n    });\n\n    pollSync();\n  }\n\n  sync() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.requiresAuthorization('sync', accessToken => __awaiter(this, void 0, void 0, function* () {\n        return this.eventService.sync(accessToken, {\n          pollingTimeout: this.store.get('pollingTimeout'),\n          syncToken: this.store.get('syncToken')\n        });\n      }));\n    });\n  }\n\n  requiresAuthorization(name, action) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.store.get('accessToken')) {\n        return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n      }\n\n      return action(this.store.get('accessToken'));\n    });\n  }\n\n  createTxnId() {\n    const timestamp = new Date().getTime();\n    const counter = this.store.get('txnNo');\n    this.store.update({\n      txnNo: counter + 1\n    });\n    return `m${timestamp}.${counter}`;\n  }\n\n}","map":{"version":3,"mappings":"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","names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","MatrixClientStore","MatrixHttpClient","MatrixRoom","MatrixRoomStatus","MatrixRoomService","MatrixUserService","MatrixEventService","MatrixClientEventEmitter","MAX_POLLING_RETRIES","MatrixClient","constructor","store","eventEmitter","userService","roomService","eventService","onStateChanged","oldState","newState","stateChange","create","config","createLocal","httpClient","baseUrl","accountService","joinedRooms","Object","values","get","filter","room","status","JOINED","invitedRooms","INVITED","leftRooms","LEFT","start","user","response","login","id","password","deviceId","update","accessToken","access_token","poll","pollingResponse","isRunning","syncToken","next_batch","pollingTimeout","pollingRetries","rooms","fromSync","error","subscribe","event","listener","on","unsubscribe","removeListener","removeAllListeners","getRoomById","getRoom","createTrustedPrivateRoom","members","requiresAuthorization","createRoom","invite","preset","is_direct","room_id","inviteToRooms","roomsOrIds","all","map","roomOrId","inviteToRoom","catch","console","warn","joinRooms","joinRoom","sendTextMessage","message","txnId","createTxnId","sendMessage","msgtype","body","interval","onSyncSuccess","onSyncError","sync","bind","pollSync","continueSyncing","log","setTimeout","Error","name","action","timestamp","Date","getTime","counter","txnNo"],"sourceRoot":"","sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@airgap/beacon-sdk/dist/esm/matrix-client/MatrixClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { MatrixClientStore } from './MatrixClientStore';\nimport { MatrixHttpClient } from './MatrixHttpClient';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nimport { MatrixRoomService } from './services/MatrixRoomService';\nimport { MatrixUserService } from './services/MatrixUserService';\nimport { MatrixEventService } from './services/MatrixEventService';\nimport { MatrixClientEventEmitter } from './MatrixClientEventEmitter';\nconst MAX_POLLING_RETRIES = 3;\nexport class MatrixClient {\n    constructor(store, eventEmitter, userService, roomService, eventService) {\n        this.store = store;\n        this.eventEmitter = eventEmitter;\n        this.userService = userService;\n        this.roomService = roomService;\n        this.eventService = eventService;\n        this.store.onStateChanged((oldState, newState, stateChange) => {\n            this.eventEmitter.onStateChanged(oldState, newState, stateChange);\n        }, 'rooms');\n    }\n    static create(config) {\n        const store = MatrixClientStore.createLocal();\n        const eventEmitter = new MatrixClientEventEmitter();\n        const httpClient = new MatrixHttpClient(config.baseUrl);\n        const accountService = new MatrixUserService(httpClient);\n        const roomService = new MatrixRoomService(httpClient);\n        const eventService = new MatrixEventService(httpClient);\n        return new MatrixClient(store, eventEmitter, accountService, roomService, eventService);\n    }\n    get joinedRooms() {\n        return Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.JOINED);\n    }\n    get invitedRooms() {\n        return Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.INVITED);\n    }\n    get leftRooms() {\n        return Object.values(this.store.get('rooms')).filter((room) => room.status === MatrixRoomStatus.LEFT);\n    }\n    start(user) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const response = yield this.userService.login(user.id, user.password, user.deviceId);\n            this.store.update({\n                accessToken: response.access_token\n            });\n            return new Promise((resolve, reject) => {\n                this.poll(0, (pollingResponse) => {\n                    if (!this.store.get('isRunning')) {\n                        resolve();\n                    }\n                    this.store.update({\n                        isRunning: true,\n                        syncToken: pollingResponse.next_batch,\n                        pollingTimeout: 30000,\n                        pollingRetries: 0,\n                        rooms: MatrixRoom.fromSync(pollingResponse.rooms)\n                    });\n                }, (error) => {\n                    if (!this.store.get('isRunning')) {\n                        reject(error);\n                    }\n                    this.store.update({\n                        isRunning: false,\n                        pollingRetries: this.store.get('pollingRetries') + 1\n                    });\n                });\n            });\n        });\n    }\n    subscribe(event, listener) {\n        this.eventEmitter.on(event, listener);\n    }\n    unsubscribe(event, listener) {\n        if (listener) {\n            this.eventEmitter.removeListener(event, listener);\n        }\n        else {\n            this.eventEmitter.removeAllListeners(event);\n        }\n    }\n    getRoomById(id) {\n        return this.store.getRoom(id);\n    }\n    createTrustedPrivateRoom(...members) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.requiresAuthorization('createRoom', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                const response = yield this.roomService.createRoom(accessToken, {\n                    invite: members,\n                    preset: 'trusted_private_chat',\n                    is_direct: true\n                });\n                return response.room_id;\n            }));\n        });\n    }\n    inviteToRooms(user, ...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.requiresAuthorization('invite', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                this.roomService\n                    .inviteToRoom(accessToken, user, room)\n                    .catch((error) => console.warn(error));\n            })));\n        });\n    }\n    joinRooms(...roomsOrIds) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.requiresAuthorization('join', (accessToken) => Promise.all(roomsOrIds.map((roomOrId) => {\n                const room = this.store.getRoom(roomOrId);\n                return this.roomService.joinRoom(accessToken, room).catch((error) => console.warn(error));\n            })));\n        });\n    }\n    sendTextMessage(roomOrId, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.requiresAuthorization('send', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                    const room = this.store.getRoom(roomOrId);\n                    const txnId = this.createTxnId();\n                    return this.eventService.sendMessage(accessToken, room, {\n                        msgtype: 'm.text',\n                        body: message\n                    }, txnId);\n                }));\n            }\n            catch (error) {\n                console.error(error);\n            }\n        });\n    }\n    poll(interval, onSyncSuccess, onSyncError) {\n        const store = this.store;\n        const sync = this.sync.bind(this);\n        const pollSync = () => __awaiter(this, void 0, void 0, function* () {\n            let continueSyncing = false;\n            try {\n                const response = yield sync();\n                onSyncSuccess(response);\n                continueSyncing = true;\n            }\n            catch (error) {\n                onSyncError(error);\n                continueSyncing = store.get('pollingRetries') < MAX_POLLING_RETRIES;\n                console.warn('Could not sync:', error);\n                if (continueSyncing) {\n                    console.log('Retry syncing...');\n                }\n            }\n            finally {\n                if (continueSyncing) {\n                    setTimeout(pollSync, interval);\n                }\n                else {\n                    throw new Error(`Max polling retries exeeded: ${MAX_POLLING_RETRIES}`);\n                }\n            }\n        });\n        pollSync();\n    }\n    sync() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.requiresAuthorization('sync', (accessToken) => __awaiter(this, void 0, void 0, function* () {\n                return this.eventService.sync(accessToken, {\n                    pollingTimeout: this.store.get('pollingTimeout'),\n                    syncToken: this.store.get('syncToken')\n                });\n            }));\n        });\n    }\n    requiresAuthorization(name, action) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.store.get('accessToken')) {\n                return Promise.reject(`${name} requires authorization but no access token has been provided.`);\n            }\n            return action(this.store.get('accessToken'));\n        });\n    }\n    createTxnId() {\n        const timestamp = new Date().getTime();\n        const counter = this.store.get('txnNo');\n        this.store.update({\n            txnNo: counter + 1\n        });\n        return `m${timestamp}.${counter}`;\n    }\n}\n//# sourceMappingURL=MatrixClient.js.map"]},"metadata":{},"sourceType":"module"}