{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\n\nvar ReplaySubject = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(ReplaySubject, _super);\n\n  function ReplaySubject(bufferSize, windowTime, scheduler) {\n    if (bufferSize === void 0) {\n      bufferSize = Number.POSITIVE_INFINITY;\n    }\n\n    if (windowTime === void 0) {\n      windowTime = Number.POSITIVE_INFINITY;\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.scheduler = scheduler;\n    _this._events = [];\n    _this._infiniteTimeWindow = false;\n    _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n    _this._windowTime = windowTime < 1 ? 1 : windowTime;\n\n    if (windowTime === Number.POSITIVE_INFINITY) {\n      _this._infiniteTimeWindow = true;\n      _this.next = _this.nextInfiniteTimeWindow;\n    } else {\n      _this.next = _this.nextTimeWindow;\n    }\n\n    return _this;\n  }\n\n  ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n    if (!this.isStopped) {\n      var _events = this._events;\n\n      _events.push(value);\n\n      if (_events.length > this._bufferSize) {\n        _events.shift();\n      }\n    }\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype.nextTimeWindow = function (value) {\n    if (!this.isStopped) {\n      this._events.push(new ReplayEvent(this._getNow(), value));\n\n      this._trimBufferThenGetEvents();\n    }\n\n    _super.prototype.next.call(this, value);\n  };\n\n  ReplaySubject.prototype._subscribe = function (subscriber) {\n    var _infiniteTimeWindow = this._infiniteTimeWindow;\n\n    var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n\n    var scheduler = this.scheduler;\n    var len = _events.length;\n    var subscription;\n\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    } else if (this.isStopped || this.hasError) {\n      subscription = Subscription.EMPTY;\n    } else {\n      this.observers.push(subscriber);\n      subscription = new SubjectSubscription(this, subscriber);\n    }\n\n    if (scheduler) {\n      subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n    }\n\n    if (_infiniteTimeWindow) {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i]);\n      }\n    } else {\n      for (var i = 0; i < len && !subscriber.closed; i++) {\n        subscriber.next(_events[i].value);\n      }\n    }\n\n    if (this.hasError) {\n      subscriber.error(this.thrownError);\n    } else if (this.isStopped) {\n      subscriber.complete();\n    }\n\n    return subscription;\n  };\n\n  ReplaySubject.prototype._getNow = function () {\n    return (this.scheduler || queue).now();\n  };\n\n  ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n    var now = this._getNow();\n\n    var _bufferSize = this._bufferSize;\n    var _windowTime = this._windowTime;\n    var _events = this._events;\n    var eventsCount = _events.length;\n    var spliceCount = 0;\n\n    while (spliceCount < eventsCount) {\n      if (now - _events[spliceCount].time < _windowTime) {\n        break;\n      }\n\n      spliceCount++;\n    }\n\n    if (eventsCount > _bufferSize) {\n      spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n    }\n\n    if (spliceCount > 0) {\n      _events.splice(0, spliceCount);\n    }\n\n    return _events;\n  };\n\n  return ReplaySubject;\n}(Subject);\n\nexport { ReplaySubject };\n\nvar ReplayEvent = /*@__PURE__*/function () {\n  function ReplayEvent(time, value) {\n    this.time = time;\n    this.value = value;\n  }\n\n  return ReplayEvent;\n}();","map":{"version":3,"mappings":"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","names":["tslib_1","Subject","queue","Subscription","ObserveOnSubscriber","ObjectUnsubscribedError","SubjectSubscription","ReplaySubject","_super","__extends","bufferSize","windowTime","scheduler","Number","POSITIVE_INFINITY","_this","call","_events","_infiniteTimeWindow","_bufferSize","_windowTime","next","nextInfiniteTimeWindow","nextTimeWindow","prototype","value","isStopped","push","length","shift","ReplayEvent","_getNow","_trimBufferThenGetEvents","_subscribe","subscriber","len","subscription","closed","hasError","EMPTY","observers","add","i","error","thrownError","complete","now","eventsCount","spliceCount","time","Math","max","splice"],"sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/rxjs/_esm5/internal/ReplaySubject.js"],"sourcesContent":["/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { queue } from './scheduler/queue';\nimport { Subscription } from './Subscription';\nimport { ObserveOnSubscriber } from './operators/observeOn';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nvar ReplaySubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(ReplaySubject, _super);\n    function ReplaySubject(bufferSize, windowTime, scheduler) {\n        if (bufferSize === void 0) {\n            bufferSize = Number.POSITIVE_INFINITY;\n        }\n        if (windowTime === void 0) {\n            windowTime = Number.POSITIVE_INFINITY;\n        }\n        var _this = _super.call(this) || this;\n        _this.scheduler = scheduler;\n        _this._events = [];\n        _this._infiniteTimeWindow = false;\n        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;\n        _this._windowTime = windowTime < 1 ? 1 : windowTime;\n        if (windowTime === Number.POSITIVE_INFINITY) {\n            _this._infiniteTimeWindow = true;\n            _this.next = _this.nextInfiniteTimeWindow;\n        }\n        else {\n            _this.next = _this.nextTimeWindow;\n        }\n        return _this;\n    }\n    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {\n        if (!this.isStopped) {\n            var _events = this._events;\n            _events.push(value);\n            if (_events.length > this._bufferSize) {\n                _events.shift();\n            }\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype.nextTimeWindow = function (value) {\n        if (!this.isStopped) {\n            this._events.push(new ReplayEvent(this._getNow(), value));\n            this._trimBufferThenGetEvents();\n        }\n        _super.prototype.next.call(this, value);\n    };\n    ReplaySubject.prototype._subscribe = function (subscriber) {\n        var _infiniteTimeWindow = this._infiniteTimeWindow;\n        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();\n        var scheduler = this.scheduler;\n        var len = _events.length;\n        var subscription;\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.isStopped || this.hasError) {\n            subscription = Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            subscription = new SubjectSubscription(this, subscriber);\n        }\n        if (scheduler) {\n            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));\n        }\n        if (_infiniteTimeWindow) {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i]);\n            }\n        }\n        else {\n            for (var i = 0; i < len && !subscriber.closed; i++) {\n                subscriber.next(_events[i].value);\n            }\n        }\n        if (this.hasError) {\n            subscriber.error(this.thrownError);\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n        }\n        return subscription;\n    };\n    ReplaySubject.prototype._getNow = function () {\n        return (this.scheduler || queue).now();\n    };\n    ReplaySubject.prototype._trimBufferThenGetEvents = function () {\n        var now = this._getNow();\n        var _bufferSize = this._bufferSize;\n        var _windowTime = this._windowTime;\n        var _events = this._events;\n        var eventsCount = _events.length;\n        var spliceCount = 0;\n        while (spliceCount < eventsCount) {\n            if ((now - _events[spliceCount].time) < _windowTime) {\n                break;\n            }\n            spliceCount++;\n        }\n        if (eventsCount > _bufferSize) {\n            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);\n        }\n        if (spliceCount > 0) {\n            _events.splice(0, spliceCount);\n        }\n        return _events;\n    };\n    return ReplaySubject;\n}(Subject));\nexport { ReplaySubject };\nvar ReplayEvent = /*@__PURE__*/ (function () {\n    function ReplayEvent(time, value) {\n        this.time = time;\n        this.value = value;\n    }\n    return ReplayEvent;\n}());\n//# sourceMappingURL=ReplaySubject.js.map\n"]},"metadata":{},"sourceType":"module"}