{"ast":null,"code":"import { keys } from '../utils/utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nconst STORAGE_KEY = 'beacon:sdk-matrix-preserved-state';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\nexport class MatrixClientStore {\n  constructor(storage) {\n    this.storage = storage;\n    this.state = {\n      isRunning: false,\n      userId: undefined,\n      deviceId: undefined,\n      txnNo: 0,\n      accessToken: undefined,\n      syncToken: undefined,\n      pollingTimeout: undefined,\n      pollingRetries: 0,\n      rooms: {}\n    };\n    this.onStateChangedListeners = new Map();\n    this.initFromStorage();\n  }\n\n  static createLocal() {\n    const localStorage = global.localStorage;\n    return new MatrixClientStore(localStorage);\n  }\n\n  get(key) {\n    return this.state[key];\n  }\n\n  getRoom(roomOrId) {\n    const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n    return this.state.rooms[room.id] || room;\n  }\n\n  update(stateUpdate) {\n    const oldState = Object.assign({}, this.state);\n    this.setState(stateUpdate);\n    this.updateStorage(stateUpdate);\n    this.notifyListeners(oldState, this.state, stateUpdate);\n  }\n\n  onStateChanged(listener) {\n    for (var _len = arguments.length, subscribed = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      subscribed[_key - 1] = arguments[_key];\n    }\n\n    if (subscribed.length > 0) {\n      subscribed.forEach(key => {\n        this.onStateChangedListeners.set(key, listener);\n      });\n    } else {\n      this.onStateChangedListeners.set('all', listener);\n    }\n  }\n\n  initFromStorage() {\n    if (this.storage) {\n      const preserved = this.storage.getItem(STORAGE_KEY);\n      this.setState(preserved ? JSON.parse(preserved) : {});\n    }\n  }\n\n  prepareData(toStore) {\n    const requiresPreparation = ['rooms'];\n    const toStoreCopy = requiresPreparation.some(key => toStore[key] !== undefined) ? JSON.parse(JSON.stringify(toStore)) : toStore; // there is no need for saving messages in a persistent storage\n\n    Object.values(toStoreCopy.rooms || {}).forEach(room => {\n      room.messages = [];\n    });\n    return toStoreCopy;\n  }\n\n  updateStorage(stateUpdate) {\n    const updatedCachedFields = Object.entries(stateUpdate).filter(_ref => {\n      let [key, value] = _ref;\n      return PRESERVED_FIELDS.includes(key) && Boolean(value);\n    });\n\n    if (this.storage && updatedCachedFields.length > 0) {\n      const filteredState = {};\n      PRESERVED_FIELDS.forEach(key => {\n        filteredState[key] = this.state[key];\n      });\n      this.storage.setItem(STORAGE_KEY, JSON.stringify(this.prepareData(filteredState)));\n    }\n  }\n\n  setState(partialState) {\n    this.state = {\n      isRunning: partialState.isRunning || this.state.isRunning,\n      userId: partialState.userId || this.state.userId,\n      deviceId: partialState.deviceId || this.state.deviceId,\n      txnNo: partialState.txnNo || this.state.txnNo,\n      accessToken: partialState.accessToken || this.state.accessToken,\n      syncToken: partialState.syncToken || this.state.syncToken,\n      pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n      pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n      rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n    };\n  }\n\n  mergeRooms(oldRooms, _newRooms) {\n    if (!_newRooms) {\n      return oldRooms;\n    }\n\n    const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n    const merged = Object.assign({}, oldRooms);\n    newRooms.forEach(newRoom => {\n      merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n    });\n    return merged;\n  }\n\n  notifyListeners(oldState, newState, stateChange) {\n    const listenForAll = this.onStateChangedListeners.get('all');\n\n    if (listenForAll) {\n      listenForAll(oldState, newState, stateChange);\n    }\n\n    keys(stateChange).filter(key => stateChange[key] !== undefined).forEach(key => {\n      const listener = this.onStateChangedListeners.get(key);\n\n      if (listener) {\n        listener(oldState, newState, stateChange);\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["keys","MatrixRoom","MatrixRoomStatus","STORAGE_KEY","PRESERVED_FIELDS","MatrixClientStore","constructor","storage","state","isRunning","userId","undefined","deviceId","txnNo","accessToken","syncToken","pollingTimeout","pollingRetries","rooms","onStateChangedListeners","Map","initFromStorage","createLocal","localStorage","global","get","key","getRoom","roomOrId","room","from","UNKNOWN","id","update","stateUpdate","oldState","Object","assign","setState","updateStorage","notifyListeners","onStateChanged","listener","subscribed","length","forEach","set","preserved","getItem","JSON","parse","prepareData","toStore","requiresPreparation","toStoreCopy","some","stringify","values","messages","updatedCachedFields","entries","filter","value","includes","Boolean","filteredState","setItem","partialState","mergeRooms","oldRooms","_newRooms","newRooms","Array","isArray","merged","newRoom","merge","newState","stateChange","listenForAll"],"sourceRoot":"","sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@airgap/beacon-sdk/dist/esm/matrix-client/MatrixClientStore.js"],"sourcesContent":["import { keys } from '../utils/utils';\nimport { MatrixRoom, MatrixRoomStatus } from './models/MatrixRoom';\nconst STORAGE_KEY = 'beacon:sdk-matrix-preserved-state';\nconst PRESERVED_FIELDS = ['syncToken', 'rooms'];\nexport class MatrixClientStore {\n    constructor(storage) {\n        this.storage = storage;\n        this.state = {\n            isRunning: false,\n            userId: undefined,\n            deviceId: undefined,\n            txnNo: 0,\n            accessToken: undefined,\n            syncToken: undefined,\n            pollingTimeout: undefined,\n            pollingRetries: 0,\n            rooms: {}\n        };\n        this.onStateChangedListeners = new Map();\n        this.initFromStorage();\n    }\n    static createLocal() {\n        const localStorage = global.localStorage;\n        return new MatrixClientStore(localStorage);\n    }\n    get(key) {\n        return this.state[key];\n    }\n    getRoom(roomOrId) {\n        const room = MatrixRoom.from(roomOrId, MatrixRoomStatus.UNKNOWN);\n        return this.state.rooms[room.id] || room;\n    }\n    update(stateUpdate) {\n        const oldState = Object.assign({}, this.state);\n        this.setState(stateUpdate);\n        this.updateStorage(stateUpdate);\n        this.notifyListeners(oldState, this.state, stateUpdate);\n    }\n    onStateChanged(listener, ...subscribed) {\n        if (subscribed.length > 0) {\n            subscribed.forEach((key) => {\n                this.onStateChangedListeners.set(key, listener);\n            });\n        }\n        else {\n            this.onStateChangedListeners.set('all', listener);\n        }\n    }\n    initFromStorage() {\n        if (this.storage) {\n            const preserved = this.storage.getItem(STORAGE_KEY);\n            this.setState(preserved ? JSON.parse(preserved) : {});\n        }\n    }\n    prepareData(toStore) {\n        const requiresPreparation = ['rooms'];\n        const toStoreCopy = requiresPreparation.some((key) => toStore[key] !== undefined)\n            ? JSON.parse(JSON.stringify(toStore))\n            : toStore;\n        // there is no need for saving messages in a persistent storage\n        Object.values(toStoreCopy.rooms || {}).forEach((room) => {\n            room.messages = [];\n        });\n        return toStoreCopy;\n    }\n    updateStorage(stateUpdate) {\n        const updatedCachedFields = Object.entries(stateUpdate).filter(([key, value]) => PRESERVED_FIELDS.includes(key) && Boolean(value));\n        if (this.storage && updatedCachedFields.length > 0) {\n            const filteredState = {};\n            PRESERVED_FIELDS.forEach((key) => {\n                filteredState[key] = this.state[key];\n            });\n            this.storage.setItem(STORAGE_KEY, JSON.stringify(this.prepareData(filteredState)));\n        }\n    }\n    setState(partialState) {\n        this.state = {\n            isRunning: partialState.isRunning || this.state.isRunning,\n            userId: partialState.userId || this.state.userId,\n            deviceId: partialState.deviceId || this.state.deviceId,\n            txnNo: partialState.txnNo || this.state.txnNo,\n            accessToken: partialState.accessToken || this.state.accessToken,\n            syncToken: partialState.syncToken || this.state.syncToken,\n            pollingTimeout: partialState.pollingTimeout || this.state.pollingTimeout,\n            pollingRetries: partialState.pollingRetries || this.state.pollingRetries,\n            rooms: this.mergeRooms(this.state.rooms, partialState.rooms)\n        };\n    }\n    mergeRooms(oldRooms, _newRooms) {\n        if (!_newRooms) {\n            return oldRooms;\n        }\n        const newRooms = Array.isArray(_newRooms) ? _newRooms : Object.values(_newRooms);\n        const merged = Object.assign({}, oldRooms);\n        newRooms.forEach((newRoom) => {\n            merged[newRoom.id] = MatrixRoom.merge(newRoom, oldRooms[newRoom.id]);\n        });\n        return merged;\n    }\n    notifyListeners(oldState, newState, stateChange) {\n        const listenForAll = this.onStateChangedListeners.get('all');\n        if (listenForAll) {\n            listenForAll(oldState, newState, stateChange);\n        }\n        keys(stateChange)\n            .filter((key) => stateChange[key] !== undefined)\n            .forEach((key) => {\n            const listener = this.onStateChangedListeners.get(key);\n            if (listener) {\n                listener(oldState, newState, stateChange);\n            }\n        });\n    }\n}\n//# sourceMappingURL=MatrixClientStore.js.map"]},"metadata":{},"sourceType":"module"}