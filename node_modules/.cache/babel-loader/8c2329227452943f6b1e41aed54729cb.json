{"ast":null,"code":"export { default as mergeWith } from \"lodash.mergewith\";\nexport { default as objectAssign } from \"object-assign\";\nexport function omit(object, keys) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) return;\n    result[key] = object[key];\n  });\n  return result;\n}\nexport function pick(object, keys) {\n  var result = {};\n  keys.forEach(key => {\n    if (key in object) {\n      result[key] = object[key];\n    }\n  });\n  return result;\n}\nexport function split(object, keys) {\n  var picked = {};\n  var omitted = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) {\n      picked[key] = object[key];\n    } else {\n      omitted[key] = object[key];\n    }\n  });\n  return [picked, omitted];\n}\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\n\nexport function get(obj, path, fallback, index) {\n  var key = typeof path === \"string\" ? path.split(\".\") : [path];\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) {\n      break;\n    }\n\n    obj = obj[key[index]];\n  }\n\n  return obj === undefined ? fallback : obj;\n}\nexport var memoize = fn => {\n  var cache = new WeakMap();\n\n  var memoizedFn = (obj, path, fallback, index) => {\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map());\n    }\n\n    var map = cache.get(obj);\n\n    if (map.has(path)) {\n      return map.get(path);\n    }\n\n    var value = fn(obj, path, fallback, index);\n    map.set(path, value);\n    return value;\n  };\n\n  return memoizedFn;\n};\nexport var memoizedGet = memoize(get);\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\n\nexport function getWithDefault(path, scale) {\n  return get(scale, path, path);\n}\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\n\nexport function objectFilter(object, fn) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    var value = object[key];\n    var shouldPass = fn(value, key, object);\n\n    if (shouldPass) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\nexport var filterUndefined = object => objectFilter(object, val => val !== null && val !== undefined);\nexport var objectKeys = obj => Object.keys(obj);\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\n\nexport var fromEntries = entries => entries.reduce((carry, _ref) => {\n  var [key, value] = _ref;\n  carry[key] = value;\n  return carry;\n}, {});","map":{"version":3,"mappings":"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","names":["default","mergeWith","objectAssign","omit","object","keys","result","Object","forEach","key","includes","pick","split","picked","omitted","get","obj","path","fallback","index","length","undefined","memoize","fn","cache","WeakMap","memoizedFn","has","set","Map","map","value","memoizedGet","getWithDefault","scale","objectFilter","shouldPass","filterUndefined","val","objectKeys","fromEntries","entries","reduce","carry","_ref"],"sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@chakra-ui/utils/dist/esm/object.js"],"sourcesContent":["export { default as mergeWith } from \"lodash.mergewith\";\nexport { default as objectAssign } from \"object-assign\";\nexport function omit(object, keys) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) return;\n    result[key] = object[key];\n  });\n  return result;\n}\nexport function pick(object, keys) {\n  var result = {};\n  keys.forEach(key => {\n    if (key in object) {\n      result[key] = object[key];\n    }\n  });\n  return result;\n}\nexport function split(object, keys) {\n  var picked = {};\n  var omitted = {};\n  Object.keys(object).forEach(key => {\n    if (keys.includes(key)) {\n      picked[key] = object[key];\n    } else {\n      omitted[key] = object[key];\n    }\n  });\n  return [picked, omitted];\n}\n/**\n * Get value from a deeply nested object using a string path.\n * Memoizes the value.\n * @param obj - the object\n * @param path - the string path\n * @param def  - the fallback value\n */\n\nexport function get(obj, path, fallback, index) {\n  var key = typeof path === \"string\" ? path.split(\".\") : [path];\n\n  for (index = 0; index < key.length; index += 1) {\n    if (!obj) {\n      break;\n    }\n\n    obj = obj[key[index]];\n  }\n\n  return obj === undefined ? fallback : obj;\n}\nexport var memoize = fn => {\n  var cache = new WeakMap();\n\n  var memoizedFn = (obj, path, fallback, index) => {\n    if (!cache.has(obj)) {\n      cache.set(obj, new Map());\n    }\n\n    var map = cache.get(obj);\n\n    if (map.has(path)) {\n      return map.get(path);\n    }\n\n    var value = fn(obj, path, fallback, index);\n    map.set(path, value);\n    return value;\n  };\n\n  return memoizedFn;\n};\nexport var memoizedGet = memoize(get);\n/**\n * Get value from deeply nested object, based on path\n * It returns the path value if not found in object\n *\n * @param path - the string path or value\n * @param scale - the string path or value\n */\n\nexport function getWithDefault(path, scale) {\n  return get(scale, path, path);\n}\n\n/**\n * Returns the items of an object that meet the condition specified in a callback function.\n *\n * @param object the object to loop through\n * @param fn The filter function\n */\nexport function objectFilter(object, fn) {\n  var result = {};\n  Object.keys(object).forEach(key => {\n    var value = object[key];\n    var shouldPass = fn(value, key, object);\n\n    if (shouldPass) {\n      result[key] = value;\n    }\n  });\n  return result;\n}\nexport var filterUndefined = object => objectFilter(object, val => val !== null && val !== undefined);\nexport var objectKeys = obj => Object.keys(obj);\n/**\n * Object.entries polyfill for Nodev10 compatibility\n */\n\nexport var fromEntries = entries => entries.reduce((carry, _ref) => {\n  var [key, value] = _ref;\n  carry[key] = value;\n  return carry;\n}, {});\n//# sourceMappingURL=object.js.map"]},"metadata":{},"sourceType":"module"}