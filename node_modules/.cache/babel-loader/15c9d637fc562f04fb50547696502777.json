{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as sodium from 'libsodium-wrappers';\nimport BigNumber from 'bignumber.js';\nimport { getHexHash, toHex, sealCryptobox, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from './utils/crypto';\nimport { MatrixClient } from './matrix-client/MatrixClient';\nimport { MatrixClientEventType } from './matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from './matrix-client/models/MatrixMessage';\nexport class P2PCommunicationClient {\n  constructor(name, keyPair, replicationCount) {\n    let debug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this.name = name;\n    this.keyPair = keyPair;\n    this.replicationCount = replicationCount;\n    this.debug = debug;\n    this.clients = [];\n    this.KNOWN_RELAY_SERVERS = ['matrix.papers.tech' // 'matrix.tez.ie',\n    // 'matrix-dev.papers.tech',\n    // \"matrix.stove-labs.com\",\n    // \"yadayada.cryptonomic-infra.tech\"\n    ];\n    this.activeListeners = new Map();\n  }\n\n  getHandshakeInfo() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        name: this.name,\n        publicKey: yield this.getPublicKey(),\n        relayServer: yield this.getRelayServer()\n      };\n    });\n  }\n\n  getRelayServer(publicKeyHash) {\n    let nonce = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.keyPair) {\n        throw new Error('KeyPair not available');\n      }\n\n      const hash = publicKeyHash || (yield getHexHash(this.keyPair.publicKey));\n      return this.KNOWN_RELAY_SERVERS.reduce((prevPromise, curr) => __awaiter(this, void 0, void 0, function* () {\n        const prev = yield prevPromise;\n        const prevRelayServerHash = yield getHexHash(prev + nonce);\n        const currRelayServerHash = yield getHexHash(curr + nonce);\n        const prevBigInt = yield this.getAbsoluteBigIntDifference(hash, prevRelayServerHash);\n        const currBigInt = yield this.getAbsoluteBigIntDifference(hash, currRelayServerHash);\n        return prevBigInt.isLessThan(currBigInt) ? prev : curr;\n      }), Promise.resolve(this.KNOWN_RELAY_SERVERS[0]));\n    });\n  }\n\n  start() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.log('starting client');\n      yield sodium.ready;\n      const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n      const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n      yield this.log(`connecting to ${this.replicationCount} servers`);\n\n      for (let i = 0; i < this.replicationCount; i++) {\n        // TODO: Parallel\n        const client = MatrixClient.create({\n          baseUrl: `https://${yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString())}`\n        });\n        client.subscribe(MatrixClientEventType.INVITE, event => __awaiter(this, void 0, void 0, function* () {\n          yield client.joinRooms(event.content.roomId);\n        }));\n        yield this.log('login', yield this.getPublicKeyHash(), 'on', yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString()));\n        yield client.start({\n          id: yield this.getPublicKeyHash(),\n          password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n          deviceId: toHex(this.keyPair.publicKey)\n        }).catch(error => this.log(error));\n        yield client.joinRooms(...client.invitedRooms).catch(error => this.log(error));\n        this.clients.push(client);\n      }\n    });\n  }\n\n  listenForEncryptedMessage(senderPublicKey, messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.keyPair) {\n        throw new Error('KeyPair not available');\n      }\n\n      const {\n        sharedRx\n      } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n\n      if (this.activeListeners.has(senderPublicKey)) {\n        return;\n      }\n\n      const callbackFunction = event => __awaiter(this, void 0, void 0, function* () {\n        if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n          const payload = Buffer.from(event.content.message.content, 'hex');\n\n          if (payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n            try {\n              messageCallback(yield decryptCryptoboxPayload(payload, sharedRx));\n            } catch (decryptionError) {\n              /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n            }\n          }\n        }\n      });\n\n      this.activeListeners.set(senderPublicKey, callbackFunction);\n\n      for (const client of this.clients) {\n        client.subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n      }\n    });\n  }\n\n  unsubscribeFromEncryptedMessage(senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const listener = this.activeListeners.get(senderPublicKey);\n\n      if (!listener) {\n        return;\n      }\n\n      for (const client of this.clients) {\n        client.unsubscribe(MatrixClientEventType.MESSAGE, listener);\n      }\n\n      this.activeListeners.delete(senderPublicKey);\n    });\n  }\n\n  unsubscribeFromEncryptedMessages() {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const client of this.clients) {\n        client.unsubscribe(MatrixClientEventType.MESSAGE);\n      }\n\n      this.activeListeners.clear();\n    });\n  }\n\n  sendMessage(recipientPublicKey, message) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.keyPair) {\n        throw new Error('KeyPair not available');\n      }\n\n      const {\n        sharedTx\n      } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n\n      for (let i = 0; i < this.replicationCount; i++) {\n        const recipientHash = yield getHexHash(Buffer.from(recipientPublicKey, 'hex'));\n        const recipient = recipientString(recipientHash, yield this.getRelayServer(recipientHash, i.toString()));\n\n        for (const client of this.clients) {\n          const room = yield this.getRelevantRoom(client, recipient);\n          client.sendTextMessage(room.id, yield encryptCryptoboxPayload(message, sharedTx)).catch(error => this.log(error));\n        }\n      }\n    });\n  }\n\n  listenForChannelOpening(messageCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      for (const client of this.clients) {\n        client.subscribe(MatrixClientEventType.MESSAGE, event => __awaiter(this, void 0, void 0, function* () {\n          yield this.log('channel opening', event);\n\n          if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n            if (!this.keyPair) {\n              throw new Error('KeyPair not available');\n            }\n\n            yield this.log('new channel open event!');\n            const splits = event.content.message.content.split(':');\n            const payload = Buffer.from(splits[splits.length - 1], 'hex');\n\n            if (payload.length >= sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n              try {\n                messageCallback(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n              } catch (decryptionError) {\n                /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n              }\n            }\n          }\n        }));\n      }\n    });\n  }\n\n  openChannel(recipientPublicKey, relayServer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.log('open channel');\n      const recipientHash = yield getHexHash(Buffer.from(recipientPublicKey, 'hex'));\n      const recipient = recipientString(recipientHash, relayServer);\n      yield this.log(`currently there are ${this.clients.length} clients open`);\n\n      for (const client of this.clients) {\n        const room = yield this.getRelevantRoom(client, recipient);\n        const encryptedMessage = yield sealCryptobox(yield this.getPublicKey(), Buffer.from(recipientPublicKey, 'hex'));\n        client.sendTextMessage(room.id, ['@channel-open', recipient, encryptedMessage].join(':')).catch(error => this.log(error));\n      }\n    });\n  }\n\n  isTextMessage(content) {\n    return content.message.type === MatrixMessageType.TEXT;\n  }\n\n  isChannelOpenMessage(content) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n    });\n  }\n\n  isSender(event, senderPublicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n    });\n  }\n\n  getPublicKey() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.keyPair) {\n        throw new Error('KeyPair not available');\n      }\n\n      return toHex(this.keyPair.publicKey);\n    });\n  }\n\n  getPublicKeyHash() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.keyPair) {\n        throw new Error('KeyPair not available');\n      }\n\n      return getHexHash(this.keyPair.publicKey);\n    });\n  }\n\n  getAbsoluteBigIntDifference(firstHash, secondHash) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const difference = new BigNumber(`0x${firstHash}`).minus(`0x${secondHash}`);\n      return difference.absoluteValue();\n    });\n  }\n\n  createCryptoBox(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO: Don't calculate it every time?\n      const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n\n      const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n\n      const kxOtherPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n\n      return [Buffer.from(kxSelfPublicKey), Buffer.from(kxSelfPrivateKey), Buffer.from(kxOtherPublicKey)];\n    });\n  }\n\n  createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return sodium.crypto_kx_server_session_keys(...keys);\n    });\n  }\n\n  createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n      return sodium.crypto_kx_client_session_keys(...keys);\n    });\n  }\n\n  getRelevantRoom(client, recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const joinedRooms = client.joinedRooms;\n      const relevantRooms = joinedRooms.filter(roomElement => roomElement.members.some(member => member === recipient));\n      let room;\n\n      if (relevantRooms.length === 0) {\n        yield this.log(`no relevant rooms found`);\n        const roomId = yield client.createTrustedPrivateRoom(recipient);\n        room = client.getRoomById(roomId);\n      } else {\n        room = relevantRooms[0];\n        yield this.log(`channel already open, reusing room ${room.id}`);\n      }\n\n      return room;\n    });\n  }\n\n  log() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.debug) {\n        console.log(`--- [P2PCommunicationClient]:${this.name}: `, ...args);\n      }\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","sodium","BigNumber","getHexHash","toHex","sealCryptobox","recipientString","openCryptobox","encryptCryptoboxPayload","decryptCryptoboxPayload","MatrixClient","MatrixClientEventType","MatrixMessageType","P2PCommunicationClient","constructor","name","keyPair","replicationCount","debug","clients","KNOWN_RELAY_SERVERS","activeListeners","Map","getHandshakeInfo","publicKey","getPublicKey","relayServer","getRelayServer","publicKeyHash","nonce","Error","hash","reduce","prevPromise","curr","prev","prevRelayServerHash","currRelayServerHash","prevBigInt","getAbsoluteBigIntDifference","currBigInt","isLessThan","start","log","ready","loginRawDigest","crypto_generichash","from_string","Math","floor","Date","now","rawSignature","crypto_sign_detached","privateKey","i","client","create","baseUrl","getPublicKeyHash","toString","subscribe","INVITE","event","joinRooms","content","roomId","id","password","deviceId","catch","error","invitedRooms","push","listenForEncryptedMessage","senderPublicKey","messageCallback","sharedRx","createCryptoBoxServer","has","callbackFunction","isTextMessage","isSender","payload","Buffer","from","message","length","crypto_secretbox_NONCEBYTES","crypto_secretbox_MACBYTES","decryptionError","set","MESSAGE","unsubscribeFromEncryptedMessage","listener","get","unsubscribe","delete","unsubscribeFromEncryptedMessages","clear","sendMessage","recipientPublicKey","sharedTx","createCryptoBoxClient","recipientHash","recipient","room","getRelevantRoom","sendTextMessage","listenForChannelOpening","isChannelOpenMessage","splits","split","openChannel","encryptedMessage","join","type","TEXT","startsWith","sender","firstHash","secondHash","difference","minus","absoluteValue","createCryptoBox","otherPublicKey","selfPrivateKey","kxSelfPrivateKey","crypto_sign_ed25519_sk_to_curve25519","kxSelfPublicKey","crypto_sign_ed25519_pk_to_curve25519","slice","kxOtherPublicKey","keys","crypto_kx_server_session_keys","crypto_kx_client_session_keys","joinedRooms","relevantRooms","filter","roomElement","members","some","member","createTrustedPrivateRoom","getRoomById","args","console"],"sourceRoot":"","sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@airgap/beacon-sdk/dist/esm/P2PCommunicationClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as sodium from 'libsodium-wrappers';\nimport BigNumber from 'bignumber.js';\nimport { getHexHash, toHex, sealCryptobox, recipientString, openCryptobox, encryptCryptoboxPayload, decryptCryptoboxPayload } from './utils/crypto';\nimport { MatrixClient } from './matrix-client/MatrixClient';\nimport { MatrixClientEventType } from './matrix-client/models/MatrixClientEvent';\nimport { MatrixMessageType } from './matrix-client/models/MatrixMessage';\nexport class P2PCommunicationClient {\n    constructor(name, keyPair, replicationCount, debug = false) {\n        this.name = name;\n        this.keyPair = keyPair;\n        this.replicationCount = replicationCount;\n        this.debug = debug;\n        this.clients = [];\n        this.KNOWN_RELAY_SERVERS = [\n            'matrix.papers.tech'\n            // 'matrix.tez.ie',\n            // 'matrix-dev.papers.tech',\n            // \"matrix.stove-labs.com\",\n            // \"yadayada.cryptonomic-infra.tech\"\n        ];\n        this.activeListeners = new Map();\n    }\n    getHandshakeInfo() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                name: this.name,\n                publicKey: yield this.getPublicKey(),\n                relayServer: yield this.getRelayServer()\n            };\n        });\n    }\n    getRelayServer(publicKeyHash, nonce = '') {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.keyPair) {\n                throw new Error('KeyPair not available');\n            }\n            const hash = publicKeyHash || (yield getHexHash(this.keyPair.publicKey));\n            return this.KNOWN_RELAY_SERVERS.reduce((prevPromise, curr) => __awaiter(this, void 0, void 0, function* () {\n                const prev = yield prevPromise;\n                const prevRelayServerHash = yield getHexHash(prev + nonce);\n                const currRelayServerHash = yield getHexHash(curr + nonce);\n                const prevBigInt = yield this.getAbsoluteBigIntDifference(hash, prevRelayServerHash);\n                const currBigInt = yield this.getAbsoluteBigIntDifference(hash, currRelayServerHash);\n                return prevBigInt.isLessThan(currBigInt) ? prev : curr;\n            }), Promise.resolve(this.KNOWN_RELAY_SERVERS[0]));\n        });\n    }\n    start() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.log('starting client');\n            yield sodium.ready;\n            const loginRawDigest = sodium.crypto_generichash(32, sodium.from_string(`login:${Math.floor(Date.now() / 1000 / (5 * 60))}`));\n            const rawSignature = sodium.crypto_sign_detached(loginRawDigest, this.keyPair.privateKey);\n            yield this.log(`connecting to ${this.replicationCount} servers`);\n            for (let i = 0; i < this.replicationCount; i++) {\n                // TODO: Parallel\n                const client = MatrixClient.create({\n                    baseUrl: `https://${yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString())}`\n                });\n                client.subscribe(MatrixClientEventType.INVITE, (event) => __awaiter(this, void 0, void 0, function* () {\n                    yield client.joinRooms(event.content.roomId);\n                }));\n                yield this.log('login', yield this.getPublicKeyHash(), 'on', yield this.getRelayServer(yield this.getPublicKeyHash(), i.toString()));\n                yield client\n                    .start({\n                    id: yield this.getPublicKeyHash(),\n                    password: `ed:${toHex(rawSignature)}:${yield this.getPublicKey()}`,\n                    deviceId: toHex(this.keyPair.publicKey)\n                })\n                    .catch((error) => this.log(error));\n                yield client.joinRooms(...client.invitedRooms).catch((error) => this.log(error));\n                this.clients.push(client);\n            }\n        });\n    }\n    listenForEncryptedMessage(senderPublicKey, messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.keyPair) {\n                throw new Error('KeyPair not available');\n            }\n            const { sharedRx } = yield this.createCryptoBoxServer(senderPublicKey, this.keyPair.privateKey);\n            if (this.activeListeners.has(senderPublicKey)) {\n                return;\n            }\n            const callbackFunction = (event) => __awaiter(this, void 0, void 0, function* () {\n                if (this.isTextMessage(event.content) && (yield this.isSender(event, senderPublicKey))) {\n                    const payload = Buffer.from(event.content.message.content, 'hex');\n                    if (payload.length >=\n                        sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                        try {\n                            messageCallback(yield decryptCryptoboxPayload(payload, sharedRx));\n                        }\n                        catch (decryptionError) {\n                            /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                        }\n                    }\n                }\n            });\n            this.activeListeners.set(senderPublicKey, callbackFunction);\n            for (const client of this.clients) {\n                client.subscribe(MatrixClientEventType.MESSAGE, callbackFunction);\n            }\n        });\n    }\n    unsubscribeFromEncryptedMessage(senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const listener = this.activeListeners.get(senderPublicKey);\n            if (!listener) {\n                return;\n            }\n            for (const client of this.clients) {\n                client.unsubscribe(MatrixClientEventType.MESSAGE, listener);\n            }\n            this.activeListeners.delete(senderPublicKey);\n        });\n    }\n    unsubscribeFromEncryptedMessages() {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const client of this.clients) {\n                client.unsubscribe(MatrixClientEventType.MESSAGE);\n            }\n            this.activeListeners.clear();\n        });\n    }\n    sendMessage(recipientPublicKey, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.keyPair) {\n                throw new Error('KeyPair not available');\n            }\n            const { sharedTx } = yield this.createCryptoBoxClient(recipientPublicKey, this.keyPair.privateKey);\n            for (let i = 0; i < this.replicationCount; i++) {\n                const recipientHash = yield getHexHash(Buffer.from(recipientPublicKey, 'hex'));\n                const recipient = recipientString(recipientHash, yield this.getRelayServer(recipientHash, i.toString()));\n                for (const client of this.clients) {\n                    const room = yield this.getRelevantRoom(client, recipient);\n                    client\n                        .sendTextMessage(room.id, yield encryptCryptoboxPayload(message, sharedTx))\n                        .catch((error) => this.log(error));\n                }\n            }\n        });\n    }\n    listenForChannelOpening(messageCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const client of this.clients) {\n                client.subscribe(MatrixClientEventType.MESSAGE, (event) => __awaiter(this, void 0, void 0, function* () {\n                    yield this.log('channel opening', event);\n                    if (this.isTextMessage(event.content) && (yield this.isChannelOpenMessage(event.content))) {\n                        if (!this.keyPair) {\n                            throw new Error('KeyPair not available');\n                        }\n                        yield this.log('new channel open event!');\n                        const splits = event.content.message.content.split(':');\n                        const payload = Buffer.from(splits[splits.length - 1], 'hex');\n                        if (payload.length >=\n                            sodium.crypto_secretbox_NONCEBYTES + sodium.crypto_secretbox_MACBYTES) {\n                            try {\n                                messageCallback(yield openCryptobox(payload, this.keyPair.publicKey, this.keyPair.privateKey));\n                            }\n                            catch (decryptionError) {\n                                /* NO-OP. We try to decode every message, but some might not be addressed to us. */\n                            }\n                        }\n                    }\n                }));\n            }\n        });\n    }\n    openChannel(recipientPublicKey, relayServer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.log('open channel');\n            const recipientHash = yield getHexHash(Buffer.from(recipientPublicKey, 'hex'));\n            const recipient = recipientString(recipientHash, relayServer);\n            yield this.log(`currently there are ${this.clients.length} clients open`);\n            for (const client of this.clients) {\n                const room = yield this.getRelevantRoom(client, recipient);\n                const encryptedMessage = yield sealCryptobox(yield this.getPublicKey(), Buffer.from(recipientPublicKey, 'hex'));\n                client\n                    .sendTextMessage(room.id, ['@channel-open', recipient, encryptedMessage].join(':'))\n                    .catch((error) => this.log(error));\n            }\n        });\n    }\n    isTextMessage(content) {\n        return content.message.type === MatrixMessageType.TEXT;\n    }\n    isChannelOpenMessage(content) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return content.message.content.startsWith(`@channel-open:@${yield getHexHash(Buffer.from(yield this.getPublicKey(), 'hex'))}`);\n        });\n    }\n    isSender(event, senderPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return event.content.message.sender.startsWith(`@${yield getHexHash(Buffer.from(senderPublicKey, 'hex'))}`);\n        });\n    }\n    getPublicKey() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.keyPair) {\n                throw new Error('KeyPair not available');\n            }\n            return toHex(this.keyPair.publicKey);\n        });\n    }\n    getPublicKeyHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.keyPair) {\n                throw new Error('KeyPair not available');\n            }\n            return getHexHash(this.keyPair.publicKey);\n        });\n    }\n    getAbsoluteBigIntDifference(firstHash, secondHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const difference = new BigNumber(`0x${firstHash}`).minus(`0x${secondHash}`);\n            return difference.absoluteValue();\n        });\n    }\n    createCryptoBox(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // TODO: Don't calculate it every time?\n            const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(selfPrivateKey)); // Secret bytes to scalar bytes\n            const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(selfPrivateKey).slice(32, 64)); // Secret bytes to scalar bytes\n            const kxOtherPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(otherPublicKey, 'hex')); // Secret bytes to scalar bytes\n            return [\n                Buffer.from(kxSelfPublicKey),\n                Buffer.from(kxSelfPrivateKey),\n                Buffer.from(kxOtherPublicKey)\n            ];\n        });\n    }\n    createCryptoBoxServer(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n            return sodium.crypto_kx_server_session_keys(...keys);\n        });\n    }\n    createCryptoBoxClient(otherPublicKey, selfPrivateKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const keys = yield this.createCryptoBox(otherPublicKey, selfPrivateKey);\n            return sodium.crypto_kx_client_session_keys(...keys);\n        });\n    }\n    getRelevantRoom(client, recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const joinedRooms = client.joinedRooms;\n            const relevantRooms = joinedRooms.filter((roomElement) => roomElement.members.some((member) => member === recipient));\n            let room;\n            if (relevantRooms.length === 0) {\n                yield this.log(`no relevant rooms found`);\n                const roomId = yield client.createTrustedPrivateRoom(recipient);\n                room = client.getRoomById(roomId);\n            }\n            else {\n                room = relevantRooms[0];\n                yield this.log(`channel already open, reusing room ${room.id}`);\n            }\n            return room;\n        });\n    }\n    log(...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.debug) {\n                console.log(`--- [P2PCommunicationClient]:${this.name}: `, ...args);\n            }\n        });\n    }\n}\n//# sourceMappingURL=P2PCommunicationClient.js.map"]},"metadata":{},"sourceType":"module"}