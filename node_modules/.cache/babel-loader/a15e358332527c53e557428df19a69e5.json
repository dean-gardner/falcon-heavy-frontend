{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport * as bs58check from 'bs58check';\nimport * as sodium from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexport function toHex(value) {\n  return Buffer.from(value).toString('hex');\n}\nexport function getHexHash(key) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    return toHex(sodium.crypto_generichash(32, key));\n  });\n}\nexport function getKeypairFromSeed(seed) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    return sodium.crypto_sign_seed_keypair(sodium.crypto_generichash(32, sodium.from_string(seed)));\n  });\n}\nexport function encryptCryptoboxPayload(message, sharedKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const nonce = Buffer.from(sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES));\n    const combinedPayload = Buffer.concat([nonce, Buffer.from(sodium.crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))]);\n    return toHex(combinedPayload);\n  });\n}\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const nonce = payload.slice(0, sodium.crypto_secretbox_NONCEBYTES);\n    const ciphertext = payload.slice(sodium.crypto_secretbox_NONCEBYTES);\n    return Buffer.from(sodium.crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8');\n  });\n}\nexport function sealCryptobox(payload, publicKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n    const encryptedMessage = sodium.crypto_box_seal(payload, kxSelfPublicKey);\n    return toHex(encryptedMessage);\n  });\n}\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n\n    const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n\n    const decryptedMessage = sodium.crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n    return Buffer.from(decryptedMessage).toString();\n  });\n}\nexport function getAddressFromPublicKey(publicKey) {\n  return __awaiter(this, void 0, void 0, function* () {\n    yield sodium.ready;\n    let plainPublicKey;\n\n    if (publicKey.length === 64) {\n      plainPublicKey = publicKey;\n    } else if (publicKey.startsWith('edpk') && publicKey.length === 54) {\n      const edpkPrefixLength = 4;\n      const decoded = bs58check.decode(publicKey);\n      plainPublicKey = decoded.slice(edpkPrefixLength, decoded.length).toString('hex');\n    } else {\n      throw new Error(`invalid publicKey: ${publicKey}`);\n    }\n\n    const payload = sodium.crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n    const tz1Prefix = Buffer.from(new Uint8Array([6, 161, 159]));\n    return bs58check.encode(Buffer.concat([tz1Prefix, Buffer.from(payload)]));\n  });\n}\nexport function recipientString(recipientHash, relayServer) {\n  return `@${recipientHash}:${relayServer}`;\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */","map":{"version":3,"mappings":"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","names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","bs58check","sodium","toHex","Buffer","from","toString","getHexHash","key","ready","crypto_generichash","getKeypairFromSeed","seed","crypto_sign_seed_keypair","from_string","encryptCryptoboxPayload","message","sharedKey","nonce","randombytes_buf","crypto_secretbox_NONCEBYTES","combinedPayload","concat","crypto_secretbox_easy","decryptCryptoboxPayload","payload","slice","ciphertext","crypto_secretbox_open_easy","sealCryptobox","publicKey","kxSelfPublicKey","crypto_sign_ed25519_pk_to_curve25519","encryptedMessage","crypto_box_seal","openCryptobox","encryptedPayload","privateKey","kxSelfPrivateKey","crypto_sign_ed25519_sk_to_curve25519","decryptedMessage","crypto_box_seal_open","getAddressFromPublicKey","plainPublicKey","length","startsWith","edpkPrefixLength","decoded","decode","Error","tz1Prefix","Uint8Array","encode","recipientString","recipientHash","relayServer"],"sourceRoot":"","sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@airgap/beacon-sdk/dist/esm/utils/crypto.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as bs58check from 'bs58check';\nimport * as sodium from 'libsodium-wrappers';\n/* eslint-disable prefer-arrow/prefer-arrow-functions */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function toHex(value) {\n    return Buffer.from(value).toString('hex');\n}\nexport function getHexHash(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        return toHex(sodium.crypto_generichash(32, key));\n    });\n}\nexport function getKeypairFromSeed(seed) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        return sodium.crypto_sign_seed_keypair(sodium.crypto_generichash(32, sodium.from_string(seed)));\n    });\n}\nexport function encryptCryptoboxPayload(message, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const nonce = Buffer.from(sodium.randombytes_buf(sodium.crypto_secretbox_NONCEBYTES));\n        const combinedPayload = Buffer.concat([\n            nonce,\n            Buffer.from(sodium.crypto_secretbox_easy(Buffer.from(message, 'utf8'), nonce, sharedKey))\n        ]);\n        return toHex(combinedPayload);\n    });\n}\nexport function decryptCryptoboxPayload(payload, sharedKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const nonce = payload.slice(0, sodium.crypto_secretbox_NONCEBYTES);\n        const ciphertext = payload.slice(sodium.crypto_secretbox_NONCEBYTES);\n        return Buffer.from(sodium.crypto_secretbox_open_easy(ciphertext, nonce, sharedKey)).toString('utf8');\n    });\n}\nexport function sealCryptobox(payload, publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const encryptedMessage = sodium.crypto_box_seal(payload, kxSelfPublicKey);\n        return toHex(encryptedMessage);\n    });\n}\nexport function openCryptobox(encryptedPayload, publicKey, privateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        const kxSelfPrivateKey = sodium.crypto_sign_ed25519_sk_to_curve25519(Buffer.from(privateKey)); // Secret bytes to scalar bytes\n        const kxSelfPublicKey = sodium.crypto_sign_ed25519_pk_to_curve25519(Buffer.from(publicKey)); // Secret bytes to scalar bytes\n        const decryptedMessage = sodium.crypto_box_seal_open(encryptedPayload, kxSelfPublicKey, kxSelfPrivateKey);\n        return Buffer.from(decryptedMessage).toString();\n    });\n}\nexport function getAddressFromPublicKey(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        yield sodium.ready;\n        let plainPublicKey;\n        if (publicKey.length === 64) {\n            plainPublicKey = publicKey;\n        }\n        else if (publicKey.startsWith('edpk') && publicKey.length === 54) {\n            const edpkPrefixLength = 4;\n            const decoded = bs58check.decode(publicKey);\n            plainPublicKey = decoded.slice(edpkPrefixLength, decoded.length).toString('hex');\n        }\n        else {\n            throw new Error(`invalid publicKey: ${publicKey}`);\n        }\n        const payload = sodium.crypto_generichash(20, Buffer.from(plainPublicKey, 'hex'));\n        const tz1Prefix = Buffer.from(new Uint8Array([6, 161, 159]));\n        return bs58check.encode(Buffer.concat([tz1Prefix, Buffer.from(payload)]));\n    });\n}\nexport function recipientString(recipientHash, relayServer) {\n    return `@${recipientHash}:${relayServer}`;\n}\n/* eslint-enable prefer-arrow/prefer-arrow-functions */\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"module"}