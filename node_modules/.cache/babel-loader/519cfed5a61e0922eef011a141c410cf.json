{"ast":null,"code":"import { useControllableProp } from \"@chakra-ui/hooks\";\nimport { countDecimalPlaces, clampValue, maxSafeInteger, minSafeInteger, toPrecision } from \"@chakra-ui/utils\";\nimport { useCallback, useState } from \"react\";\nexport function useCounter(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    keepWithinRange = true\n  } = props;\n  var [valueState, setValue] = useState(() => {\n    if (defaultValue == null) return \"\";\n    return cast(defaultValue, stepProp, precisionProp);\n  });\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n\n  var [isControlled, value] = useControllableProp(valueProp, valueState);\n  var decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  var precision = precisionProp != null ? precisionProp : decimalPlaces;\n  var update = useCallback(next => {\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n\n    onChange == null ? void 0 : onChange(next.toString(), parse(next));\n  }, [onChange, isControlled]); // Function to clamp the value and round it to the precision\n\n  var clamp = useCallback(value => {\n    var nextValue = value;\n\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  var increment = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next;\n    /**\n     * Let's follow the native browser behavior for\n     * scenarios where the input starts empty (\"\")\n     */\n\n    if (value === \"\") {\n      /**\n       * If `min` is set, native input, starts at the `min`.\n       * Else, it starts at `step`\n       */\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, props.min, stepProp, update, value]);\n  var decrement = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next; // Same thing here. We'll follow native implementation\n\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, props.min, stepProp, update, value]);\n  var reset = useCallback(() => {\n    var next;\n\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      next = cast(defaultValue, stepProp, precisionProp);\n    }\n\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update]);\n  var castValue = useCallback(value => {\n    update(cast(value, stepProp, precision));\n  }, [precision, stepProp, update]);\n  var valueAsNumber = parse(value);\n  /**\n   * Common range checks\n   */\n\n  var isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  var isAtMax = valueAsNumber === max;\n  var isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue\n  };\n}\n\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\n\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\n\nfunction cast(value, step, precision) {\n  var decimalPlaces = getDecimalPlaces(parse(value), step);\n  return toPrecision(parse(value), precision != null ? precision : decimalPlaces);\n}","map":{"version":3,"mappings":"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","names":["useControllableProp","countDecimalPlaces","clampValue","maxSafeInteger","minSafeInteger","toPrecision","useCallback","useState","useCounter","props","onChange","precision","precisionProp","defaultValue","value","valueProp","step","stepProp","min","max","keepWithinRange","valueState","setValue","cast","isControlled","decimalPlaces","getDecimalPlaces","parse","update","next","toString","clamp","nextValue","increment","decrement","reset","castValue","valueAsNumber","isOutOfRange","isAtMax","isAtMin","parseFloat","replace","Math"],"sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@chakra-ui/counter/dist/esm/use-counter.js"],"sourcesContent":["import { useControllableProp } from \"@chakra-ui/hooks\";\nimport { countDecimalPlaces, clampValue, maxSafeInteger, minSafeInteger, toPrecision } from \"@chakra-ui/utils\";\nimport { useCallback, useState } from \"react\";\nexport function useCounter(props) {\n  if (props === void 0) {\n    props = {};\n  }\n\n  var {\n    onChange,\n    precision: precisionProp,\n    defaultValue,\n    value: valueProp,\n    step: stepProp = 1,\n    min = minSafeInteger,\n    max = maxSafeInteger,\n    keepWithinRange = true\n  } = props;\n  var [valueState, setValue] = useState(() => {\n    if (defaultValue == null) return \"\";\n    return cast(defaultValue, stepProp, precisionProp);\n  });\n  /**\n   * Because the component that consumes this hook can be controlled or uncontrolled\n   * we'll keep track of that\n   */\n\n  var [isControlled, value] = useControllableProp(valueProp, valueState);\n  var decimalPlaces = getDecimalPlaces(parse(value), stepProp);\n  var precision = precisionProp != null ? precisionProp : decimalPlaces;\n  var update = useCallback(next => {\n    if (!isControlled) {\n      setValue(next.toString());\n    }\n\n    onChange == null ? void 0 : onChange(next.toString(), parse(next));\n  }, [onChange, isControlled]); // Function to clamp the value and round it to the precision\n\n  var clamp = useCallback(value => {\n    var nextValue = value;\n\n    if (keepWithinRange) {\n      nextValue = clampValue(nextValue, min, max);\n    }\n\n    return toPrecision(nextValue, precision);\n  }, [precision, keepWithinRange, max, min]);\n  var increment = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next;\n    /**\n     * Let's follow the native browser behavior for\n     * scenarios where the input starts empty (\"\")\n     */\n\n    if (value === \"\") {\n      /**\n       * If `min` is set, native input, starts at the `min`.\n       * Else, it starts at `step`\n       */\n      next = parse(step);\n    } else {\n      next = parse(value) + step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, props.min, stepProp, update, value]);\n  var decrement = useCallback(function (step) {\n    if (step === void 0) {\n      step = stepProp;\n    }\n\n    var next; // Same thing here. We'll follow native implementation\n\n    if (value === \"\") {\n      next = parse(-step);\n    } else {\n      next = parse(value) - step;\n    }\n\n    next = clamp(next);\n    update(next);\n  }, [clamp, props.min, stepProp, update, value]);\n  var reset = useCallback(() => {\n    var next;\n\n    if (defaultValue == null) {\n      next = \"\";\n    } else {\n      next = cast(defaultValue, stepProp, precisionProp);\n    }\n\n    update(next);\n  }, [defaultValue, precisionProp, stepProp, update]);\n  var castValue = useCallback(value => {\n    update(cast(value, stepProp, precision));\n  }, [precision, stepProp, update]);\n  var valueAsNumber = parse(value);\n  /**\n   * Common range checks\n   */\n\n  var isOutOfRange = valueAsNumber > max || valueAsNumber < min;\n  var isAtMax = valueAsNumber === max;\n  var isAtMin = valueAsNumber === min;\n  return {\n    isOutOfRange,\n    isAtMax,\n    isAtMin,\n    precision,\n    value,\n    valueAsNumber,\n    update,\n    reset,\n    increment,\n    decrement,\n    clamp,\n    cast: castValue\n  };\n}\n\nfunction parse(value) {\n  return parseFloat(value.toString().replace(/[^\\w.-]+/g, \"\"));\n}\n\nfunction getDecimalPlaces(value, step) {\n  return Math.max(countDecimalPlaces(step), countDecimalPlaces(value));\n}\n\nfunction cast(value, step, precision) {\n  var decimalPlaces = getDecimalPlaces(parse(value), step);\n  return toPrecision(parse(value), precision != null ? precision : decimalPlaces);\n}\n//# sourceMappingURL=use-counter.js.map"]},"metadata":{},"sourceType":"module"}