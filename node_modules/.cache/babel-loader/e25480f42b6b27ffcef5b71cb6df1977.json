{"ast":null,"code":"/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  extendStatics(d, b);\n\n  function __() {\n    this.constructor = d;\n  }\n\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nfunction __generator(thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n}\n\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n\n  return ar;\n}\n\nvar ScanError =\n/** @class */\nfunction (_super) {\n  __extends(ScanError, _super);\n\n  function ScanError(src, idx, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.src = src;\n    _this.idx = idx;\n    return _this;\n  }\n\n  return ScanError;\n}(Error);\n\nvar Literal;\n\n(function (Literal) {\n  Literal[Literal[\"Comment\"] = 0] = \"Comment\";\n  Literal[Literal[\"Number\"] = 1] = \"Number\";\n  Literal[Literal[\"String\"] = 2] = \"String\";\n  Literal[Literal[\"Bytes\"] = 3] = \"Bytes\";\n  Literal[Literal[\"Ident\"] = 4] = \"Ident\";\n})(Literal || (Literal = {}));\n\nvar isSpace = new RegExp(\"\\\\s\");\nvar isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nvar isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nvar isDigit = new RegExp(\"[0-9]\");\nvar isHex = new RegExp(\"[0-9a-fA-F]\");\n\nfunction scan(src, scanComments) {\n  var i, s, start, ii, esc;\n\n  if (scanComments === void 0) {\n    scanComments = false;\n  }\n\n  return __generator(this, function (_a) {\n    switch (_a.label) {\n      case 0:\n        i = 0;\n        _a.label = 1;\n\n      case 1:\n        if (!(i < src.length)) return [3\n        /*break*/\n        , 16]; // Skip space\n\n        while (i < src.length && isSpace.test(src[i])) {\n          i++;\n        }\n\n        if (i === src.length) {\n          return [2\n          /*return*/\n          ];\n        }\n\n        s = src[i];\n        start = i;\n        if (!isIdentStart.test(s)) return [3\n        /*break*/\n        , 3]; // Identifier\n\n        i++;\n\n        while (i < src.length && isIdent.test(src[i])) {\n          i++;\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Ident,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 2:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 3:\n        if (!(src.length - i > 1 && src.substr(i, 2) === \"0x\")) return [3\n        /*break*/\n        , 5]; // Bytes\n\n        i += 2;\n\n        while (i < src.length && isHex.test(src[i])) {\n          i++;\n        }\n\n        if (i - start === 2) {\n          throw new ScanError(src, i, \"Bytes literal is too short\");\n        } else if ((i - start & 1) !== 0) {\n          throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Bytes,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 4:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 5:\n        if (!(isDigit.test(s) || s === \"-\")) return [3\n        /*break*/\n        , 7]; // Number\n\n        if (s === \"-\") {\n          i++;\n        }\n\n        ii = i;\n\n        while (i < src.length && isDigit.test(src[i])) {\n          i++;\n        }\n\n        if (ii === i) {\n          throw new ScanError(src, i, \"Number literal is too short\");\n        }\n\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Number,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 6:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 7:\n        if (!(s === \"\\\"\")) return [3\n        /*break*/\n        , 9]; // String\n\n        i++;\n        esc = false;\n\n        for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\n          if (!esc && src[i] === \"\\\\\") {\n            esc = true;\n          } else {\n            esc = false;\n          }\n        }\n\n        if (i === src.length) {\n          throw new ScanError(src, i, \"Unterminated string literal\");\n        }\n\n        i++;\n        return [4\n        /*yield*/\n        , {\n          t: Literal.String,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 8:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 9:\n        if (!(s === \"#\")) return [3\n        /*break*/\n        , 12]; // Comment\n\n        i++;\n\n        while (i < src.length && src[i] !== \"\\n\") {\n          i++;\n        }\n\n        if (!scanComments) return [3\n        /*break*/\n        , 11];\n        return [4\n        /*yield*/\n        , {\n          t: Literal.Comment,\n          v: src.slice(start, i),\n          offset: i\n        }];\n\n      case 10:\n        _a.sent();\n\n        _a.label = 11;\n\n      case 11:\n        return [3\n        /*break*/\n        , 15];\n\n      case 12:\n        if (!(s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\")) return [3\n        /*break*/\n        , 14];\n        i++;\n        return [4\n        /*yield*/\n        , {\n          t: s,\n          v: s,\n          offset: i\n        }];\n\n      case 13:\n        _a.sent();\n\n        return [3\n        /*break*/\n        , 15];\n\n      case 14:\n        throw new ScanError(src, i, \"Invalid character at offset \" + i + \": `\" + s + \"'\");\n\n      case 15:\n        return [3\n        /*break*/\n        , 1];\n\n      case 16:\n        return [2\n        /*return*/\n        ];\n    }\n  });\n}\n\nvar MacroError =\n/** @class */\nfunction (_super) {\n  __extends(MacroError, _super);\n\n  function MacroError(prim, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.prim = prim;\n    Object.setPrototypeOf(_this, MacroError.prototype);\n    return _this;\n  }\n\n  return MacroError;\n}(Error);\n\nfunction assertArgs(ex, n) {\n  var _a, _b;\n\n  if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"macro \" + ex.prim + \" expects \" + n + \" arguments, was given \" + ((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length));\n}\n\nfunction assertNoAnnots(ex) {\n  if (ex.annots === undefined) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + ex.annots);\n}\n\nfunction assertIntArg(ex, arg) {\n  if (\"int\" in arg) {\n    return true;\n  }\n\n  throw new MacroError(ex, \"macro \" + ex.prim + \" expects int argument\");\n}\n\nfunction parsePairUnpairExpr(p, expr, annotations, agg) {\n  var i = 0;\n  var ai = 0;\n  var ann = [null, null]; // Left expression\n\n  var lexpr;\n\n  if (i === expr.length) {\n    throw new MacroError(p, \"unexpected end: \" + p.prim);\n  }\n\n  var c = expr[i++];\n\n  switch (c) {\n    case \"P\":\n      var _a = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),\n          r = _a.r,\n          n = _a.n,\n          an = _a.an;\n\n      lexpr = r;\n      i += n;\n      ai += an;\n      break;\n\n    case \"A\":\n      if (ai !== annotations.length) {\n        ann[0] = annotations[ai++];\n      }\n\n      break;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  } // Right expression\n\n\n  var rexpr;\n\n  if (i === expr.length) {\n    throw new MacroError(p, \"unexpected end: \" + p.prim);\n  }\n\n  c = expr[i++];\n\n  switch (c) {\n    case \"P\":\n      var _b = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg),\n          r = _b.r,\n          n = _b.n,\n          an = _b.an;\n\n      rexpr = r.map(function (_a) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        return [v + 1, a];\n      });\n      i += n;\n      ai += an;\n      break;\n\n    case \"I\":\n      if (ai !== annotations.length) {\n        ann[1] = annotations[ai++];\n      }\n\n      break;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  }\n\n  return {\n    r: agg(lexpr, rexpr, [0, ann]),\n    n: i,\n    an: ai\n  };\n}\n\nfunction parseSetMapCadr(p, expr, vann, term) {\n  var c = expr[0];\n\n  switch (c) {\n    case \"A\":\n      return expr.length > 1 ? [{\n        prim: \"DUP\"\n      }, {\n        prim: \"DIP\",\n        args: [[{\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, parseSetMapCadr(p, expr.slice(1), [], term)]]\n      }, {\n        prim: \"CDR\",\n        annots: [\"@%%\"]\n      }, {\n        prim: \"SWAP\"\n      }, {\n        prim: \"PAIR\",\n        annots: __spread([\"%@\", \"%@\"], vann)\n      }] : term.a;\n\n    case \"D\":\n      return expr.length > 1 ? [{\n        prim: \"DUP\"\n      }, {\n        prim: \"DIP\",\n        args: [[{\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, parseSetMapCadr(p, expr.slice(1), [], term)]]\n      }, {\n        prim: \"CAR\",\n        annots: [\"@%%\"]\n      }, {\n        prim: \"PAIR\",\n        annots: __spread([\"%@\", \"%@\"], vann)\n      }] : term.d;\n\n    default:\n      throw new MacroError(p, p.prim + \": unexpected character: \" + c);\n  }\n}\n\nfunction trimLast(a, v) {\n  var l = a.length;\n\n  while (l > 0 && a[l - 1] === v) {\n    l--;\n  }\n\n  return a.slice(0, l);\n}\n\nfunction filterAnnotations(a) {\n  var e_1, _a;\n\n  var fields = [];\n  var rest = [];\n\n  if (a !== undefined) {\n    try {\n      for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\n        var v = a_1_1.value;\n        (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  return {\n    fields: fields,\n    rest: rest\n  };\n}\n\nfunction mkPrim(_a) {\n  var prim = _a.prim,\n      annots = _a.annots,\n      args = _a.args;\n  return __assign(__assign({\n    prim: prim\n  }, annots && {\n    annots: annots\n  }), args && {\n    args: args\n  });\n}\n\nvar pairRe = /^P[PAI]{3,}R$/;\nvar unpairRe = /^UNP[PAI]{2,}R$/;\nvar cadrRe = /^C[AD]{2,}R$/;\nvar setCadrRe = /^SET_C[AD]+R$/;\nvar mapCadrRe = /^MAP_C[AD]+R$/;\nvar diipRe = /^DI{2,}P$/;\nvar duupRe = /^DU+P$/;\n\nfunction expandMacros(ex) {\n  function mayRename(annots) {\n    return annots !== undefined ? [{\n      prim: \"RENAME\",\n      annots: annots\n    }] : [];\n  }\n\n  switch (ex.prim) {\n    // Compare\n    case \"CMPEQ\":\n    case \"CMPNEQ\":\n    case \"CMPLT\":\n    case \"CMPGT\":\n    case \"CMPLE\":\n    case \"CMPGE\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"COMPARE\"\n        }, mkPrim({\n          prim: ex.prim.slice(3),\n          annots: ex.annots\n        })];\n      }\n\n      break;\n\n    case \"IFEQ\":\n    case \"IFNEQ\":\n    case \"IFLT\":\n    case \"IFGT\":\n    case \"IFLE\":\n    case \"IFGE\":\n      if (assertArgs(ex, 2)) {\n        return [{\n          prim: ex.prim.slice(2)\n        }, mkPrim({\n          prim: \"IF\",\n          annots: ex.annots,\n          args: ex.args\n        })];\n      }\n\n      break;\n\n    case \"IFCMPEQ\":\n    case \"IFCMPNEQ\":\n    case \"IFCMPLT\":\n    case \"IFCMPGT\":\n    case \"IFCMPLE\":\n    case \"IFCMPGE\":\n      if (assertArgs(ex, 2)) {\n        return [{\n          prim: \"COMPARE\"\n        }, {\n          prim: ex.prim.slice(5)\n        }, mkPrim({\n          prim: \"IF\",\n          annots: ex.annots,\n          args: ex.args\n        })];\n      }\n\n      break;\n    // Fail\n\n    case \"FAIL\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"UNIT\"\n        }, {\n          prim: \"FAILWITH\"\n        }];\n      }\n\n      break;\n    // Assertion macros\n\n    case \"ASSERT\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_EQ\":\n    case \"ASSERT_NEQ\":\n    case \"ASSERT_LT\":\n    case \"ASSERT_GT\":\n    case \"ASSERT_LE\":\n    case \"ASSERT_GE\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: ex.prim.slice(7)\n        }, {\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_CMPEQ\":\n    case \"ASSERT_CMPNEQ\":\n    case \"ASSERT_CMPLT\":\n    case \"ASSERT_CMPGT\":\n    case \"ASSERT_CMPLE\":\n    case \"ASSERT_CMPGE\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [[{\n          prim: \"COMPARE\"\n        }, {\n          prim: ex.prim.slice(10)\n        }], {\n          prim: \"IF\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_NONE\":\n      if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\n        return [{\n          prim: \"IF_NONE\",\n          args: [[], [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_SOME\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"IF_NONE\",\n          args: [[[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]], mayRename(ex.annots)]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_LEFT\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"IF_LEFT\",\n          args: [mayRename(ex.annots), [[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]]]\n        }];\n      }\n\n      break;\n\n    case \"ASSERT_RIGHT\":\n      if (assertArgs(ex, 0)) {\n        return [{\n          prim: \"IF_LEFT\",\n          args: [[[{\n            prim: \"UNIT\"\n          }, {\n            prim: \"FAILWITH\"\n          }]], mayRename(ex.annots)]\n        }];\n      }\n\n      break;\n    // Syntactic conveniences\n\n    case \"IF_SOME\":\n      if (assertArgs(ex, 2)) {\n        return [mkPrim({\n          prim: \"IF_NONE\",\n          annots: ex.annots,\n          args: [ex.args[1], ex.args[0]]\n        })];\n      }\n\n      break;\n\n    case \"IF_RIGHT\":\n      if (assertArgs(ex, 2)) {\n        return [mkPrim({\n          prim: \"IF_LEFT\",\n          annots: ex.annots,\n          args: [ex.args[1], ex.args[0]]\n        })];\n      }\n\n  } // More syntactic conveniences\n  // PAPPAIIR macro\n\n\n  if (pairRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var _a = filterAnnotations(ex.annots),\n          fields = _a.fields,\n          rest_1 = _a.rest;\n\n      var r_1 = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, function (l, r, top) {\n        return __spread(l || [], r || [], [top]);\n      }).r;\n      return r_1.map(function (_a, i) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        var ann = __spread(trimLast(a, null).map(function (v) {\n          return v === null ? \"%\" : v;\n        }), v === 0 && i === r_1.length - 1 ? rest_1 : []);\n\n        var leaf = mkPrim({\n          prim: \"PAIR\",\n          annots: ann.length !== 0 ? ann : undefined\n        });\n        return v === 0 ? leaf : {\n          prim: \"DIP\",\n          args: v === 1 ? [[leaf]] : [{\n            int: String(v)\n          }, [leaf]]\n        };\n      });\n    }\n  } // UNPAPPAIIR macro\n\n\n  if (unpairRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var r = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], function (l, r, top) {\n        return __spread([top], r || [], l || []);\n      }).r;\n      return r.map(function (_a) {\n        var _b = __read(_a, 2),\n            v = _b[0],\n            a = _b[1];\n\n        var leaf = [{\n          prim: \"DUP\"\n        }, mkPrim({\n          prim: \"CAR\",\n          annots: a[0] !== null ? [a[0]] : undefined\n        }), {\n          prim: \"DIP\",\n          args: [[mkPrim({\n            prim: \"CDR\",\n            annots: a[1] !== null ? [a[1]] : undefined\n          })]]\n        }];\n        return v === 0 ? leaf : {\n          prim: \"DIP\",\n          args: v === 1 ? [[leaf]] : [{\n            int: String(v)\n          }, [leaf]]\n        };\n      });\n    }\n  } // C[AD]+R macro\n\n\n  if (cadrRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var ch_1 = __spread(ex.prim.slice(1, ex.prim.length - 1));\n\n      return ch_1.map(function (c, i) {\n        var ann = i === ch_1.length - 1 ? ex.annots : undefined;\n\n        switch (c) {\n          case \"A\":\n            return mkPrim({\n              prim: \"CAR\",\n              annots: ann\n            });\n\n          case \"D\":\n            return mkPrim({\n              prim: \"CDR\",\n              annots: ann\n            });\n\n          default:\n            throw new MacroError(ex, \"unexpected character: \" + c);\n        }\n      });\n    }\n  } // SET_C[AD]+R macro\n\n\n  if (setCadrRe.test(ex.prim)) {\n    if (assertArgs(ex, 0)) {\n      var _b = filterAnnotations(ex.annots),\n          fields = _b.fields,\n          rest = _b.rest;\n\n      if (fields.length > 1) {\n        throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\n      }\n\n      var term = fields.length !== 0 ? {\n        a: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CAR\",\n          annots: fields\n        }, {\n          prim: \"DROP\"\n        }, {\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [fields[0], \"%@\"]\n        }],\n        d: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CDR\",\n          annots: fields\n        }, {\n          prim: \"DROP\"\n        }, {\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", fields[0]]\n        }]\n      } : {\n        a: [{\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%\", \"%@\"]\n        }],\n        d: [{\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", \"%\"]\n        }]\n      };\n      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n    }\n  } // MAP_C[AD]+R macro\n\n\n  if (mapCadrRe.test(ex.prim)) {\n    if (assertArgs(ex, 1)) {\n      var fields = filterAnnotations(ex.annots).fields;\n\n      if (fields.length > 1) {\n        throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\n      }\n\n      var term = {\n        a: [{\n          prim: \"DUP\"\n        }, {\n          prim: \"CDR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"DIP\",\n          args: [[mkPrim({\n            prim: \"CAR\",\n            annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined\n          }), ex.args[0]]]\n        }, {\n          prim: \"SWAP\"\n        }, {\n          prim: \"PAIR\",\n          annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"]\n        }],\n        d: [{\n          prim: \"DUP\"\n        }, mkPrim({\n          prim: \"CDR\",\n          annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined\n        }), ex.args[0], {\n          prim: \"SWAP\"\n        }, {\n          prim: \"CAR\",\n          annots: [\"@%%\"]\n        }, {\n          prim: \"PAIR\",\n          annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"]\n        }]\n      };\n      return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n    }\n  } // Expand deprecated DI...IP to [DIP n]\n\n\n  if (diipRe.test(ex.prim)) {\n    if (assertArgs(ex, 1)) {\n      var n = 0;\n\n      while (ex.prim[1 + n] === \"I\") {\n        n++;\n      }\n\n      return mkPrim({\n        prim: \"DIP\",\n        args: [{\n          int: String(n)\n        }, ex.args[0]]\n      });\n    }\n  } // Expand modern DUP n or deprecated DU...UP\n\n\n  if (duupRe.test(ex.prim)) {\n    var n = 0;\n\n    while (ex.prim[1 + n] === \"U\") {\n      n++;\n    }\n\n    if (n === 1) {\n      if (ex.args === undefined) {\n        return ex; // skip\n      }\n\n      if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\n        n = parseInt(ex.args[0].int, 10);\n      }\n    } else {\n      assertArgs(ex, 0);\n    }\n\n    if (n === 1) {\n      return [mkPrim({\n        prim: \"DUP\",\n        annots: ex.annots\n      })];\n    } else if (n === 2) {\n      return [{\n        prim: \"DIP\",\n        args: [[mkPrim({\n          prim: \"DUP\",\n          annots: ex.annots\n        })]]\n      }, {\n        prim: \"SWAP\"\n      }];\n    } else {\n      return [{\n        prim: \"DIP\",\n        args: [{\n          int: String(n - 1)\n        }, [mkPrim({\n          prim: \"DUP\",\n          annots: ex.annots\n        })]]\n      }, {\n        prim: \"DIG\",\n        args: [{\n          int: String(n)\n        }]\n      }];\n    }\n  }\n\n  return ex;\n}\n\nvar MichelineParseError =\n/** @class */\nfunction (_super) {\n  __extends(MichelineParseError, _super);\n  /**\r\n   * @param token A token caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function MichelineParseError(token, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.token = token;\n    return _this;\n  }\n\n  return MichelineParseError;\n}(Error);\n\nvar JSONParseError =\n/** @class */\nfunction (_super) {\n  __extends(JSONParseError, _super);\n  /**\r\n   * @param node A node caused the error\r\n   * @param message An error message\r\n   */\n\n\n  function JSONParseError(node, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.node = node;\n    return _this;\n  }\n\n  return JSONParseError;\n}(Error);\n\nvar errEOF = new MichelineParseError(null, 'Unexpected EOF');\n\nfunction isAnnotation(tok) {\n  return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\n}\n\nvar intRe = new RegExp('^-?[0-9]+$');\nvar bytesRe = new RegExp('^([0-9a-fA-F]{2})+$');\n/**\r\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\r\n *\r\n * Pretty Print a Michelson Smart Contract:\r\n * ```\r\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\r\n * const p = new Parser();\r\n *\r\n * const michelsonCode = p.parseJSON(contract.script.code);\r\n * const storage = p.parseJSON(contract.script.storage);\r\n *\r\n * console.log(\"Pretty print Michelson smart contract:\");\r\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\r\n *\r\n * console.log(\"Pretty print Storage:\");\r\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\r\n * ```\r\n *\r\n * Encode a Michelson expression for inital storage of a smart contract\r\n * ```\r\n * const src = `(Pair (Pair { Elt 1\r\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\r\n *                      0x0501000000026869) }\r\n *          10000000)\r\n *    (Pair 2 333))`;\r\n *\r\n * const p = new Parser();\r\n *\r\n * const exp = p.parseMichelineExpression(src);\r\n * console.log(JSON.stringify(exp));\r\n * ```\r\n */\n\nvar Parser =\n/** @class */\nfunction () {\n  function Parser(opt) {\n    this.opt = opt;\n  }\n\n  Parser.prototype.expand = function (ex) {\n    var _a;\n\n    return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandMacros) ? expandMacros(ex) : ex;\n  };\n\n  Parser.prototype.parseList = function (scanner) {\n    var tok = scanner.next();\n\n    if (tok.done) {\n      throw errEOF;\n    }\n\n    if (tok.value.t !== Literal.Ident) {\n      throw new MichelineParseError(tok.value, \"List: not an identifier: \" + tok.value.v);\n    }\n\n    var ret = {\n      prim: tok.value.v\n    };\n\n    for (;;) {\n      var tok_1 = scanner.next();\n\n      if (tok_1.done) {\n        throw errEOF;\n      }\n\n      if (tok_1.value.t === ')') {\n        break;\n      }\n\n      if (isAnnotation(tok_1.value)) {\n        ret.annots = ret.annots || [];\n        ret.annots.push(tok_1.value.v);\n      } else {\n        ret.args = ret.args || [];\n        ret.args.push(this.parseExpr(scanner, tok_1.value));\n      }\n    }\n\n    return this.expand(ret);\n  };\n\n  Parser.prototype.parseArgs = function (scanner, prim, expectBracket) {\n    // Identifier with arguments\n    var p = {\n      prim: prim\n    };\n\n    for (;;) {\n      var t = scanner.next();\n\n      if (t.done) {\n        if (expectBracket) {\n          throw errEOF;\n        } else {\n          return [p, true];\n        }\n      } else if (t.value.t === '}') {\n        if (!expectBracket) {\n          throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\n        } else {\n          return [p, true];\n        }\n      } else if (t.value.t === ';') {\n        return [p, false];\n      }\n\n      if (isAnnotation(t.value)) {\n        p.annots = p.annots || [];\n        p.annots.push(t.value.v);\n      } else {\n        p.args = p.args || [];\n        p.args.push(this.parseExpr(scanner, t.value));\n      }\n    }\n  };\n\n  Parser.prototype.parseSequence = function (scanner, initialToken, expectBracket) {\n    var seq = [];\n\n    for (;;) {\n      var tok = void 0;\n\n      if (initialToken !== null) {\n        tok = initialToken;\n        initialToken = null;\n      } else {\n        var t = scanner.next();\n\n        if (t.done) {\n          if (expectBracket) {\n            throw errEOF;\n          } else {\n            return seq;\n          }\n        }\n\n        tok = t.value;\n      }\n\n      if (tok.t === '}') {\n        if (!expectBracket) {\n          throw new MichelineParseError(tok, \"Seq: unexpected token: \" + tok.v);\n        } else {\n          return seq;\n        }\n      } else if (tok.t === Literal.Ident) {\n        // Identifier with arguments\n        var _a = __read(this.parseArgs(scanner, tok.v, expectBracket), 2),\n            itm = _a[0],\n            done = _a[1];\n\n        seq.push(this.expand(itm));\n\n        if (done) {\n          return seq;\n        }\n      } else {\n        // Other\n        seq.push(this.parseExpr(scanner, tok));\n        var t = scanner.next();\n\n        if (t.done) {\n          if (expectBracket) {\n            throw errEOF;\n          } else {\n            return seq;\n          }\n        } else if (t.value.t === '}') {\n          if (!expectBracket) {\n            throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\n          } else {\n            return seq;\n          }\n        } else if (t.value.t !== ';') {\n          throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\n        }\n      }\n    }\n  };\n\n  Parser.prototype.parseExpr = function (scanner, tok) {\n    switch (tok.t) {\n      case Literal.Ident:\n        return this.expand({\n          prim: tok.v\n        });\n\n      case Literal.Number:\n        return {\n          int: tok.v\n        };\n\n      case Literal.String:\n        return {\n          string: JSON.parse(tok.v)\n        };\n\n      case Literal.Bytes:\n        return {\n          bytes: tok.v.substr(2)\n        };\n\n      case '(':\n        return this.parseList(scanner);\n\n      case '{':\n        return this.parseSequence(scanner, null, true);\n\n      default:\n        throw new MichelineParseError(tok, \"Expr: unexpected token: \" + tok.v);\n    }\n  };\n  /**\r\n   * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\r\n   * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\r\n   */\n\n\n  Parser.prototype.parseScript = function (src) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof src !== \"string\") {\n      throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\n    }\n\n    var scanner = scan(src);\n    var tok = scanner.next();\n\n    if (tok.done) {\n      return null;\n    }\n\n    return tok.value.t === '{' ? this.parseSequence(scanner, null, true) : this.parseSequence(scanner, tok.value, false);\n  };\n  /**\r\n   * Parse any Michelson expression\r\n   * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\r\n   * @returns An AST node or null for empty document.\r\n   */\n\n\n  Parser.prototype.parseMichelineExpression = function (src) {\n    // tslint:disable-next-line: strict-type-predicates\n    if (typeof src !== \"string\") {\n      throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\n    }\n\n    var scanner = scan(src);\n    var tok = scanner.next();\n\n    if (tok.done) {\n      return null;\n    }\n\n    return this.parseExpr(scanner, tok.value);\n  };\n  /**\r\n   * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\r\n   * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\r\n   */\n\n\n  Parser.prototype.parseJSON = function (src) {\n    var e_1, _a, e_2, _b, e_3, _c; // tslint:disable-next-line: strict-type-predicates\n\n\n    if (typeof src !== \"object\") {\n      throw new TypeError(\"object type was expected, got \" + typeof src + \" instead\");\n    }\n\n    if (Array.isArray(src)) {\n      var ret = [];\n\n      try {\n        for (var src_1 = __values(src), src_1_1 = src_1.next(); !src_1_1.done; src_1_1 = src_1.next()) {\n          var n = src_1_1.value;\n\n          if (n === null || typeof n !== 'object') {\n            throw new JSONParseError(n, \"unexpected sequence element: \" + n);\n          }\n\n          ret.push(this.parseJSON(n));\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (src_1_1 && !src_1_1.done && (_a = src_1.return)) _a.call(src_1);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      return ret;\n    } else if ('prim' in src) {\n      var p = src;\n\n      if (typeof p.prim === 'string' && (p.annots === undefined || Array.isArray(p.annots)) && (p.args === undefined || Array.isArray(p.args))) {\n        var ret = {\n          prim: p.prim\n        };\n\n        if (p.annots !== undefined) {\n          try {\n            for (var _d = __values(p.annots), _e = _d.next(); !_e.done; _e = _d.next()) {\n              var a = _e.value;\n\n              if (typeof a !== 'string') {\n                throw new JSONParseError(a, \"string expected: \" + a);\n              }\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n\n          ret.annots = p.annots;\n        }\n\n        if (p.args !== undefined) {\n          ret.args = [];\n\n          try {\n            for (var _f = __values(p.args), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var a = _g.value;\n\n              if (a === null || typeof a !== 'object') {\n                throw new JSONParseError(a, \"unexpected argument: \" + a);\n              }\n\n              ret.args.push(this.parseJSON(a));\n            }\n          } catch (e_3_1) {\n            e_3 = {\n              error: e_3_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n            } finally {\n              if (e_3) throw e_3.error;\n            }\n          }\n        }\n\n        return this.expand(ret);\n      }\n\n      throw new JSONParseError(src, \"malformed prim expression: \" + src);\n    } else if ('string' in src) {\n      if (typeof src.string === 'string') {\n        return {\n          string: src.string\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed string literal: \" + src);\n    } else if ('int' in src) {\n      if (typeof src.int === 'string' && intRe.test(src.int)) {\n        return {\n          int: src.int\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed int literal: \" + src);\n    } else if ('bytes' in src) {\n      if (typeof src.bytes === 'string' && bytesRe.test(src.bytes)) {\n        return {\n          bytes: src.bytes\n        };\n      }\n\n      throw new JSONParseError(src, \"malformed bytes literal: \" + src);\n    } else {\n      throw new JSONParseError(src, \"unexpected object: \" + src);\n    }\n  };\n\n  return Parser;\n}();\n\nvar Formatter =\n/** @class */\nfunction () {\n  function Formatter(opt, lev) {\n    if (lev === void 0) {\n      lev = 0;\n    }\n\n    this.opt = opt;\n    this.lev = lev;\n  }\n\n  Formatter.prototype.indent = function (n) {\n    var _a;\n\n    if (n === void 0) {\n      n = 0;\n    }\n\n    var ret = \"\";\n\n    if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {\n      for (var i = this.lev + n; i > 0; i--) {\n        ret += this.opt.indent;\n      }\n    }\n\n    return ret;\n  };\n\n  Object.defineProperty(Formatter.prototype, \"lf\", {\n    get: function () {\n      var _a;\n\n      return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \"\";\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(Formatter.prototype, \"lfsp\", {\n    get: function () {\n      var _a;\n\n      return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \" \";\n    },\n    enumerable: false,\n    configurable: true\n  });\n\n  Formatter.prototype.down = function (n) {\n    return new Formatter(this.opt, this.lev + n);\n  };\n\n  return Formatter;\n}();\n\nfunction hasArgs(node) {\n  return \"prim\" in node && (node.annots !== undefined && node.annots.length !== 0 || node.args !== undefined && node.args.length !== 0);\n}\n\nfunction isMultiline(node) {\n  var e_1, _a;\n\n  if (node.args !== undefined) {\n    try {\n      for (var _b = __values(node.args), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var a = _c.value;\n\n        if (Array.isArray(a) || hasArgs(a)) {\n          return true;\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction emitExpr(node, f) {\n  var e_2, _a, e_3, _b;\n\n  if (Array.isArray(node)) {\n    return emitSeq(node, f);\n  } else if (\"string\" in node) {\n    return JSON.stringify(node.string);\n  } else if (\"int\" in node) {\n    return node.int;\n  } else if (\"bytes\" in node) {\n    return \"0x\" + node.bytes;\n  } else {\n    if ((node.annots === undefined || node.annots.length === 0) && (node.args === undefined || node.args.length === 0)) {\n      return node.prim;\n    }\n\n    var ret = \"(\" + node.prim;\n\n    if (node.annots !== undefined) {\n      try {\n        for (var _c = __values(node.annots), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var a = _d.value;\n          ret += \" \" + a;\n        }\n      } catch (e_2_1) {\n        e_2 = {\n          error: e_2_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_2) throw e_2.error;\n        }\n      }\n    }\n\n    if (node.args !== undefined) {\n      var multiline = isMultiline(node);\n\n      try {\n        for (var _e = __values(node.args), _f = _e.next(); !_f.done; _f = _e.next()) {\n          var a = _f.value;\n\n          if (multiline) {\n            ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1));\n          } else {\n            ret += \" \" + emitExpr(a, f);\n          }\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    }\n\n    return ret + \")\";\n  }\n}\n\nfunction emitSeq(node, f) {\n  var e_4, _a, e_5, _b, e_6, _c;\n\n  var ret = \"{\" + f.lf;\n  var i = node.length;\n\n  try {\n    for (var node_1 = __values(node), node_1_1 = node_1.next(); !node_1_1.done; node_1_1 = node_1.next()) {\n      var el = node_1_1.value;\n      ret += f.indent(1);\n\n      if (\"prim\" in el) {\n        ret += el.prim;\n\n        if (el.annots !== undefined) {\n          try {\n            for (var _d = (e_5 = void 0, __values(el.annots)), _e = _d.next(); !_e.done; _e = _d.next()) {\n              var a = _e.value;\n              ret += \" \" + a;\n            }\n          } catch (e_5_1) {\n            e_5 = {\n              error: e_5_1\n            };\n          } finally {\n            try {\n              if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\n            } finally {\n              if (e_5) throw e_5.error;\n            }\n          }\n        }\n\n        if (el.args !== undefined) {\n          var multiline = isMultiline(el);\n\n          try {\n            for (var _f = (e_6 = void 0, __values(el.args)), _g = _f.next(); !_g.done; _g = _f.next()) {\n              var a = _g.value;\n\n              if (multiline) {\n                ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2));\n              } else {\n                ret += \" \" + emitExpr(a, f);\n              }\n            }\n          } catch (e_6_1) {\n            e_6 = {\n              error: e_6_1\n            };\n          } finally {\n            try {\n              if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\n            } finally {\n              if (e_6) throw e_6.error;\n            }\n          }\n        }\n      } else {\n        ret += emitExpr(el, f.down(1));\n      }\n\n      ret += (i > 1 ? \";\" : \"\") + f.lf;\n      i--;\n    }\n  } catch (e_4_1) {\n    e_4 = {\n      error: e_4_1\n    };\n  } finally {\n    try {\n      if (node_1_1 && !node_1_1.done && (_a = node_1.return)) _a.call(node_1);\n    } finally {\n      if (e_4) throw e_4.error;\n    }\n  }\n\n  return ret + f.indent() + \"}\";\n}\n/**\r\n * Formats Micheline expression\r\n * @param expr An AST node\r\n * @param opt Options\r\n */\n\n\nfunction emitMicheline(expr, opt) {\n  // tslint:disable-next-line: strict-type-predicates\n  if (typeof expr !== \"object\") {\n    throw new TypeError(\"object type was expected, got \" + typeof expr + \" instead\");\n  }\n\n  return emitExpr(expr, new Formatter(opt));\n} // Michelson types\n\n\nvar ValidationError =\n/** @class */\nfunction (_super) {\n  __extends(ValidationError, _super);\n  /**\r\n   * @param val Value of a node caused the error\r\n   * @param path Path to a node caused the error in the AST tree\r\n   * @param message An error message\r\n   */\n\n\n  function ValidationError(val, path, message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.val = val;\n    _this.path = path;\n    return _this;\n  }\n\n  return ValidationError;\n}(Error);\n\nfunction isPrim(ex) {\n  return \"prim\" in ex;\n}\n\nfunction assertPrim(ex, path) {\n  if (isPrim(ex)) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, \"prim expression expected\");\n}\n\nfunction assertSeq(ex, path) {\n  if (Array.isArray(ex)) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, \"sequence expression expected\");\n}\n\nfunction assertNatural(i, path) {\n  if (i.int[0] === \"-\") {\n    throw new ValidationError(i, path, \"natural number expected\");\n  }\n}\n\nfunction assertIntLiteral(ex, path) {\n  if (\"int\" in ex) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, \"int literal expected\");\n}\n\nfunction assertArgs$1(ex, n, path) {\n  var _a;\n\n  if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n    return true;\n  }\n\n  throw new ValidationError(ex, path, n + \" arguments expected\");\n}\n\nvar unaryInstructionTable = {\n  \"DUP\": true,\n  \"SWAP\": true,\n  \"SOME\": true,\n  \"UNIT\": true,\n  \"PAIR\": true,\n  \"CAR\": true,\n  \"CDR\": true,\n  \"CONS\": true,\n  \"SIZE\": true,\n  \"MEM\": true,\n  \"GET\": true,\n  \"UPDATE\": true,\n  \"EXEC\": true,\n  \"FAILWITH\": true,\n  \"RENAME\": true,\n  \"CONCAT\": true,\n  \"SLICE\": true,\n  \"PACK\": true,\n  \"ADD\": true,\n  \"SUB\": true,\n  \"MUL\": true,\n  \"EDIV\": true,\n  \"ABS\": true,\n  \"ISNAT\": true,\n  \"INT\": true,\n  \"NEG\": true,\n  \"LSL\": true,\n  \"LSR\": true,\n  \"OR\": true,\n  \"AND\": true,\n  \"XOR\": true,\n  \"NOT\": true,\n  \"COMPARE\": true,\n  \"EQ\": true,\n  \"NEQ\": true,\n  \"LT\": true,\n  \"GT\": true,\n  \"LE\": true,\n  \"GE\": true,\n  \"SELF\": true,\n  \"TRANSFER_TOKENS\": true,\n  \"SET_DELEGATE\": true,\n  \"CREATE_ACCOUNT\": true,\n  \"IMPLICIT_ACCOUNT\": true,\n  \"NOW\": true,\n  \"AMOUNT\": true,\n  \"BALANCE\": true,\n  \"CHECK_SIGNATURE\": true,\n  \"BLAKE2B\": true,\n  \"SHA256\": true,\n  \"SHA512\": true,\n  \"HASH_KEY\": true,\n  \"STEPS_TO_QUOTA\": true,\n  \"SOURCE\": true,\n  \"SENDER\": true,\n  \"ADDRESS\": true,\n  \"CHAIN_ID\": true\n};\nvar instructionTable = Object.assign({}, unaryInstructionTable, {\n  \"DROP\": true,\n  \"DIG\": true,\n  \"DUG\": true,\n  \"NONE\": true,\n  \"LEFT\": true,\n  \"RIGHT\": true,\n  \"NIL\": true,\n  \"UNPACK\": true,\n  \"CONTRACT\": true,\n  \"CAST\": true,\n  \"IF_NONE\": true,\n  \"IF_LEFT\": true,\n  \"IF_CONS\": true,\n  \"IF\": true,\n  \"MAP\": true,\n  \"ITER\": true,\n  \"LOOP\": true,\n  \"LOOP_LEFT\": true,\n  \"DIP\": true,\n  \"CREATE_CONTRACT\": true,\n  \"PUSH\": true,\n  \"EMPTY_SET\": true,\n  \"EMPTY_MAP\": true,\n  \"EMPTY_BIG_MAP\": true,\n  \"LAMBDA\": true\n});\n\nfunction assertMichelsonInstruction(ex, path) {\n  var e_1, _a;\n\n  var _b, _c;\n\n  if (Array.isArray(ex)) {\n    var i = 0;\n\n    try {\n      for (var ex_1 = __values(ex), ex_1_1 = ex_1.next(); !ex_1_1.done; ex_1_1 = ex_1.next()) {\n        var n = ex_1_1.value;\n\n        var p = __spread(path, [{\n          index: i,\n          val: n\n        }]);\n\n        if (!Array.isArray(n) && !isPrim(n)) {\n          throw new ValidationError(ex, p, \"sequence or prim expected\");\n        }\n\n        assertMichelsonInstruction(n, p);\n        i++;\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  } else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {\n    assertArgs$1(ex, 0, path);\n  } else {\n    switch (ex.prim) {\n      case \"DROP\":\n        if (ex.args !== undefined && assertArgs$1(ex, 1, path)) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertIntLiteral(ex.args[0], p)) {\n            assertNatural(ex.args[0], p);\n          }\n        }\n\n        break;\n\n      case \"DIG\":\n      case \"DUG\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertIntLiteral(ex.args[0], p)) {\n            assertNatural(ex.args[0], p);\n          }\n        }\n\n        break;\n\n      case \"NONE\":\n      case \"LEFT\":\n      case \"RIGHT\":\n      case \"NIL\":\n      case \"UNPACK\":\n      case \"CONTRACT\":\n      case \"CAST\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"IF_NONE\":\n      case \"IF_LEFT\":\n      case \"IF_CONS\":\n      case \"IF\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          var p0 = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[0], p0)) {\n            assertMichelsonInstruction(ex.args[0], p0);\n          }\n\n          var p1 = __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[1], p1)) {\n            assertMichelsonInstruction(ex.args[1], p1);\n          }\n        }\n\n        break;\n\n      case \"MAP\":\n      case \"ITER\":\n      case \"LOOP\":\n      case \"LOOP_LEFT\":\n      case \"CREATE_CONTRACT\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[0], p)) {\n            assertMichelsonInstruction(ex.args[0], p);\n          }\n        }\n\n        break;\n\n      case \"DIP\":\n        if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {\n          var p0 = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertIntLiteral(ex.args[0], p0)) {\n            assertNatural(ex.args[0], p0);\n          }\n\n          var p1 = __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[1], p1)) {\n            assertMichelsonInstruction(ex.args[1], p1);\n          }\n        } else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {\n          var p = __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[0], p)) {\n            assertMichelsonInstruction(ex.args[0], p);\n          }\n        } else {\n          throw new ValidationError(ex, path, \"1 or 2 arguments expected\");\n        }\n\n        break;\n\n      case \"PUSH\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonDataInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"EMPTY_SET\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"EMPTY_MAP\":\n      case \"EMPTY_BIG_MAP\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"LAMBDA\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 3, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n\n          var p2 = __spread(path, [{\n            index: 2,\n            val: ex.args[2]\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertSeq(ex.args[2], p2)) {\n            assertMichelsonInstruction(ex.args[2], p2);\n          }\n        }\n\n        break;\n\n      default:\n        throw new ValidationError(ex, path, \"instruction expected\");\n    }\n  }\n\n  return true;\n}\n\nvar simpleComparableTypeTable = {\n  \"int\": true,\n  \"nat\": true,\n  \"string\": true,\n  \"bytes\": true,\n  \"mutez\": true,\n  \"bool\": true,\n  \"key_hash\": true,\n  \"timestamp\": true,\n  \"address\": true\n};\n\nfunction assertMichelsonSimpleComparableType(ex, path) {\n  /* istanbul ignore else */\n  if (assertPrim(ex, path)) {\n    if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n      throw new ValidationError(ex, path, \"simple comparable type expected\");\n    }\n\n    assertArgs$1(ex, 0, path);\n  }\n\n  return true;\n}\n\nfunction assertMichelsonComparableType(ex, path) {\n  /* istanbul ignore else */\n  if (assertPrim(ex, path)) {\n    if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\n      assertArgs$1(ex, 0, path);\n    } else if (ex.prim === \"pair\") {\n      /* istanbul ignore else */\n      if (assertArgs$1(ex, 2, path)) {\n        assertMichelsonSimpleComparableType(ex.args[0], __spread(path, [{\n          index: 0,\n          val: ex.args[0]\n        }]));\n        assertMichelsonComparableType(ex.args[1], __spread(path, [{\n          index: 1,\n          val: ex.args[1]\n        }]));\n      }\n    } else {\n      throw new ValidationError(ex, path, \"comparable type expected\");\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonTypeInternal(ex, path) {\n  /* istanbul ignore else */\n  if (assertPrim(ex, path)) {\n    switch (ex.prim) {\n      case \"key\":\n      case \"unit\":\n      case \"signature\":\n      case \"operation\":\n      case \"chain_id\":\n        assertArgs$1(ex, 0, path);\n        break;\n\n      case \"option\":\n      case \"list\":\n      case \"contract\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"pair\":\n      case \"or\":\n      case \"lambda\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonTypeInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"set\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      case \"map\":\n      case \"big_map\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonComparableType(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonTypeInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      default:\n        assertMichelsonComparableType(ex, path);\n    }\n  }\n\n  return true;\n}\n\nfunction assertMichelsonDataInternal(ex, path) {\n  var e_2, _a;\n\n  if (\"int\" in ex || \"string\" in ex || \"bytes\" in ex) {\n    return true;\n  }\n\n  if (Array.isArray(ex)) {\n    var mapElts = 0;\n    var i = 0;\n\n    try {\n      for (var ex_2 = __values(ex), ex_2_1 = ex_2.next(); !ex_2_1.done; ex_2_1 = ex_2.next()) {\n        var n = ex_2_1.value;\n\n        var p = __spread(path, [{\n          index: i,\n          val: n\n        }]);\n\n        if (isPrim(n) && n.prim === \"Elt\") {\n          /* istanbul ignore else */\n          if (assertArgs$1(n, 2, p)) {\n            assertMichelsonDataInternal(n.args[0], __spread(p, [{\n              index: 0,\n              val: n.args[0]\n            }]));\n            assertMichelsonDataInternal(n.args[1], __spread(p, [{\n              index: 1,\n              val: n.args[1]\n            }]));\n          }\n\n          mapElts++;\n        } else {\n          assertMichelsonDataInternal(n, p);\n        }\n\n        i++;\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    if (mapElts !== 0 && mapElts !== ex.length) {\n      throw new ValidationError(ex, path, \"data entries and map elements can't be intermixed\");\n    }\n\n    return true;\n  }\n\n  if (isPrim(ex)) {\n    switch (ex.prim) {\n      case \"Unit\":\n      case \"True\":\n      case \"False\":\n      case \"None\":\n        assertArgs$1(ex, 0, path);\n        break;\n\n      case \"Pair\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 2, path)) {\n          assertMichelsonDataInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n          assertMichelsonDataInternal(ex.args[1], __spread(path, [{\n            index: 1,\n            val: ex.args[1]\n          }]));\n        }\n\n        break;\n\n      case \"Left\":\n      case \"Right\":\n      case \"Some\":\n        /* istanbul ignore else */\n        if (assertArgs$1(ex, 1, path)) {\n          assertMichelsonDataInternal(ex.args[0], __spread(path, [{\n            index: 0,\n            val: ex.args[0]\n          }]));\n        }\n\n        break;\n\n      default:\n        if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {\n          assertMichelsonInstruction(ex, path);\n        } else {\n          throw new ValidationError(ex, path, \"data entry or instruction expected\");\n        }\n\n    }\n  } else {\n    throw new ValidationError(ex, path, \"data entry expected\");\n  }\n\n  return true;\n}\n\nfunction assertMichelsonScriptInternal(ex, path) {\n  var e_3, _a;\n  /* istanbul ignore else */\n\n\n  if (assertSeq(ex, path) && ex.length === 3 && assertPrim(ex[0], __spread(path, [{\n    index: 0,\n    val: ex[0]\n  }])) && assertPrim(ex[1], __spread(path, [{\n    index: 1,\n    val: ex[1]\n  }])) && assertPrim(ex[2], __spread(path, [{\n    index: 2,\n    val: ex[2]\n  }]))) {\n    var p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();\n\n    if (p[0] === \"code\" && p[1] === \"parameter\" && p[2] === \"storage\") {\n      var i = 0;\n\n      try {\n        for (var _b = __values(ex), _c = _b.next(); !_c.done; _c = _b.next()) {\n          var n = _c.value;\n\n          var p_1 = __spread(path, [{\n            index: i,\n            val: n\n          }]);\n          /* istanbul ignore else */\n\n\n          if (assertArgs$1(n, 1, p_1)) {\n            var pp = __spread(p_1, [{\n              index: 0,\n              val: n.args[0]\n            }]);\n\n            switch (n.prim) {\n              case \"code\":\n                /* istanbul ignore else */\n                if (assertSeq(n.args[0], pp)) {\n                  assertMichelsonInstruction(n.args[0], pp);\n                }\n\n                break;\n\n              case \"parameter\":\n              case \"storage\":\n                assertMichelsonTypeInternal(n.args[0], pp);\n            }\n          }\n\n          i++;\n        }\n      } catch (e_3_1) {\n        e_3 = {\n          error: e_3_1\n        };\n      } finally {\n        try {\n          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n        } finally {\n          if (e_3) throw e_3.error;\n        }\n      }\n    } else {\n      throw new ValidationError(ex, path, \"valid Michelson script expected\");\n    }\n  }\n\n  return true;\n}\n/**\r\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonScript(ex) {\n  return assertMichelsonScriptInternal(ex, []);\n}\n/**\r\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonData(ex) {\n  return assertMichelsonDataInternal(ex, []);\n}\n/**\r\n * Checks if the node is a valid Michelson code (sequence of instructions).\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonCode(ex) {\n  return assertMichelsonInstruction(ex, []);\n}\n/**\r\n * Checks if the node is a valid Michelson type expression.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\n\n\nfunction assertMichelsonType(ex) {\n  return assertMichelsonTypeInternal(ex, []);\n}\n\nexport { JSONParseError, MacroError, MichelineParseError, Parser, ValidationError, assertMichelsonCode, assertMichelsonData, assertMichelsonScript, assertMichelsonType, emitMicheline };","map":{"version":3,"mappings":"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","names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","prototype","hasOwnProperty","call","__extends","__","constructor","create","__assign","assign","t","s","i","n","arguments","length","apply","__generator","thisArg","body","_","label","sent","trys","ops","f","y","g","next","verb","Symbol","iterator","v","step","op","TypeError","done","value","pop","push","e","__values","o","m","__read","r","ar","error","__spread","concat","ScanError","_super","src","idx","message","_this","Error","Literal","isSpace","RegExp","isIdentStart","isIdent","isDigit","isHex","scan","scanComments","start","ii","esc","_a","test","Ident","slice","offset","substr","Bytes","Number","String","Comment","MacroError","prim","assertArgs","ex","_b","args","undefined","assertNoAnnots","annots","assertIntArg","arg","parsePairUnpairExpr","expr","annotations","agg","ai","ann","lexpr","c","an","rexpr","map","a","parseSetMapCadr","vann","term","trimLast","l","filterAnnotations","e_1","fields","rest","a_1","a_1_1","e_1_1","return","mkPrim","pairRe","unpairRe","cadrRe","setCadrRe","mapCadrRe","diipRe","duupRe","expandMacros","mayRename","rest_1","r_1","top","leaf","int","ch_1","parseInt","MichelineParseError","token","JSONParseError","node","errEOF","isAnnotation","tok","intRe","bytesRe","Parser","opt","expand","parseList","scanner","ret","tok_1","parseExpr","parseArgs","expectBracket","parseSequence","initialToken","seq","itm","string","JSON","parse","bytes","parseScript","parseMichelineExpression","parseJSON","e_2","e_3","_c","isArray","src_1","src_1_1","_d","_e","e_2_1","_f","_g","e_3_1","Formatter","lev","indent","defineProperty","get","newline","enumerable","configurable","down","hasArgs","isMultiline","emitExpr","emitSeq","stringify","multiline","lfsp","e_4","e_5","e_6","lf","node_1","node_1_1","el","e_5_1","e_6_1","e_4_1","emitMicheline","ValidationError","val","path","isPrim","assertPrim","assertSeq","assertNatural","assertIntLiteral","assertArgs$1","unaryInstructionTable","instructionTable","assertMichelsonInstruction","ex_1","ex_1_1","index","assertMichelsonTypeInternal","p0","p1","assertMichelsonDataInternal","assertMichelsonComparableType","p2","simpleComparableTypeTable","assertMichelsonSimpleComparableType","mapElts","ex_2","ex_2_1","assertMichelsonScriptInternal","sort","p_1","pp","assertMichelsonScript","assertMichelsonData","assertMichelsonCode","assertMichelsonType"],"sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es5.js"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\n\nvar ScanError = /** @class */ (function (_super) {\r\n    __extends(ScanError, _super);\r\n    function ScanError(src, idx, message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.src = src;\r\n        _this.idx = idx;\r\n        return _this;\r\n    }\r\n    return ScanError;\r\n}(Error));\r\nvar Literal;\r\n(function (Literal) {\r\n    Literal[Literal[\"Comment\"] = 0] = \"Comment\";\r\n    Literal[Literal[\"Number\"] = 1] = \"Number\";\r\n    Literal[Literal[\"String\"] = 2] = \"String\";\r\n    Literal[Literal[\"Bytes\"] = 3] = \"Bytes\";\r\n    Literal[Literal[\"Ident\"] = 4] = \"Ident\";\r\n})(Literal || (Literal = {}));\r\nvar isSpace = new RegExp(\"\\\\s\");\r\nvar isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\r\nvar isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\r\nvar isDigit = new RegExp(\"[0-9]\");\r\nvar isHex = new RegExp(\"[0-9a-fA-F]\");\r\nfunction scan(src, scanComments) {\r\n    var i, s, start, ii, esc;\r\n    if (scanComments === void 0) { scanComments = false; }\r\n    return __generator(this, function (_a) {\r\n        switch (_a.label) {\r\n            case 0:\r\n                i = 0;\r\n                _a.label = 1;\r\n            case 1:\r\n                if (!(i < src.length)) return [3 /*break*/, 16];\r\n                // Skip space\r\n                while (i < src.length && isSpace.test(src[i])) {\r\n                    i++;\r\n                }\r\n                if (i === src.length) {\r\n                    return [2 /*return*/];\r\n                }\r\n                s = src[i];\r\n                start = i;\r\n                if (!isIdentStart.test(s)) return [3 /*break*/, 3];\r\n                // Identifier\r\n                i++;\r\n                while (i < src.length && isIdent.test(src[i])) {\r\n                    i++;\r\n                }\r\n                return [4 /*yield*/, { t: Literal.Ident, v: src.slice(start, i), offset: i }];\r\n            case 2:\r\n                _a.sent();\r\n                return [3 /*break*/, 15];\r\n            case 3:\r\n                if (!(src.length - i > 1 && src.substr(i, 2) === \"0x\")) return [3 /*break*/, 5];\r\n                // Bytes\r\n                i += 2;\r\n                while (i < src.length && isHex.test(src[i])) {\r\n                    i++;\r\n                }\r\n                if (i - start === 2) {\r\n                    throw new ScanError(src, i, \"Bytes literal is too short\");\r\n                }\r\n                else if (((i - start) & 1) !== 0) {\r\n                    throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\r\n                }\r\n                return [4 /*yield*/, { t: Literal.Bytes, v: src.slice(start, i), offset: i }];\r\n            case 4:\r\n                _a.sent();\r\n                return [3 /*break*/, 15];\r\n            case 5:\r\n                if (!(isDigit.test(s) || s === \"-\")) return [3 /*break*/, 7];\r\n                // Number\r\n                if (s === \"-\") {\r\n                    i++;\r\n                }\r\n                ii = i;\r\n                while (i < src.length && isDigit.test(src[i])) {\r\n                    i++;\r\n                }\r\n                if (ii === i) {\r\n                    throw new ScanError(src, i, \"Number literal is too short\");\r\n                }\r\n                return [4 /*yield*/, { t: Literal.Number, v: src.slice(start, i), offset: i }];\r\n            case 6:\r\n                _a.sent();\r\n                return [3 /*break*/, 15];\r\n            case 7:\r\n                if (!(s === \"\\\"\")) return [3 /*break*/, 9];\r\n                // String\r\n                i++;\r\n                esc = false;\r\n                for (; i < src.length && (esc || src[i] !== \"\\\"\"); i++) {\r\n                    if (!esc && src[i] === \"\\\\\") {\r\n                        esc = true;\r\n                    }\r\n                    else {\r\n                        esc = false;\r\n                    }\r\n                }\r\n                if (i === src.length) {\r\n                    throw new ScanError(src, i, \"Unterminated string literal\");\r\n                }\r\n                i++;\r\n                return [4 /*yield*/, { t: Literal.String, v: src.slice(start, i), offset: i }];\r\n            case 8:\r\n                _a.sent();\r\n                return [3 /*break*/, 15];\r\n            case 9:\r\n                if (!(s === \"#\")) return [3 /*break*/, 12];\r\n                // Comment\r\n                i++;\r\n                while (i < src.length && src[i] !== \"\\n\") {\r\n                    i++;\r\n                }\r\n                if (!scanComments) return [3 /*break*/, 11];\r\n                return [4 /*yield*/, { t: Literal.Comment, v: src.slice(start, i), offset: i }];\r\n            case 10:\r\n                _a.sent();\r\n                _a.label = 11;\r\n            case 11: return [3 /*break*/, 15];\r\n            case 12:\r\n                if (!(s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\")) return [3 /*break*/, 14];\r\n                i++;\r\n                return [4 /*yield*/, { t: s, v: s, offset: i }];\r\n            case 13:\r\n                _a.sent();\r\n                return [3 /*break*/, 15];\r\n            case 14: throw new ScanError(src, i, \"Invalid character at offset \" + i + \": `\" + s + \"'\");\r\n            case 15: return [3 /*break*/, 1];\r\n            case 16: return [2 /*return*/];\r\n        }\r\n    });\r\n}\n\nvar MacroError = /** @class */ (function (_super) {\r\n    __extends(MacroError, _super);\r\n    function MacroError(prim, message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.prim = prim;\r\n        Object.setPrototypeOf(_this, MacroError.prototype);\r\n        return _this;\r\n    }\r\n    return MacroError;\r\n}(Error));\r\nfunction assertArgs(ex, n) {\r\n    var _a, _b;\r\n    if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\r\n        return true;\r\n    }\r\n    throw new MacroError(ex, \"macro \" + ex.prim + \" expects \" + n + \" arguments, was given \" + ((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length));\r\n}\r\nfunction assertNoAnnots(ex) {\r\n    if (ex.annots === undefined) {\r\n        return true;\r\n    }\r\n    throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + ex.annots);\r\n}\r\nfunction assertIntArg(ex, arg) {\r\n    if (\"int\" in arg) {\r\n        return true;\r\n    }\r\n    throw new MacroError(ex, \"macro \" + ex.prim + \" expects int argument\");\r\n}\r\nfunction parsePairUnpairExpr(p, expr, annotations, agg) {\r\n    var i = 0;\r\n    var ai = 0;\r\n    var ann = [null, null];\r\n    // Left expression\r\n    var lexpr;\r\n    if (i === expr.length) {\r\n        throw new MacroError(p, \"unexpected end: \" + p.prim);\r\n    }\r\n    var c = expr[i++];\r\n    switch (c) {\r\n        case \"P\":\r\n            var _a = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg), r = _a.r, n = _a.n, an = _a.an;\r\n            lexpr = r;\r\n            i += n;\r\n            ai += an;\r\n            break;\r\n        case \"A\":\r\n            if (ai !== annotations.length) {\r\n                ann[0] = annotations[ai++];\r\n            }\r\n            break;\r\n        default:\r\n            throw new MacroError(p, p.prim + \": unexpected character: \" + c);\r\n    }\r\n    // Right expression\r\n    var rexpr;\r\n    if (i === expr.length) {\r\n        throw new MacroError(p, \"unexpected end: \" + p.prim);\r\n    }\r\n    c = expr[i++];\r\n    switch (c) {\r\n        case \"P\":\r\n            var _b = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg), r = _b.r, n = _b.n, an = _b.an;\r\n            rexpr = r.map(function (_a) {\r\n                var _b = __read(_a, 2), v = _b[0], a = _b[1];\r\n                return [v + 1, a];\r\n            });\r\n            i += n;\r\n            ai += an;\r\n            break;\r\n        case \"I\":\r\n            if (ai !== annotations.length) {\r\n                ann[1] = annotations[ai++];\r\n            }\r\n            break;\r\n        default:\r\n            throw new MacroError(p, p.prim + \": unexpected character: \" + c);\r\n    }\r\n    return { r: agg(lexpr, rexpr, [0, ann]), n: i, an: ai };\r\n}\r\nfunction parseSetMapCadr(p, expr, vann, term) {\r\n    var c = expr[0];\r\n    switch (c) {\r\n        case \"A\":\r\n            return expr.length > 1 ?\r\n                [\r\n                    { prim: \"DUP\" },\r\n                    {\r\n                        prim: \"DIP\",\r\n                        args: [[\r\n                                { prim: \"CAR\", annots: [\"@%%\"] },\r\n                                parseSetMapCadr(p, expr.slice(1), [], term),\r\n                            ]],\r\n                    },\r\n                    { prim: \"CDR\", annots: [\"@%%\"] },\r\n                    { prim: \"SWAP\" },\r\n                    { prim: \"PAIR\", annots: __spread([\"%@\", \"%@\"], vann) },\r\n                ] : term.a;\r\n        case \"D\":\r\n            return expr.length > 1 ?\r\n                [\r\n                    { prim: \"DUP\" },\r\n                    {\r\n                        prim: \"DIP\",\r\n                        args: [[\r\n                                { prim: \"CDR\", annots: [\"@%%\"] },\r\n                                parseSetMapCadr(p, expr.slice(1), [], term),\r\n                            ]],\r\n                    },\r\n                    { prim: \"CAR\", annots: [\"@%%\"] },\r\n                    { prim: \"PAIR\", annots: __spread([\"%@\", \"%@\"], vann) },\r\n                ] : term.d;\r\n        default:\r\n            throw new MacroError(p, p.prim + \": unexpected character: \" + c);\r\n    }\r\n}\r\nfunction trimLast(a, v) {\r\n    var l = a.length;\r\n    while (l > 0 && a[l - 1] === v) {\r\n        l--;\r\n    }\r\n    return a.slice(0, l);\r\n}\r\nfunction filterAnnotations(a) {\r\n    var e_1, _a;\r\n    var fields = [];\r\n    var rest = [];\r\n    if (a !== undefined) {\r\n        try {\r\n            for (var a_1 = __values(a), a_1_1 = a_1.next(); !a_1_1.done; a_1_1 = a_1.next()) {\r\n                var v = a_1_1.value;\r\n                (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (a_1_1 && !a_1_1.done && (_a = a_1.return)) _a.call(a_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    }\r\n    return { fields: fields, rest: rest };\r\n}\r\nfunction mkPrim(_a) {\r\n    var prim = _a.prim, annots = _a.annots, args = _a.args;\r\n    return __assign(__assign({ prim: prim }, (annots && { annots: annots })), (args && { args: args }));\r\n}\r\nvar pairRe = /^P[PAI]{3,}R$/;\r\nvar unpairRe = /^UNP[PAI]{2,}R$/;\r\nvar cadrRe = /^C[AD]{2,}R$/;\r\nvar setCadrRe = /^SET_C[AD]+R$/;\r\nvar mapCadrRe = /^MAP_C[AD]+R$/;\r\nvar diipRe = /^DI{2,}P$/;\r\nvar duupRe = /^DU+P$/;\r\nfunction expandMacros(ex) {\r\n    function mayRename(annots) {\r\n        return annots !== undefined ? [{ prim: \"RENAME\", annots: annots }] : [];\r\n    }\r\n    switch (ex.prim) {\r\n        // Compare\r\n        case \"CMPEQ\":\r\n        case \"CMPNEQ\":\r\n        case \"CMPLT\":\r\n        case \"CMPGT\":\r\n        case \"CMPLE\":\r\n        case \"CMPGE\":\r\n            if (assertArgs(ex, 0)) {\r\n                return [\r\n                    { prim: \"COMPARE\" },\r\n                    mkPrim({ prim: ex.prim.slice(3), annots: ex.annots }),\r\n                ];\r\n            }\r\n            break;\r\n        case \"IFEQ\":\r\n        case \"IFNEQ\":\r\n        case \"IFLT\":\r\n        case \"IFGT\":\r\n        case \"IFLE\":\r\n        case \"IFGE\":\r\n            if (assertArgs(ex, 2)) {\r\n                return [\r\n                    { prim: ex.prim.slice(2) },\r\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\r\n                ];\r\n            }\r\n            break;\r\n        case \"IFCMPEQ\":\r\n        case \"IFCMPNEQ\":\r\n        case \"IFCMPLT\":\r\n        case \"IFCMPGT\":\r\n        case \"IFCMPLE\":\r\n        case \"IFCMPGE\":\r\n            if (assertArgs(ex, 2)) {\r\n                return [\r\n                    { prim: \"COMPARE\" },\r\n                    { prim: ex.prim.slice(5) },\r\n                    mkPrim({ prim: \"IF\", annots: ex.annots, args: ex.args }),\r\n                ];\r\n            }\r\n            break;\r\n        // Fail\r\n        case \"FAIL\":\r\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\r\n                return [\r\n                    { prim: \"UNIT\" },\r\n                    { prim: \"FAILWITH\" },\r\n                ];\r\n            }\r\n            break;\r\n        // Assertion macros\r\n        case \"ASSERT\":\r\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\r\n                return [{\r\n                        prim: \"IF\", args: [\r\n                            [],\r\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\r\n                        ]\r\n                    }];\r\n            }\r\n            break;\r\n        case \"ASSERT_EQ\":\r\n        case \"ASSERT_NEQ\":\r\n        case \"ASSERT_LT\":\r\n        case \"ASSERT_GT\":\r\n        case \"ASSERT_LE\":\r\n        case \"ASSERT_GE\":\r\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\r\n                return [\r\n                    { prim: ex.prim.slice(7) },\r\n                    {\r\n                        prim: \"IF\", args: [\r\n                            [],\r\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\r\n                        ]\r\n                    },\r\n                ];\r\n            }\r\n            break;\r\n        case \"ASSERT_CMPEQ\":\r\n        case \"ASSERT_CMPNEQ\":\r\n        case \"ASSERT_CMPLT\":\r\n        case \"ASSERT_CMPGT\":\r\n        case \"ASSERT_CMPLE\":\r\n        case \"ASSERT_CMPGE\":\r\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\r\n                return [\r\n                    [\r\n                        { prim: \"COMPARE\" },\r\n                        { prim: ex.prim.slice(10) },\r\n                    ],\r\n                    {\r\n                        prim: \"IF\", args: [\r\n                            [],\r\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\r\n                        ]\r\n                    },\r\n                ];\r\n            }\r\n            break;\r\n        case \"ASSERT_NONE\":\r\n            if (assertArgs(ex, 0) && assertNoAnnots(ex)) {\r\n                return [{\r\n                        prim: \"IF_NONE\", args: [\r\n                            [],\r\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\r\n                        ]\r\n                    }];\r\n            }\r\n            break;\r\n        case \"ASSERT_SOME\":\r\n            if (assertArgs(ex, 0)) {\r\n                return [{\r\n                        prim: \"IF_NONE\", args: [\r\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\r\n                            mayRename(ex.annots),\r\n                        ]\r\n                    }];\r\n            }\r\n            break;\r\n        case \"ASSERT_LEFT\":\r\n            if (assertArgs(ex, 0)) {\r\n                return [{\r\n                        prim: \"IF_LEFT\", args: [\r\n                            mayRename(ex.annots),\r\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\r\n                        ]\r\n                    }];\r\n            }\r\n            break;\r\n        case \"ASSERT_RIGHT\":\r\n            if (assertArgs(ex, 0)) {\r\n                return [{\r\n                        prim: \"IF_LEFT\", args: [\r\n                            [[{ prim: \"UNIT\" }, { prim: \"FAILWITH\" }]],\r\n                            mayRename(ex.annots),\r\n                        ]\r\n                    }];\r\n            }\r\n            break;\r\n        // Syntactic conveniences\r\n        case \"IF_SOME\":\r\n            if (assertArgs(ex, 2)) {\r\n                return [mkPrim({ prim: \"IF_NONE\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\r\n            }\r\n            break;\r\n        case \"IF_RIGHT\":\r\n            if (assertArgs(ex, 2)) {\r\n                return [mkPrim({ prim: \"IF_LEFT\", annots: ex.annots, args: [ex.args[1], ex.args[0]] })];\r\n            }\r\n    }\r\n    // More syntactic conveniences\r\n    // PAPPAIIR macro\r\n    if (pairRe.test(ex.prim)) {\r\n        if (assertArgs(ex, 0)) {\r\n            var _a = filterAnnotations(ex.annots), fields = _a.fields, rest_1 = _a.rest;\r\n            var r_1 = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, function (l, r, top) { return __spread((l || []), (r || []), [top]); }).r;\r\n            return r_1.map(function (_a, i) {\r\n                var _b = __read(_a, 2), v = _b[0], a = _b[1];\r\n                var ann = __spread(trimLast(a, null).map(function (v) { return v === null ? \"%\" : v; }), ((v === 0 && i === r_1.length - 1) ? rest_1 : []));\r\n                var leaf = mkPrim({ prim: \"PAIR\", annots: ann.length !== 0 ? ann : undefined, });\r\n                return v === 0 ? leaf : {\r\n                    prim: \"DIP\",\r\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\r\n                };\r\n            });\r\n        }\r\n    }\r\n    // UNPAPPAIIR macro\r\n    if (unpairRe.test(ex.prim)) {\r\n        if (assertArgs(ex, 0)) {\r\n            var r = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], function (l, r, top) { return __spread([top], (r || []), (l || [])); }).r;\r\n            return r.map(function (_a) {\r\n                var _b = __read(_a, 2), v = _b[0], a = _b[1];\r\n                var leaf = [\r\n                    { prim: \"DUP\" },\r\n                    mkPrim({ prim: \"CAR\", annots: a[0] !== null ? [a[0]] : undefined }),\r\n                    {\r\n                        prim: \"DIP\",\r\n                        args: [[mkPrim({ prim: \"CDR\", annots: a[1] !== null ? [a[1]] : undefined })]],\r\n                    }\r\n                ];\r\n                return v === 0 ? leaf : {\r\n                    prim: \"DIP\",\r\n                    args: v === 1 ? [[leaf]] : [{ int: String(v) }, [leaf]],\r\n                };\r\n            });\r\n        }\r\n    }\r\n    // C[AD]+R macro\r\n    if (cadrRe.test(ex.prim)) {\r\n        if (assertArgs(ex, 0)) {\r\n            var ch_1 = __spread(ex.prim.slice(1, ex.prim.length - 1));\r\n            return ch_1.map(function (c, i) {\r\n                var ann = i === ch_1.length - 1 ? ex.annots : undefined;\r\n                switch (c) {\r\n                    case \"A\":\r\n                        return mkPrim({ prim: \"CAR\", annots: ann });\r\n                    case \"D\":\r\n                        return mkPrim({ prim: \"CDR\", annots: ann });\r\n                    default:\r\n                        throw new MacroError(ex, \"unexpected character: \" + c);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    // SET_C[AD]+R macro\r\n    if (setCadrRe.test(ex.prim)) {\r\n        if (assertArgs(ex, 0)) {\r\n            var _b = filterAnnotations(ex.annots), fields = _b.fields, rest = _b.rest;\r\n            if (fields.length > 1) {\r\n                throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\r\n            }\r\n            var term = fields.length !== 0 ?\r\n                {\r\n                    a: [\r\n                        { prim: \"DUP\" },\r\n                        { prim: \"CAR\", annots: fields },\r\n                        { prim: \"DROP\" },\r\n                        { prim: \"CDR\", annots: [\"@%%\"] },\r\n                        { prim: \"SWAP\" },\r\n                        { prim: \"PAIR\", annots: [fields[0], \"%@\"] },\r\n                    ],\r\n                    d: [\r\n                        { prim: \"DUP\" },\r\n                        { prim: \"CDR\", annots: fields },\r\n                        { prim: \"DROP\" },\r\n                        { prim: \"CAR\", annots: [\"@%%\"] },\r\n                        { prim: \"PAIR\", annots: [\"%@\", fields[0]] },\r\n                    ],\r\n                } :\r\n                {\r\n                    a: [\r\n                        { prim: \"CDR\", annots: [\"@%%\"] },\r\n                        { prim: \"SWAP\" },\r\n                        { prim: \"PAIR\", annots: [\"%\", \"%@\"] },\r\n                    ],\r\n                    d: [\r\n                        { prim: \"CAR\", annots: [\"@%%\"] },\r\n                        { prim: \"PAIR\", annots: [\"%@\", \"%\"] },\r\n                    ],\r\n                };\r\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\r\n        }\r\n    }\r\n    // MAP_C[AD]+R macro\r\n    if (mapCadrRe.test(ex.prim)) {\r\n        if (assertArgs(ex, 1)) {\r\n            var fields = filterAnnotations(ex.annots).fields;\r\n            if (fields.length > 1) {\r\n                throw new MacroError(ex, \"unexpected annotation on macro \" + ex.prim + \": \" + fields);\r\n            }\r\n            var term = {\r\n                a: [\r\n                    { prim: \"DUP\" },\r\n                    { prim: \"CDR\", annots: [\"@%%\"] },\r\n                    {\r\n                        prim: \"DIP\", args: [[\r\n                                mkPrim({ prim: \"CAR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\r\n                                ex.args[0],\r\n                            ]]\r\n                    },\r\n                    { prim: \"SWAP\" },\r\n                    { prim: \"PAIR\", annots: [fields.length !== 0 ? fields[0] : \"%\", \"%@\"] },\r\n                ],\r\n                d: [\r\n                    { prim: \"DUP\" },\r\n                    mkPrim({ prim: \"CDR\", annots: fields.length !== 0 ? [\"@\" + fields[0].slice(1)] : undefined }),\r\n                    ex.args[0],\r\n                    { prim: \"SWAP\" },\r\n                    { prim: \"CAR\", annots: [\"@%%\"] },\r\n                    { prim: \"PAIR\", annots: [\"%@\", fields.length !== 0 ? fields[0] : \"%\"] },\r\n                ],\r\n            };\r\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\r\n        }\r\n    }\r\n    // Expand deprecated DI...IP to [DIP n]\r\n    if (diipRe.test(ex.prim)) {\r\n        if (assertArgs(ex, 1)) {\r\n            var n = 0;\r\n            while (ex.prim[1 + n] === \"I\") {\r\n                n++;\r\n            }\r\n            return mkPrim({ prim: \"DIP\", args: [{ int: String(n) }, ex.args[0]] });\r\n        }\r\n    }\r\n    // Expand modern DUP n or deprecated DU...UP\r\n    if (duupRe.test(ex.prim)) {\r\n        var n = 0;\r\n        while (ex.prim[1 + n] === \"U\") {\r\n            n++;\r\n        }\r\n        if (n === 1) {\r\n            if (ex.args === undefined) {\r\n                return ex; // skip\r\n            }\r\n            if (assertArgs(ex, 1) && assertIntArg(ex, ex.args[0])) {\r\n                n = parseInt(ex.args[0].int, 10);\r\n            }\r\n        }\r\n        else {\r\n            assertArgs(ex, 0);\r\n        }\r\n        if (n === 1) {\r\n            return [mkPrim({ prim: \"DUP\", annots: ex.annots })];\r\n        }\r\n        else if (n === 2) {\r\n            return [\r\n                {\r\n                    prim: \"DIP\",\r\n                    args: [[mkPrim({ prim: \"DUP\", annots: ex.annots })]],\r\n                },\r\n                { prim: \"SWAP\" },\r\n            ];\r\n        }\r\n        else {\r\n            return [\r\n                {\r\n                    prim: \"DIP\",\r\n                    args: [\r\n                        { int: String(n - 1) },\r\n                        [mkPrim({ prim: \"DUP\", annots: ex.annots })],\r\n                    ],\r\n                },\r\n                {\r\n                    prim: \"DIG\",\r\n                    args: [{ int: String(n) }],\r\n                },\r\n            ];\r\n        }\r\n    }\r\n    return ex;\r\n}\n\nvar MichelineParseError = /** @class */ (function (_super) {\r\n    __extends(MichelineParseError, _super);\r\n    /**\r\n     * @param token A token caused the error\r\n     * @param message An error message\r\n     */\r\n    function MichelineParseError(token, message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.token = token;\r\n        return _this;\r\n    }\r\n    return MichelineParseError;\r\n}(Error));\r\nvar JSONParseError = /** @class */ (function (_super) {\r\n    __extends(JSONParseError, _super);\r\n    /**\r\n     * @param node A node caused the error\r\n     * @param message An error message\r\n     */\r\n    function JSONParseError(node, message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.node = node;\r\n        return _this;\r\n    }\r\n    return JSONParseError;\r\n}(Error));\r\nvar errEOF = new MichelineParseError(null, 'Unexpected EOF');\r\nfunction isAnnotation(tok) {\r\n    return tok.t === Literal.Ident && (tok.v[0] === '@' || tok.v[0] === '%' || tok.v[0] === ':');\r\n}\r\nvar intRe = new RegExp('^-?[0-9]+$');\r\nvar bytesRe = new RegExp('^([0-9a-fA-F]{2})+$');\r\n/**\r\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\r\n *\r\n * Pretty Print a Michelson Smart Contract:\r\n * ```\r\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\r\n * const p = new Parser();\r\n *\r\n * const michelsonCode = p.parseJSON(contract.script.code);\r\n * const storage = p.parseJSON(contract.script.storage);\r\n *\r\n * console.log(\"Pretty print Michelson smart contract:\");\r\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\r\n *\r\n * console.log(\"Pretty print Storage:\");\r\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\r\n * ```\r\n *\r\n * Encode a Michelson expression for inital storage of a smart contract\r\n * ```\r\n * const src = `(Pair (Pair { Elt 1\r\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\r\n *                      0x0501000000026869) }\r\n *          10000000)\r\n *    (Pair 2 333))`;\r\n *\r\n * const p = new Parser();\r\n *\r\n * const exp = p.parseMichelineExpression(src);\r\n * console.log(JSON.stringify(exp));\r\n * ```\r\n */\r\nvar Parser = /** @class */ (function () {\r\n    function Parser(opt) {\r\n        this.opt = opt;\r\n    }\r\n    Parser.prototype.expand = function (ex) {\r\n        var _a;\r\n        return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandMacros) ? expandMacros(ex) : ex;\r\n    };\r\n    Parser.prototype.parseList = function (scanner) {\r\n        var tok = scanner.next();\r\n        if (tok.done) {\r\n            throw errEOF;\r\n        }\r\n        if (tok.value.t !== Literal.Ident) {\r\n            throw new MichelineParseError(tok.value, \"List: not an identifier: \" + tok.value.v);\r\n        }\r\n        var ret = {\r\n            prim: tok.value.v,\r\n        };\r\n        for (;;) {\r\n            var tok_1 = scanner.next();\r\n            if (tok_1.done) {\r\n                throw errEOF;\r\n            }\r\n            if (tok_1.value.t === ')') {\r\n                break;\r\n            }\r\n            if (isAnnotation(tok_1.value)) {\r\n                ret.annots = ret.annots || [];\r\n                ret.annots.push(tok_1.value.v);\r\n            }\r\n            else {\r\n                ret.args = ret.args || [];\r\n                ret.args.push(this.parseExpr(scanner, tok_1.value));\r\n            }\r\n        }\r\n        return this.expand(ret);\r\n    };\r\n    Parser.prototype.parseArgs = function (scanner, prim, expectBracket) {\r\n        // Identifier with arguments\r\n        var p = { prim: prim };\r\n        for (;;) {\r\n            var t = scanner.next();\r\n            if (t.done) {\r\n                if (expectBracket) {\r\n                    throw errEOF;\r\n                }\r\n                else {\r\n                    return [p, true];\r\n                }\r\n            }\r\n            else if (t.value.t === '}') {\r\n                if (!expectBracket) {\r\n                    throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\r\n                }\r\n                else {\r\n                    return [p, true];\r\n                }\r\n            }\r\n            else if (t.value.t === ';') {\r\n                return [p, false];\r\n            }\r\n            if (isAnnotation(t.value)) {\r\n                p.annots = p.annots || [];\r\n                p.annots.push(t.value.v);\r\n            }\r\n            else {\r\n                p.args = p.args || [];\r\n                p.args.push(this.parseExpr(scanner, t.value));\r\n            }\r\n        }\r\n    };\r\n    Parser.prototype.parseSequence = function (scanner, initialToken, expectBracket) {\r\n        var seq = [];\r\n        for (;;) {\r\n            var tok = void 0;\r\n            if (initialToken !== null) {\r\n                tok = initialToken;\r\n                initialToken = null;\r\n            }\r\n            else {\r\n                var t = scanner.next();\r\n                if (t.done) {\r\n                    if (expectBracket) {\r\n                        throw errEOF;\r\n                    }\r\n                    else {\r\n                        return seq;\r\n                    }\r\n                }\r\n                tok = t.value;\r\n            }\r\n            if (tok.t === '}') {\r\n                if (!expectBracket) {\r\n                    throw new MichelineParseError(tok, \"Seq: unexpected token: \" + tok.v);\r\n                }\r\n                else {\r\n                    return seq;\r\n                }\r\n            }\r\n            else if (tok.t === Literal.Ident) {\r\n                // Identifier with arguments\r\n                var _a = __read(this.parseArgs(scanner, tok.v, expectBracket), 2), itm = _a[0], done = _a[1];\r\n                seq.push(this.expand(itm));\r\n                if (done) {\r\n                    return seq;\r\n                }\r\n            }\r\n            else {\r\n                // Other\r\n                seq.push(this.parseExpr(scanner, tok));\r\n                var t = scanner.next();\r\n                if (t.done) {\r\n                    if (expectBracket) {\r\n                        throw errEOF;\r\n                    }\r\n                    else {\r\n                        return seq;\r\n                    }\r\n                }\r\n                else if (t.value.t === '}') {\r\n                    if (!expectBracket) {\r\n                        throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\r\n                    }\r\n                    else {\r\n                        return seq;\r\n                    }\r\n                }\r\n                else if (t.value.t !== ';') {\r\n                    throw new MichelineParseError(t.value, \"Seq: unexpected token: \" + t.value.v);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Parser.prototype.parseExpr = function (scanner, tok) {\r\n        switch (tok.t) {\r\n            case Literal.Ident:\r\n                return this.expand({ prim: tok.v });\r\n            case Literal.Number:\r\n                return { int: tok.v };\r\n            case Literal.String:\r\n                return { string: JSON.parse(tok.v) };\r\n            case Literal.Bytes:\r\n                return { bytes: tok.v.substr(2) };\r\n            case '(':\r\n                return this.parseList(scanner);\r\n            case '{':\r\n                return this.parseSequence(scanner, null, true);\r\n            default:\r\n                throw new MichelineParseError(tok, \"Expr: unexpected token: \" + tok.v);\r\n        }\r\n    };\r\n    /**\r\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\r\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\r\n     */\r\n    Parser.prototype.parseScript = function (src) {\r\n        // tslint:disable-next-line: strict-type-predicates\r\n        if (typeof src !== \"string\") {\r\n            throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\r\n        }\r\n        var scanner = scan(src);\r\n        var tok = scanner.next();\r\n        if (tok.done) {\r\n            return null;\r\n        }\r\n        return tok.value.t === '{'\r\n            ? this.parseSequence(scanner, null, true)\r\n            : this.parseSequence(scanner, tok.value, false);\r\n    };\r\n    /**\r\n     * Parse any Michelson expression\r\n     * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\r\n     * @returns An AST node or null for empty document.\r\n     */\r\n    Parser.prototype.parseMichelineExpression = function (src) {\r\n        // tslint:disable-next-line: strict-type-predicates\r\n        if (typeof src !== \"string\") {\r\n            throw new TypeError(\"string type was expected, got \" + typeof src + \" instead\");\r\n        }\r\n        var scanner = scan(src);\r\n        var tok = scanner.next();\r\n        if (tok.done) {\r\n            return null;\r\n        }\r\n        return this.parseExpr(scanner, tok.value);\r\n    };\r\n    /**\r\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\r\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\r\n     */\r\n    Parser.prototype.parseJSON = function (src) {\r\n        var e_1, _a, e_2, _b, e_3, _c;\r\n        // tslint:disable-next-line: strict-type-predicates\r\n        if (typeof src !== \"object\") {\r\n            throw new TypeError(\"object type was expected, got \" + typeof src + \" instead\");\r\n        }\r\n        if (Array.isArray(src)) {\r\n            var ret = [];\r\n            try {\r\n                for (var src_1 = __values(src), src_1_1 = src_1.next(); !src_1_1.done; src_1_1 = src_1.next()) {\r\n                    var n = src_1_1.value;\r\n                    if (n === null || typeof n !== 'object') {\r\n                        throw new JSONParseError(n, \"unexpected sequence element: \" + n);\r\n                    }\r\n                    ret.push(this.parseJSON(n));\r\n                }\r\n            }\r\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n            finally {\r\n                try {\r\n                    if (src_1_1 && !src_1_1.done && (_a = src_1.return)) _a.call(src_1);\r\n                }\r\n                finally { if (e_1) throw e_1.error; }\r\n            }\r\n            return ret;\r\n        }\r\n        else if ('prim' in src) {\r\n            var p = src;\r\n            if (typeof p.prim === 'string' &&\r\n                (p.annots === undefined || Array.isArray(p.annots)) &&\r\n                (p.args === undefined || Array.isArray(p.args))) {\r\n                var ret = {\r\n                    prim: p.prim,\r\n                };\r\n                if (p.annots !== undefined) {\r\n                    try {\r\n                        for (var _d = __values(p.annots), _e = _d.next(); !_e.done; _e = _d.next()) {\r\n                            var a = _e.value;\r\n                            if (typeof a !== 'string') {\r\n                                throw new JSONParseError(a, \"string expected: \" + a);\r\n                            }\r\n                        }\r\n                    }\r\n                    catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\r\n                        }\r\n                        finally { if (e_2) throw e_2.error; }\r\n                    }\r\n                    ret.annots = p.annots;\r\n                }\r\n                if (p.args !== undefined) {\r\n                    ret.args = [];\r\n                    try {\r\n                        for (var _f = __values(p.args), _g = _f.next(); !_g.done; _g = _f.next()) {\r\n                            var a = _g.value;\r\n                            if (a === null || typeof a !== 'object') {\r\n                                throw new JSONParseError(a, \"unexpected argument: \" + a);\r\n                            }\r\n                            ret.args.push(this.parseJSON(a));\r\n                        }\r\n                    }\r\n                    catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\r\n                        }\r\n                        finally { if (e_3) throw e_3.error; }\r\n                    }\r\n                }\r\n                return this.expand(ret);\r\n            }\r\n            throw new JSONParseError(src, \"malformed prim expression: \" + src);\r\n        }\r\n        else if ('string' in src) {\r\n            if (typeof src.string === 'string') {\r\n                return { string: src.string };\r\n            }\r\n            throw new JSONParseError(src, \"malformed string literal: \" + src);\r\n        }\r\n        else if ('int' in src) {\r\n            if (typeof src.int === 'string' && intRe.test(src.int)) {\r\n                return { int: src.int };\r\n            }\r\n            throw new JSONParseError(src, \"malformed int literal: \" + src);\r\n        }\r\n        else if ('bytes' in src) {\r\n            if (typeof src.bytes === 'string' &&\r\n                bytesRe.test(src.bytes)) {\r\n                return { bytes: src.bytes };\r\n            }\r\n            throw new JSONParseError(src, \"malformed bytes literal: \" + src);\r\n        }\r\n        else {\r\n            throw new JSONParseError(src, \"unexpected object: \" + src);\r\n        }\r\n    };\r\n    return Parser;\r\n}());\n\nvar Formatter = /** @class */ (function () {\r\n    function Formatter(opt, lev) {\r\n        if (lev === void 0) { lev = 0; }\r\n        this.opt = opt;\r\n        this.lev = lev;\r\n    }\r\n    Formatter.prototype.indent = function (n) {\r\n        var _a;\r\n        if (n === void 0) { n = 0; }\r\n        var ret = \"\";\r\n        if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {\r\n            for (var i = this.lev + n; i > 0; i--) {\r\n                ret += this.opt.indent;\r\n            }\r\n        }\r\n        return ret;\r\n    };\r\n    Object.defineProperty(Formatter.prototype, \"lf\", {\r\n        get: function () {\r\n            var _a;\r\n            return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \"\";\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(Formatter.prototype, \"lfsp\", {\r\n        get: function () {\r\n            var _a;\r\n            return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \" \";\r\n        },\r\n        enumerable: false,\r\n        configurable: true\r\n    });\r\n    Formatter.prototype.down = function (n) {\r\n        return new Formatter(this.opt, this.lev + n);\r\n    };\r\n    return Formatter;\r\n}());\r\nfunction hasArgs(node) {\r\n    return (\"prim\" in node) &&\r\n        ((node.annots !== undefined && node.annots.length !== 0) ||\r\n            (node.args !== undefined && node.args.length !== 0));\r\n}\r\nfunction isMultiline(node) {\r\n    var e_1, _a;\r\n    if (node.args !== undefined) {\r\n        try {\r\n            for (var _b = __values(node.args), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var a = _c.value;\r\n                if (Array.isArray(a) || hasArgs(a)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction emitExpr(node, f) {\r\n    var e_2, _a, e_3, _b;\r\n    if (Array.isArray(node)) {\r\n        return emitSeq(node, f);\r\n    }\r\n    else if (\"string\" in node) {\r\n        return JSON.stringify(node.string);\r\n    }\r\n    else if (\"int\" in node) {\r\n        return node.int;\r\n    }\r\n    else if (\"bytes\" in node) {\r\n        return \"0x\" + node.bytes;\r\n    }\r\n    else {\r\n        if ((node.annots === undefined || node.annots.length === 0) &&\r\n            (node.args === undefined || node.args.length === 0)) {\r\n            return node.prim;\r\n        }\r\n        var ret = \"(\" + node.prim;\r\n        if (node.annots !== undefined) {\r\n            try {\r\n                for (var _c = __values(node.annots), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                    var a = _d.value;\r\n                    ret += \" \" + a;\r\n                }\r\n            }\r\n            catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n                }\r\n                finally { if (e_2) throw e_2.error; }\r\n            }\r\n        }\r\n        if (node.args !== undefined) {\r\n            var multiline = isMultiline(node);\r\n            try {\r\n                for (var _e = __values(node.args), _f = _e.next(); !_f.done; _f = _e.next()) {\r\n                    var a = _f.value;\r\n                    if (multiline) {\r\n                        ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1));\r\n                    }\r\n                    else {\r\n                        ret += \" \" + emitExpr(a, f);\r\n                    }\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        }\r\n        return ret + \")\";\r\n    }\r\n}\r\nfunction emitSeq(node, f) {\r\n    var e_4, _a, e_5, _b, e_6, _c;\r\n    var ret = \"{\" + f.lf;\r\n    var i = node.length;\r\n    try {\r\n        for (var node_1 = __values(node), node_1_1 = node_1.next(); !node_1_1.done; node_1_1 = node_1.next()) {\r\n            var el = node_1_1.value;\r\n            ret += f.indent(1);\r\n            if (\"prim\" in el) {\r\n                ret += el.prim;\r\n                if (el.annots !== undefined) {\r\n                    try {\r\n                        for (var _d = (e_5 = void 0, __values(el.annots)), _e = _d.next(); !_e.done; _e = _d.next()) {\r\n                            var a = _e.value;\r\n                            ret += \" \" + a;\r\n                        }\r\n                    }\r\n                    catch (e_5_1) { e_5 = { error: e_5_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_e && !_e.done && (_b = _d.return)) _b.call(_d);\r\n                        }\r\n                        finally { if (e_5) throw e_5.error; }\r\n                    }\r\n                }\r\n                if (el.args !== undefined) {\r\n                    var multiline = isMultiline(el);\r\n                    try {\r\n                        for (var _f = (e_6 = void 0, __values(el.args)), _g = _f.next(); !_g.done; _g = _f.next()) {\r\n                            var a = _g.value;\r\n                            if (multiline) {\r\n                                ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2));\r\n                            }\r\n                            else {\r\n                                ret += \" \" + emitExpr(a, f);\r\n                            }\r\n                        }\r\n                    }\r\n                    catch (e_6_1) { e_6 = { error: e_6_1 }; }\r\n                    finally {\r\n                        try {\r\n                            if (_g && !_g.done && (_c = _f.return)) _c.call(_f);\r\n                        }\r\n                        finally { if (e_6) throw e_6.error; }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                ret += emitExpr(el, f.down(1));\r\n            }\r\n            ret += (i > 1 ? \";\" : \"\") + f.lf;\r\n            i--;\r\n        }\r\n    }\r\n    catch (e_4_1) { e_4 = { error: e_4_1 }; }\r\n    finally {\r\n        try {\r\n            if (node_1_1 && !node_1_1.done && (_a = node_1.return)) _a.call(node_1);\r\n        }\r\n        finally { if (e_4) throw e_4.error; }\r\n    }\r\n    return ret + f.indent() + \"}\";\r\n}\r\n/**\r\n * Formats Micheline expression\r\n * @param expr An AST node\r\n * @param opt Options\r\n */\r\nfunction emitMicheline(expr, opt) {\r\n    // tslint:disable-next-line: strict-type-predicates\r\n    if (typeof expr !== \"object\") {\r\n        throw new TypeError(\"object type was expected, got \" + typeof expr + \" instead\");\r\n    }\r\n    return emitExpr(expr, new Formatter(opt));\r\n}\n\n// Michelson types\r\nvar ValidationError = /** @class */ (function (_super) {\r\n    __extends(ValidationError, _super);\r\n    /**\r\n     * @param val Value of a node caused the error\r\n     * @param path Path to a node caused the error in the AST tree\r\n     * @param message An error message\r\n     */\r\n    function ValidationError(val, path, message) {\r\n        var _this = _super.call(this, message) || this;\r\n        _this.val = val;\r\n        _this.path = path;\r\n        return _this;\r\n    }\r\n    return ValidationError;\r\n}(Error));\r\nfunction isPrim(ex) {\r\n    return \"prim\" in ex;\r\n}\r\nfunction assertPrim(ex, path) {\r\n    if (isPrim(ex)) {\r\n        return true;\r\n    }\r\n    throw new ValidationError(ex, path, \"prim expression expected\");\r\n}\r\nfunction assertSeq(ex, path) {\r\n    if (Array.isArray(ex)) {\r\n        return true;\r\n    }\r\n    throw new ValidationError(ex, path, \"sequence expression expected\");\r\n}\r\nfunction assertNatural(i, path) {\r\n    if (i.int[0] === \"-\") {\r\n        throw new ValidationError(i, path, \"natural number expected\");\r\n    }\r\n}\r\nfunction assertIntLiteral(ex, path) {\r\n    if (\"int\" in ex) {\r\n        return true;\r\n    }\r\n    throw new ValidationError(ex, path, \"int literal expected\");\r\n}\r\nfunction assertArgs$1(ex, n, path) {\r\n    var _a;\r\n    if ((n === 0 && ex.args === undefined) || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\r\n        return true;\r\n    }\r\n    throw new ValidationError(ex, path, n + \" arguments expected\");\r\n}\r\nvar unaryInstructionTable = {\r\n    \"DUP\": true, \"SWAP\": true, \"SOME\": true, \"UNIT\": true, \"PAIR\": true, \"CAR\": true, \"CDR\": true,\r\n    \"CONS\": true, \"SIZE\": true, \"MEM\": true, \"GET\": true, \"UPDATE\": true, \"EXEC\": true, \"FAILWITH\": true, \"RENAME\": true, \"CONCAT\": true, \"SLICE\": true,\r\n    \"PACK\": true, \"ADD\": true, \"SUB\": true, \"MUL\": true, \"EDIV\": true, \"ABS\": true, \"ISNAT\": true, \"INT\": true, \"NEG\": true, \"LSL\": true, \"LSR\": true, \"OR\": true,\r\n    \"AND\": true, \"XOR\": true, \"NOT\": true, \"COMPARE\": true, \"EQ\": true, \"NEQ\": true, \"LT\": true, \"GT\": true, \"LE\": true, \"GE\": true, \"SELF\": true,\r\n    \"TRANSFER_TOKENS\": true, \"SET_DELEGATE\": true, \"CREATE_ACCOUNT\": true, \"IMPLICIT_ACCOUNT\": true, \"NOW\": true, \"AMOUNT\": true,\r\n    \"BALANCE\": true, \"CHECK_SIGNATURE\": true, \"BLAKE2B\": true, \"SHA256\": true, \"SHA512\": true, \"HASH_KEY\": true, \"STEPS_TO_QUOTA\": true,\r\n    \"SOURCE\": true, \"SENDER\": true, \"ADDRESS\": true, \"CHAIN_ID\": true,\r\n};\r\nvar instructionTable = Object.assign({}, unaryInstructionTable, {\r\n    \"DROP\": true, \"DIG\": true, \"DUG\": true, \"NONE\": true, \"LEFT\": true, \"RIGHT\": true, \"NIL\": true, \"UNPACK\": true, \"CONTRACT\": true, \"CAST\": true,\r\n    \"IF_NONE\": true, \"IF_LEFT\": true, \"IF_CONS\": true, \"IF\": true, \"MAP\": true, \"ITER\": true, \"LOOP\": true, \"LOOP_LEFT\": true, \"DIP\": true,\r\n    \"CREATE_CONTRACT\": true, \"PUSH\": true, \"EMPTY_SET\": true, \"EMPTY_MAP\": true, \"EMPTY_BIG_MAP\": true, \"LAMBDA\": true,\r\n});\r\nfunction assertMichelsonInstruction(ex, path) {\r\n    var e_1, _a;\r\n    var _b, _c;\r\n    if (Array.isArray(ex)) {\r\n        var i = 0;\r\n        try {\r\n            for (var ex_1 = __values(ex), ex_1_1 = ex_1.next(); !ex_1_1.done; ex_1_1 = ex_1.next()) {\r\n                var n = ex_1_1.value;\r\n                var p = __spread(path, [{ index: i, val: n }]);\r\n                if (!Array.isArray(n) && !isPrim(n)) {\r\n                    throw new ValidationError(ex, p, \"sequence or prim expected\");\r\n                }\r\n                assertMichelsonInstruction(n, p);\r\n                i++;\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (ex_1_1 && !ex_1_1.done && (_a = ex_1.return)) _a.call(ex_1);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    }\r\n    else if (Object.prototype.hasOwnProperty.call(unaryInstructionTable, ex.prim)) {\r\n        assertArgs$1(ex, 0, path);\r\n    }\r\n    else {\r\n        switch (ex.prim) {\r\n            case \"DROP\":\r\n                if (ex.args !== undefined && assertArgs$1(ex, 1, path)) {\r\n                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertIntLiteral(ex.args[0], p)) {\r\n                        assertNatural(ex.args[0], p);\r\n                    }\r\n                }\r\n                break;\r\n            case \"DIG\":\r\n            case \"DUG\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 1, path)) {\r\n                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertIntLiteral(ex.args[0], p)) {\r\n                        assertNatural(ex.args[0], p);\r\n                    }\r\n                }\r\n                break;\r\n            case \"NONE\":\r\n            case \"LEFT\":\r\n            case \"RIGHT\":\r\n            case \"NIL\":\r\n            case \"UNPACK\":\r\n            case \"CONTRACT\":\r\n            case \"CAST\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 1, path)) {\r\n                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                }\r\n                break;\r\n            case \"IF_NONE\":\r\n            case \"IF_LEFT\":\r\n            case \"IF_CONS\":\r\n            case \"IF\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 2, path)) {\r\n                    var p0 = __spread(path, [{ index: 0, val: ex.args[0] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertSeq(ex.args[0], p0)) {\r\n                        assertMichelsonInstruction(ex.args[0], p0);\r\n                    }\r\n                    var p1 = __spread(path, [{ index: 1, val: ex.args[1] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertSeq(ex.args[1], p1)) {\r\n                        assertMichelsonInstruction(ex.args[1], p1);\r\n                    }\r\n                }\r\n                break;\r\n            case \"MAP\":\r\n            case \"ITER\":\r\n            case \"LOOP\":\r\n            case \"LOOP_LEFT\":\r\n            case \"CREATE_CONTRACT\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 1, path)) {\r\n                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertSeq(ex.args[0], p)) {\r\n                        assertMichelsonInstruction(ex.args[0], p);\r\n                    }\r\n                }\r\n                break;\r\n            case \"DIP\":\r\n                if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 2) {\r\n                    var p0 = __spread(path, [{ index: 0, val: ex.args[0] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertIntLiteral(ex.args[0], p0)) {\r\n                        assertNatural(ex.args[0], p0);\r\n                    }\r\n                    var p1 = __spread(path, [{ index: 1, val: ex.args[1] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertSeq(ex.args[1], p1)) {\r\n                        assertMichelsonInstruction(ex.args[1], p1);\r\n                    }\r\n                }\r\n                else if (((_c = ex.args) === null || _c === void 0 ? void 0 : _c.length) === 1) {\r\n                    var p = __spread(path, [{ index: 0, val: ex.args[0] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertSeq(ex.args[0], p)) {\r\n                        assertMichelsonInstruction(ex.args[0], p);\r\n                    }\r\n                }\r\n                else {\r\n                    throw new ValidationError(ex, path, \"1 or 2 arguments expected\");\r\n                }\r\n                break;\r\n            case \"PUSH\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 2, path)) {\r\n                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                    assertMichelsonDataInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));\r\n                }\r\n                break;\r\n            case \"EMPTY_SET\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 1, path)) {\r\n                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                }\r\n                break;\r\n            case \"EMPTY_MAP\":\r\n            case \"EMPTY_BIG_MAP\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 2, path)) {\r\n                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));\r\n                }\r\n                break;\r\n            case \"LAMBDA\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 3, path)) {\r\n                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));\r\n                    var p2 = __spread(path, [{ index: 2, val: ex.args[2] }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertSeq(ex.args[2], p2)) {\r\n                        assertMichelsonInstruction(ex.args[2], p2);\r\n                    }\r\n                }\r\n                break;\r\n            default:\r\n                throw new ValidationError(ex, path, \"instruction expected\");\r\n        }\r\n    }\r\n    return true;\r\n}\r\nvar simpleComparableTypeTable = {\r\n    \"int\": true, \"nat\": true, \"string\": true, \"bytes\": true, \"mutez\": true,\r\n    \"bool\": true, \"key_hash\": true, \"timestamp\": true, \"address\": true,\r\n};\r\nfunction assertMichelsonSimpleComparableType(ex, path) {\r\n    /* istanbul ignore else */\r\n    if (assertPrim(ex, path)) {\r\n        if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\r\n            throw new ValidationError(ex, path, \"simple comparable type expected\");\r\n        }\r\n        assertArgs$1(ex, 0, path);\r\n    }\r\n    return true;\r\n}\r\nfunction assertMichelsonComparableType(ex, path) {\r\n    /* istanbul ignore else */\r\n    if (assertPrim(ex, path)) {\r\n        if (Object.prototype.hasOwnProperty.call(simpleComparableTypeTable, ex.prim)) {\r\n            assertArgs$1(ex, 0, path);\r\n        }\r\n        else if (ex.prim === \"pair\") {\r\n            /* istanbul ignore else */\r\n            if (assertArgs$1(ex, 2, path)) {\r\n                assertMichelsonSimpleComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                assertMichelsonComparableType(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));\r\n            }\r\n        }\r\n        else {\r\n            throw new ValidationError(ex, path, \"comparable type expected\");\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction assertMichelsonTypeInternal(ex, path) {\r\n    /* istanbul ignore else */\r\n    if (assertPrim(ex, path)) {\r\n        switch (ex.prim) {\r\n            case \"key\":\r\n            case \"unit\":\r\n            case \"signature\":\r\n            case \"operation\":\r\n            case \"chain_id\":\r\n                assertArgs$1(ex, 0, path);\r\n                break;\r\n            case \"option\":\r\n            case \"list\":\r\n            case \"contract\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 1, path)) {\r\n                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                }\r\n                break;\r\n            case \"pair\":\r\n            case \"or\":\r\n            case \"lambda\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 2, path)) {\r\n                    assertMichelsonTypeInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));\r\n                }\r\n                break;\r\n            case \"set\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 1, path)) {\r\n                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                }\r\n                break;\r\n            case \"map\":\r\n            case \"big_map\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 2, path)) {\r\n                    assertMichelsonComparableType(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                    assertMichelsonTypeInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));\r\n                }\r\n                break;\r\n            default:\r\n                assertMichelsonComparableType(ex, path);\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction assertMichelsonDataInternal(ex, path) {\r\n    var e_2, _a;\r\n    if ((\"int\" in ex) || (\"string\" in ex) || (\"bytes\" in ex)) {\r\n        return true;\r\n    }\r\n    if (Array.isArray(ex)) {\r\n        var mapElts = 0;\r\n        var i = 0;\r\n        try {\r\n            for (var ex_2 = __values(ex), ex_2_1 = ex_2.next(); !ex_2_1.done; ex_2_1 = ex_2.next()) {\r\n                var n = ex_2_1.value;\r\n                var p = __spread(path, [{ index: i, val: n }]);\r\n                if (isPrim(n) && n.prim === \"Elt\") {\r\n                    /* istanbul ignore else */\r\n                    if (assertArgs$1(n, 2, p)) {\r\n                        assertMichelsonDataInternal(n.args[0], __spread(p, [{ index: 0, val: n.args[0] }]));\r\n                        assertMichelsonDataInternal(n.args[1], __spread(p, [{ index: 1, val: n.args[1] }]));\r\n                    }\r\n                    mapElts++;\r\n                }\r\n                else {\r\n                    assertMichelsonDataInternal(n, p);\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (ex_2_1 && !ex_2_1.done && (_a = ex_2.return)) _a.call(ex_2);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        if (mapElts !== 0 && mapElts !== ex.length) {\r\n            throw new ValidationError(ex, path, \"data entries and map elements can't be intermixed\");\r\n        }\r\n        return true;\r\n    }\r\n    if (isPrim(ex)) {\r\n        switch (ex.prim) {\r\n            case \"Unit\":\r\n            case \"True\":\r\n            case \"False\":\r\n            case \"None\":\r\n                assertArgs$1(ex, 0, path);\r\n                break;\r\n            case \"Pair\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 2, path)) {\r\n                    assertMichelsonDataInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                    assertMichelsonDataInternal(ex.args[1], __spread(path, [{ index: 1, val: ex.args[1] }]));\r\n                }\r\n                break;\r\n            case \"Left\":\r\n            case \"Right\":\r\n            case \"Some\":\r\n                /* istanbul ignore else */\r\n                if (assertArgs$1(ex, 1, path)) {\r\n                    assertMichelsonDataInternal(ex.args[0], __spread(path, [{ index: 0, val: ex.args[0] }]));\r\n                }\r\n                break;\r\n            default:\r\n                if (Object.prototype.hasOwnProperty.call(instructionTable, ex.prim)) {\r\n                    assertMichelsonInstruction(ex, path);\r\n                }\r\n                else {\r\n                    throw new ValidationError(ex, path, \"data entry or instruction expected\");\r\n                }\r\n        }\r\n    }\r\n    else {\r\n        throw new ValidationError(ex, path, \"data entry expected\");\r\n    }\r\n    return true;\r\n}\r\nfunction assertMichelsonScriptInternal(ex, path) {\r\n    var e_3, _a;\r\n    /* istanbul ignore else */\r\n    if (assertSeq(ex, path) && ex.length === 3 &&\r\n        assertPrim(ex[0], __spread(path, [{ index: 0, val: ex[0] }])) &&\r\n        assertPrim(ex[1], __spread(path, [{ index: 1, val: ex[1] }])) &&\r\n        assertPrim(ex[2], __spread(path, [{ index: 2, val: ex[2] }]))) {\r\n        var p = [ex[0].prim, ex[1].prim, ex[2].prim].sort();\r\n        if (p[0] === \"code\" && p[1] === \"parameter\" && p[2] === \"storage\") {\r\n            var i = 0;\r\n            try {\r\n                for (var _b = __values(ex), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                    var n = _c.value;\r\n                    var p_1 = __spread(path, [{ index: i, val: n }]);\r\n                    /* istanbul ignore else */\r\n                    if (assertArgs$1(n, 1, p_1)) {\r\n                        var pp = __spread(p_1, [{ index: 0, val: n.args[0] }]);\r\n                        switch (n.prim) {\r\n                            case \"code\":\r\n                                /* istanbul ignore else */\r\n                                if (assertSeq(n.args[0], pp)) {\r\n                                    assertMichelsonInstruction(n.args[0], pp);\r\n                                }\r\n                                break;\r\n                            case \"parameter\":\r\n                            case \"storage\":\r\n                                assertMichelsonTypeInternal(n.args[0], pp);\r\n                        }\r\n                    }\r\n                    i++;\r\n                }\r\n            }\r\n            catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n            finally {\r\n                try {\r\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n                }\r\n                finally { if (e_3) throw e_3.error; }\r\n            }\r\n        }\r\n        else {\r\n            throw new ValidationError(ex, path, \"valid Michelson script expected\");\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nfunction assertMichelsonScript(ex) {\r\n    return assertMichelsonScriptInternal(ex, []);\r\n}\r\n/**\r\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nfunction assertMichelsonData(ex) {\r\n    return assertMichelsonDataInternal(ex, []);\r\n}\r\n/**\r\n * Checks if the node is a valid Michelson code (sequence of instructions).\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nfunction assertMichelsonCode(ex) {\r\n    return assertMichelsonInstruction(ex, []);\r\n}\r\n/**\r\n * Checks if the node is a valid Michelson type expression.\r\n * This is a type guard function which either returns true of throws an exception.\r\n * @param ex An AST node\r\n */\r\nfunction assertMichelsonType(ex) {\r\n    return assertMichelsonTypeInternal(ex, []);\r\n}\n\nexport { JSONParseError, MacroError, MichelineParseError, Parser, ValidationError, assertMichelsonCode, assertMichelsonData, assertMichelsonScript, assertMichelsonType, emitMicheline };\n//# sourceMappingURL=taquito-michel-codec.es5.js.map\n"]},"metadata":{},"sourceType":"module"}