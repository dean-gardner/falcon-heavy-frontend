{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise, ExposedPromiseStatus } from '../../utils/exposed-promise';\nimport { Serializer, PostMessageTransport, P2PTransport, TransportType, TransportStatus } from '../..';\nimport { BeaconEventHandler, BeaconEvent } from '../../events';\nimport { isChromeExtensionInstalled } from '../../utils/is-extension-installed';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nexport class Client extends BeaconClient {\n  constructor(config) {\n    super({\n      name: config.name,\n      storage: config.storage\n    });\n    this.requestCounter = [];\n    this.rateLimit = 2;\n    this.rateLimitWindowInSeconds = 5;\n    this._transport = new ExposedPromise();\n    this._isConnected = new ExposedPromise();\n    this.events = new BeaconEventHandler(config.eventHandlers);\n    this.accountManager = new AccountManager(config.storage);\n\n    this.handleResponse = (message, connectionInfo) => {\n      throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n    };\n  }\n\n  get transport() {\n    return this._transport.promise;\n  }\n\n  get isConnected() {\n    return this._isConnected.promise;\n  }\n\n  get ready() {\n    return this.transport.then(() => undefined);\n  }\n\n  getAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccounts();\n    });\n  }\n\n  getAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.getAccount(accountIdentifier);\n    });\n  }\n\n  removeAccount(accountIdentifier) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAccount(accountIdentifier);\n    });\n  }\n\n  removeAllAccounts() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.accountManager.removeAllAccounts();\n    });\n  }\n\n  addRequestAndCheckIfRateLimited() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = new Date().getTime();\n      this.requestCounter = this.requestCounter.filter(date => date + this.rateLimitWindowInSeconds * 1000 > now);\n      this.requestCounter.push(now);\n      return this.requestCounter.length > this.rateLimit;\n    });\n  }\n\n  init() {\n    let isDapp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    let transport = arguments.length > 1 ? arguments[1] : undefined;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n        return (yield this.transport).type;\n      }\n\n      if (transport) {\n        yield this.setTransport(transport); // Let users define their own transport\n\n        return transport.type;\n      } else {\n        return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n          const keyPair = yield this.keyPair; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues\n\n          const setTransport = newTransport => __awaiter(this, void 0, void 0, function* () {\n            yield this.setTransport(newTransport);\n            resolve(newTransport.type);\n          });\n\n          const setBeaconTransport = () => __awaiter(this, void 0, void 0, function* () {\n            const newTransport = new P2PTransport(this.name, keyPair, this.storage, this.events, isDapp);\n            return setTransport(newTransport);\n          });\n\n          const setBeaconTransportTimeout = setTimeout(setBeaconTransport, 200);\n          return isChromeExtensionInstalled.then(postMessageAvailable => __awaiter(this, void 0, void 0, function* () {\n            if (postMessageAvailable) {\n              if (setBeaconTransportTimeout) {\n                clearTimeout(setBeaconTransportTimeout);\n              }\n\n              return setTransport(new PostMessageTransport(this.name));\n            }\n          }));\n        }));\n      }\n    });\n  }\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if ((yield this.transport).type === TransportType.P2P) {\n        return (yield this.transport).getPeers();\n      } else {\n        return [];\n      }\n    });\n  }\n\n  addPeer(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if ((yield this.transport).type === TransportType.P2P) {\n        return (yield this.transport).addPeer(id);\n      }\n    });\n  }\n\n  _connect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const transport = yield this.transport;\n\n      if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {\n        yield transport.connect();\n        transport.addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n          if (typeof message === 'string') {\n            const deserializedMessage = yield new Serializer().deserialize(message);\n            this.handleResponse(deserializedMessage, connectionInfo);\n          }\n        })).catch(error => console.log(error));\n\n        this._isConnected.resolve(true);\n      } else if (transport.connectionStatus === TransportStatus.CONNECTING) {\n        yield transport.reconnect();\n      } else {// NO-OP\n      }\n\n      return this._isConnected.promise;\n    });\n  }\n\n  setTransport(transport) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._transport.isSettled()) {\n        // If the promise has already been resolved we need to create a new one.\n        this._transport = ExposedPromise.resolve(transport);\n      } else {\n        this._transport.resolve(transport);\n      }\n\n      yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","ExposedPromise","ExposedPromiseStatus","Serializer","PostMessageTransport","P2PTransport","TransportType","TransportStatus","BeaconEventHandler","BeaconEvent","isChromeExtensionInstalled","BeaconClient","AccountManager","Client","constructor","config","name","storage","requestCounter","rateLimit","rateLimitWindowInSeconds","_transport","_isConnected","events","eventHandlers","accountManager","handleResponse","message","connectionInfo","Error","JSON","stringify","transport","promise","isConnected","ready","undefined","getAccounts","getAccount","accountIdentifier","removeAccount","removeAllAccounts","addRequestAndCheckIfRateLimited","now","Date","getTime","filter","date","push","length","init","isDapp","status","RESOLVED","type","setTransport","keyPair","newTransport","setBeaconTransport","setBeaconTransportTimeout","setTimeout","postMessageAvailable","clearTimeout","getPeers","P2P","addPeer","id","_connect","connectionStatus","NOT_CONNECTED","connect","addListener","deserializedMessage","deserialize","catch","error","console","log","CONNECTING","reconnect","isSettled","emit","ACTIVE_TRANSPORT_SET"],"sourceRoot":"","sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@airgap/beacon-sdk/dist/esm/clients/client/Client.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise, ExposedPromiseStatus } from '../../utils/exposed-promise';\nimport { Serializer, PostMessageTransport, P2PTransport, TransportType, TransportStatus } from '../..';\nimport { BeaconEventHandler, BeaconEvent } from '../../events';\nimport { isChromeExtensionInstalled } from '../../utils/is-extension-installed';\nimport { BeaconClient } from '../beacon-client/BeaconClient';\nimport { AccountManager } from '../../managers/AccountManager';\nexport class Client extends BeaconClient {\n    constructor(config) {\n        super({ name: config.name, storage: config.storage });\n        this.requestCounter = [];\n        this.rateLimit = 2;\n        this.rateLimitWindowInSeconds = 5;\n        this._transport = new ExposedPromise();\n        this._isConnected = new ExposedPromise();\n        this.events = new BeaconEventHandler(config.eventHandlers);\n        this.accountManager = new AccountManager(config.storage);\n        this.handleResponse = (message, connectionInfo) => {\n            throw new Error(`not overwritten${JSON.stringify(message)} - ${JSON.stringify(connectionInfo)}`);\n        };\n    }\n    get transport() {\n        return this._transport.promise;\n    }\n    get isConnected() {\n        return this._isConnected.promise;\n    }\n    get ready() {\n        return this.transport.then(() => undefined);\n    }\n    getAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccounts();\n        });\n    }\n    getAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.getAccount(accountIdentifier);\n        });\n    }\n    removeAccount(accountIdentifier) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAccount(accountIdentifier);\n        });\n    }\n    removeAllAccounts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.accountManager.removeAllAccounts();\n        });\n    }\n    addRequestAndCheckIfRateLimited() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const now = new Date().getTime();\n            this.requestCounter = this.requestCounter.filter((date) => date + this.rateLimitWindowInSeconds * 1000 > now);\n            this.requestCounter.push(now);\n            return this.requestCounter.length > this.rateLimit;\n        });\n    }\n    init(isDapp = true, transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.status === ExposedPromiseStatus.RESOLVED) {\n                return (yield this.transport).type;\n            }\n            if (transport) {\n                yield this.setTransport(transport); // Let users define their own transport\n                return transport.type;\n            }\n            else {\n                return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                    const keyPair = yield this.keyPair; // We wait for keypair here so the P2P Transport creation is not delayed and causing issues\n                    const setTransport = (newTransport) => __awaiter(this, void 0, void 0, function* () {\n                        yield this.setTransport(newTransport);\n                        resolve(newTransport.type);\n                    });\n                    const setBeaconTransport = () => __awaiter(this, void 0, void 0, function* () {\n                        const newTransport = new P2PTransport(this.name, keyPair, this.storage, this.events, isDapp);\n                        return setTransport(newTransport);\n                    });\n                    const setBeaconTransportTimeout = setTimeout(setBeaconTransport, 200);\n                    return isChromeExtensionInstalled.then((postMessageAvailable) => __awaiter(this, void 0, void 0, function* () {\n                        if (postMessageAvailable) {\n                            if (setBeaconTransportTimeout) {\n                                clearTimeout(setBeaconTransportTimeout);\n                            }\n                            return setTransport(new PostMessageTransport(this.name));\n                        }\n                    }));\n                }));\n            }\n        });\n    }\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((yield this.transport).type === TransportType.P2P) {\n                return (yield this.transport).getPeers();\n            }\n            else {\n                return [];\n            }\n        });\n    }\n    addPeer(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((yield this.transport).type === TransportType.P2P) {\n                return (yield this.transport).addPeer(id);\n            }\n        });\n    }\n    _connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const transport = yield this.transport;\n            if (transport.connectionStatus === TransportStatus.NOT_CONNECTED) {\n                yield transport.connect();\n                transport\n                    .addListener((message, connectionInfo) => __awaiter(this, void 0, void 0, function* () {\n                    if (typeof message === 'string') {\n                        const deserializedMessage = (yield new Serializer().deserialize(message));\n                        this.handleResponse(deserializedMessage, connectionInfo);\n                    }\n                }))\n                    .catch((error) => console.log(error));\n                this._isConnected.resolve(true);\n            }\n            else if (transport.connectionStatus === TransportStatus.CONNECTING) {\n                yield transport.reconnect();\n            }\n            else {\n                // NO-OP\n            }\n            return this._isConnected.promise;\n        });\n    }\n    setTransport(transport) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._transport.isSettled()) {\n                // If the promise has already been resolved we need to create a new one.\n                this._transport = ExposedPromise.resolve(transport);\n            }\n            else {\n                this._transport.resolve(transport);\n            }\n            yield this.events.emit(BeaconEvent.ACTIVE_TRANSPORT_SET, transport);\n        });\n    }\n}\n//# sourceMappingURL=Client.js.map"]},"metadata":{},"sourceType":"module"}