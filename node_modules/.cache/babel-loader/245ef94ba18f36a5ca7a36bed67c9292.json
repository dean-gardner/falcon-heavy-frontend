{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { Logger } from '../../utils/Logger';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BeaconEvent } from '../../events';\nimport { BEACON_VERSION } from '../../constants';\nimport { getAddressFromPublicKey } from '../../utils/crypto';\nimport { Client, TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Serializer, LocalStorage, BeaconError } from '../..';\nimport { messageEvents } from '../../beacon-message-events';\nimport { checkPermissions } from '../../utils/check-permissions';\nimport { getAccountIdentifier } from '../../utils/get-account-identifier';\nconst logger = new Logger('DAppClient');\nexport class DAppClient extends Client {\n  constructor(config) {\n    super(Object.assign({\n      storage: config.storage ? config.storage : new LocalStorage()\n    }, config));\n    this.openRequests = new Map();\n    this._activeAccount = new ExposedPromise();\n    this.iconUrl = config.iconUrl;\n    this.storage.get(StorageKey.ACTIVE_ACCOUNT).then(activeAccountIdentifier => __awaiter(this, void 0, void 0, function* () {\n      if (activeAccountIdentifier) {\n        yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));\n      } else {\n        yield this.setActiveAccount(undefined);\n      }\n    })).catch(storageError => __awaiter(this, void 0, void 0, function* () {\n      yield this.setActiveAccount(undefined);\n      console.error(storageError);\n    }));\n\n    this.handleResponse = (event, connectionInfo) => {\n      const openRequest = this.openRequests.get(event.id);\n\n      if (openRequest) {\n        logger.log('handleResponse', 'found openRequest', event.id); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        const errorMessage = event;\n\n        if (errorMessage.errorType) {\n          openRequest.reject(errorMessage);\n        } else {\n          openRequest.resolve({\n            message: event,\n            connectionInfo\n          });\n        }\n\n        this.openRequests.delete(event.id);\n      } else {\n        logger.error('handleResponse', 'no request found for id ', event.id);\n      }\n    };\n  }\n\n  get isConnected() {\n    return this._isConnected.promise;\n  }\n\n  addOpenRequest(id, promise) {\n    logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);\n    this.openRequests.set(id, promise);\n  }\n\n  init(_isDapp, transport) {\n    const _super = Object.create(null, {\n      init: {\n        get: () => super.init\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const initResponse = yield _super.init.call(this, true, transport);\n      return initResponse;\n    });\n  }\n\n  getActiveAccount() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this._activeAccount.promise;\n    });\n  }\n\n  setActiveAccount(account) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this._activeAccount.isSettled()) {\n        // If the promise has already been resolved we need to create a new one.\n        this._activeAccount = ExposedPromise.resolve(account);\n      } else {\n        this._activeAccount.resolve(account);\n      }\n\n      yield this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);\n      yield this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);\n      return;\n    });\n  }\n\n  getAppMetadata() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return {\n        beaconId: yield this.beaconId,\n        name: this.name,\n        icon: this.iconUrl\n      };\n    });\n  }\n\n  connect() {\n    const _super = Object.create(null, {\n      _connect: {\n        get: () => super._connect\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      return _super._connect.call(this);\n    });\n  }\n\n  removeAccount(accountIdentifier) {\n    const _super = Object.create(null, {\n      removeAccount: {\n        get: () => super.removeAccount\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {\n        yield this.setActiveAccount(undefined);\n      }\n\n      return removeAccountResult;\n    });\n  }\n\n  removeAllAccounts() {\n    const _super = Object.create(null, {\n      removeAllAccounts: {\n        get: () => super.removeAllAccounts\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      yield _super.removeAllAccounts.call(this);\n      yield this.setActiveAccount(undefined);\n    });\n  }\n\n  removePeer(id) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if ((yield this.transport).type === TransportType.P2P) {\n        const removePeerResult = (yield this.transport).removePeer(id);\n        yield this.removeAccountsForPeers([id]);\n        return removePeerResult;\n      }\n    });\n  }\n\n  removeAllPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if ((yield this.transport).type === TransportType.P2P) {\n        const peers = yield (yield this.transport).getPeers();\n        const removePeerResult = (yield this.transport).removeAllPeers();\n        yield this.removeAccountsForPeers(peers);\n        return removePeerResult;\n      }\n    });\n  }\n\n  subscribeToEvent(internalEvent, eventCallback) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.events.on(internalEvent, eventCallback);\n    });\n  }\n\n  checkPermissions(type) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (type === BeaconMessageType.PermissionRequest) {\n        return true;\n      }\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (!activeAccount) {\n        throw this.sendInternalError('No active account set!');\n      }\n\n      const permissions = activeAccount.scopes;\n      return checkPermissions(type, permissions);\n    });\n  }\n  /**\n   * Permission request\n   */\n\n\n  requestPermissions(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const request = {\n        appMetadata: yield this.getAppMetadata(),\n        type: BeaconMessageType.PermissionRequest,\n        network: input && input.network ? input.network : {\n          type: NetworkType.MAINNET\n        },\n        scopes: input && input.scopes ? input.scopes : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw this.handleRequestError(request, requestError);\n      })); // TODO: Migration code. Remove before 1.0.0 release.\n\n      const publicKey = message.publicKey || message.pubkey || message.pubKey;\n      const address = yield getAddressFromPublicKey(publicKey);\n      const accountInfo = {\n        accountIdentifier: yield getAccountIdentifier(address, message.network),\n        beaconId: message.beaconId,\n        origin: {\n          type: connectionInfo.origin,\n          id: connectionInfo.id\n        },\n        address,\n        publicKey,\n        network: message.network,\n        scopes: message.scopes,\n        connectedAt: new Date().getTime()\n      };\n      yield this.accountManager.addAccount(accountInfo);\n      yield this.setActiveAccount(accountInfo);\n      const {\n        beaconId,\n        network,\n        scopes\n      } = message;\n      const output = {\n        beaconId,\n        publicKey,\n        address,\n        network,\n        scopes\n      };\n      yield this.notifySuccess(request, {\n        account: accountInfo,\n        output,\n        connectionContext: connectionInfo\n      });\n      return output;\n    });\n  }\n  /**\n   * Sign request\n   */\n\n\n  requestSignPayload(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!input.payload) {\n        throw this.sendInternalError('Payload must be provided');\n      }\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (!activeAccount) {\n        throw this.sendInternalError('No active account!');\n      }\n\n      const request = {\n        type: BeaconMessageType.SignPayloadRequest,\n        payload: input.payload,\n        sourceAddress: input.sourceAddress || activeAccount.address\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw this.handleRequestError(request, requestError);\n      }));\n      const {\n        beaconId,\n        signature\n      } = message;\n      const output = {\n        beaconId,\n        signature\n      };\n      yield this.notifySuccess(request, {\n        account: activeAccount,\n        output,\n        connectionContext: connectionInfo\n      });\n      return output;\n    });\n  }\n  /**\n   * Operation request\n   */\n\n\n  requestOperation(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!input.operationDetails) {\n        throw this.sendInternalError('Operation details must be provided');\n      }\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (!activeAccount) {\n        throw this.sendInternalError('No active account!');\n      }\n\n      const request = {\n        type: BeaconMessageType.OperationRequest,\n        network: input.network || activeAccount.network || {\n          type: NetworkType.MAINNET\n        },\n        operationDetails: input.operationDetails,\n        sourceAddress: activeAccount.address || ''\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw this.handleRequestError(request, requestError);\n      }));\n      const {\n        beaconId,\n        transactionHash\n      } = message;\n      const output = {\n        beaconId,\n        transactionHash\n      };\n      yield this.notifySuccess(request, {\n        account: activeAccount,\n        output,\n        connectionContext: connectionInfo\n      });\n      return {\n        beaconId,\n        transactionHash\n      };\n    });\n  }\n  /**\n   * Broadcast request\n   */\n\n\n  requestBroadcast(input) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!input.signedTransaction) {\n        throw this.sendInternalError('Signed transaction must be provided');\n      }\n\n      const network = input.network || {\n        type: NetworkType.MAINNET\n      };\n      const request = {\n        type: BeaconMessageType.BroadcastRequest,\n        network,\n        signedTransaction: input.signedTransaction\n      };\n      const {\n        message,\n        connectionInfo\n      } = yield this.makeRequest(request).catch(requestError => __awaiter(this, void 0, void 0, function* () {\n        throw this.handleRequestError(request, requestError);\n      }));\n      const {\n        beaconId,\n        transactionHash\n      } = message;\n      const output = {\n        beaconId,\n        transactionHash\n      };\n      yield this.notifySuccess(request, {\n        network,\n        output,\n        connectionContext: connectionInfo\n      });\n      return {\n        beaconId,\n        transactionHash\n      };\n    });\n  }\n\n  sendInternalError(errorMessage) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.events.emit(BeaconEvent.INTERNAL_ERROR, errorMessage);\n      throw new Error(errorMessage);\n    });\n  }\n\n  removeAccountsForPeers(peersToRemove) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const accounts = yield this.accountManager.getAccounts();\n      const peerIdsToRemove = peersToRemove.map(peer => peer.publicKey); // Remove all accounts with origin of the specified peer\n\n      const accountsToRemove = accounts.filter(account => peerIdsToRemove.includes(account.origin.id));\n      const accountIdentifiersToRemove = accountsToRemove.map(accountInfo => accountInfo.accountIdentifier);\n      yield this.accountManager.removeAccounts(accountIdentifiersToRemove); // Check if one of the accounts that was removed was the active account and if yes, set it to undefined\n\n      const activeAccount = yield this.getActiveAccount();\n\n      if (activeAccount) {\n        if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {\n          yield this.setActiveAccount(undefined);\n        }\n      }\n    });\n  }\n\n  handleRequestError(request, beaconError) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (beaconError.errorType) {\n        this.events.emit(messageEvents[request.type].error, beaconError).catch(emitError => console.warn(emitError));\n        throw BeaconError.getError(beaconError.errorType);\n      }\n\n      console.error('requestError', beaconError);\n      throw beaconError;\n    });\n  }\n\n  notifySuccess(request, response) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.events.emit(messageEvents[request.type].success, response).catch(emitError => console.warn(emitError));\n    });\n  }\n\n  makeRequest(requestInput, account) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('makeRequest');\n      yield this.init();\n      logger.log('makeRequest', 'after init');\n      yield this.connect();\n      logger.log('makeRequest', 'after connecting');\n\n      if (yield this.addRequestAndCheckIfRateLimited()) {\n        this.events.emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED).catch(emitError => console.warn(emitError));\n        throw new Error('rate limit reached');\n      }\n\n      if (!(yield this.checkPermissions(requestInput.type))) {\n        this.events.emit(BeaconEvent.NO_PERMISSIONS).catch(emitError => console.warn(emitError));\n        throw new Error('No permissions to send this request to wallet!');\n      }\n\n      if (!this.beaconId) {\n        throw this.sendInternalError('BeaconID not defined');\n      }\n\n      const request = Object.assign({\n        id: generateGUID(),\n        version: BEACON_VERSION,\n        beaconId: yield this.beaconId\n      }, requestInput);\n      const exposed = new ExposedPromise();\n      this.addOpenRequest(request.id, exposed);\n      const payload = yield new Serializer().serialize(request);\n      let origin;\n\n      if (account) {\n        origin = account.origin.id;\n      }\n\n      yield (yield this.transport).send(payload, origin);\n      this.events.emit(messageEvents[requestInput.type].sent).catch(emitError => console.warn(emitError)); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n      return exposed.promise; // TODO: fix type\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","ExposedPromise","Logger","generateGUID","BeaconEvent","BEACON_VERSION","getAddressFromPublicKey","Client","TransportType","StorageKey","BeaconMessageType","PermissionScope","NetworkType","Serializer","LocalStorage","BeaconError","messageEvents","checkPermissions","getAccountIdentifier","logger","DAppClient","constructor","config","Object","assign","storage","openRequests","Map","_activeAccount","iconUrl","get","ACTIVE_ACCOUNT","activeAccountIdentifier","setActiveAccount","accountManager","getAccount","undefined","catch","storageError","console","error","handleResponse","event","connectionInfo","openRequest","id","log","errorMessage","errorType","message","delete","isConnected","_isConnected","promise","addOpenRequest","name","set","init","_isDapp","transport","_super","create","initResponse","call","getActiveAccount","account","isSettled","accountIdentifier","events","emit","ACTIVE_ACCOUNT_SET","getAppMetadata","beaconId","icon","connect","_connect","removeAccount","removeAccountResult","activeAccount","removeAllAccounts","removePeer","type","P2P","removePeerResult","removeAccountsForPeers","removeAllPeers","peers","getPeers","subscribeToEvent","internalEvent","eventCallback","on","PermissionRequest","sendInternalError","permissions","scopes","requestPermissions","input","request","appMetadata","network","MAINNET","OPERATION_REQUEST","SIGN","makeRequest","requestError","handleRequestError","publicKey","pubkey","pubKey","address","accountInfo","origin","connectedAt","Date","getTime","addAccount","output","notifySuccess","connectionContext","requestSignPayload","payload","SignPayloadRequest","sourceAddress","signature","requestOperation","operationDetails","OperationRequest","transactionHash","requestBroadcast","signedTransaction","BroadcastRequest","INTERNAL_ERROR","Error","peersToRemove","accounts","getAccounts","peerIdsToRemove","map","peer","accountsToRemove","filter","includes","accountIdentifiersToRemove","removeAccounts","beaconError","emitError","warn","getError","response","success","requestInput","addRequestAndCheckIfRateLimited","LOCAL_RATE_LIMIT_REACHED","NO_PERMISSIONS","version","exposed","serialize","send","sent"],"sourceRoot":"","sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@airgap/beacon-sdk/dist/esm/clients/dapp-client/DAppClient.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ExposedPromise } from '../../utils/exposed-promise';\nimport { Logger } from '../../utils/Logger';\nimport { generateGUID } from '../../utils/generate-uuid';\nimport { BeaconEvent } from '../../events';\nimport { BEACON_VERSION } from '../../constants';\nimport { getAddressFromPublicKey } from '../../utils/crypto';\nimport { Client, TransportType, StorageKey, BeaconMessageType, PermissionScope, NetworkType, Serializer, LocalStorage, BeaconError } from '../..';\nimport { messageEvents } from '../../beacon-message-events';\nimport { checkPermissions } from '../../utils/check-permissions';\nimport { getAccountIdentifier } from '../../utils/get-account-identifier';\nconst logger = new Logger('DAppClient');\nexport class DAppClient extends Client {\n    constructor(config) {\n        super(Object.assign({ storage: config.storage ? config.storage : new LocalStorage() }, config));\n        this.openRequests = new Map();\n        this._activeAccount = new ExposedPromise();\n        this.iconUrl = config.iconUrl;\n        this.storage\n            .get(StorageKey.ACTIVE_ACCOUNT)\n            .then((activeAccountIdentifier) => __awaiter(this, void 0, void 0, function* () {\n            if (activeAccountIdentifier) {\n                yield this.setActiveAccount(yield this.accountManager.getAccount(activeAccountIdentifier));\n            }\n            else {\n                yield this.setActiveAccount(undefined);\n            }\n        }))\n            .catch((storageError) => __awaiter(this, void 0, void 0, function* () {\n            yield this.setActiveAccount(undefined);\n            console.error(storageError);\n        }));\n        this.handleResponse = (event, connectionInfo) => {\n            const openRequest = this.openRequests.get(event.id);\n            if (openRequest) {\n                logger.log('handleResponse', 'found openRequest', event.id);\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                const errorMessage = event;\n                if (errorMessage.errorType) {\n                    openRequest.reject(errorMessage);\n                }\n                else {\n                    openRequest.resolve({ message: event, connectionInfo });\n                }\n                this.openRequests.delete(event.id);\n            }\n            else {\n                logger.error('handleResponse', 'no request found for id ', event.id);\n            }\n        };\n    }\n    get isConnected() {\n        return this._isConnected.promise;\n    }\n    addOpenRequest(id, promise) {\n        logger.log('addOpenRequest', this.name, `adding request ${id} and waiting for answer`);\n        this.openRequests.set(id, promise);\n    }\n    init(_isDapp, transport) {\n        const _super = Object.create(null, {\n            init: { get: () => super.init }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const initResponse = yield _super.init.call(this, true, transport);\n            return initResponse;\n        });\n    }\n    getActiveAccount() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._activeAccount.promise;\n        });\n    }\n    setActiveAccount(account) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._activeAccount.isSettled()) {\n                // If the promise has already been resolved we need to create a new one.\n                this._activeAccount = ExposedPromise.resolve(account);\n            }\n            else {\n                this._activeAccount.resolve(account);\n            }\n            yield this.storage.set(StorageKey.ACTIVE_ACCOUNT, account ? account.accountIdentifier : undefined);\n            yield this.events.emit(BeaconEvent.ACTIVE_ACCOUNT_SET, account);\n            return;\n        });\n    }\n    getAppMetadata() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return {\n                beaconId: yield this.beaconId,\n                name: this.name,\n                icon: this.iconUrl\n            };\n        });\n    }\n    connect() {\n        const _super = Object.create(null, {\n            _connect: { get: () => super._connect }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            return _super._connect.call(this);\n        });\n    }\n    removeAccount(accountIdentifier) {\n        const _super = Object.create(null, {\n            removeAccount: { get: () => super.removeAccount }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            const removeAccountResult = _super.removeAccount.call(this, accountIdentifier);\n            const activeAccount = yield this.getActiveAccount();\n            if (activeAccount && activeAccount.accountIdentifier === accountIdentifier) {\n                yield this.setActiveAccount(undefined);\n            }\n            return removeAccountResult;\n        });\n    }\n    removeAllAccounts() {\n        const _super = Object.create(null, {\n            removeAllAccounts: { get: () => super.removeAllAccounts }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            yield _super.removeAllAccounts.call(this);\n            yield this.setActiveAccount(undefined);\n        });\n    }\n    removePeer(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((yield this.transport).type === TransportType.P2P) {\n                const removePeerResult = (yield this.transport).removePeer(id);\n                yield this.removeAccountsForPeers([id]);\n                return removePeerResult;\n            }\n        });\n    }\n    removeAllPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if ((yield this.transport).type === TransportType.P2P) {\n                const peers = yield (yield this.transport).getPeers();\n                const removePeerResult = (yield this.transport).removeAllPeers();\n                yield this.removeAccountsForPeers(peers);\n                return removePeerResult;\n            }\n        });\n    }\n    subscribeToEvent(internalEvent, eventCallback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.events.on(internalEvent, eventCallback);\n        });\n    }\n    checkPermissions(type) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (type === BeaconMessageType.PermissionRequest) {\n                return true;\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw this.sendInternalError('No active account set!');\n            }\n            const permissions = activeAccount.scopes;\n            return checkPermissions(type, permissions);\n        });\n    }\n    /**\n     * Permission request\n     */\n    requestPermissions(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const request = {\n                appMetadata: yield this.getAppMetadata(),\n                type: BeaconMessageType.PermissionRequest,\n                network: input && input.network ? input.network : { type: NetworkType.MAINNET },\n                scopes: input && input.scopes\n                    ? input.scopes\n                    : [PermissionScope.OPERATION_REQUEST, PermissionScope.SIGN]\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw this.handleRequestError(request, requestError);\n            }));\n            // TODO: Migration code. Remove before 1.0.0 release.\n            const publicKey = message.publicKey || message.pubkey || message.pubKey;\n            const address = yield getAddressFromPublicKey(publicKey);\n            const accountInfo = {\n                accountIdentifier: yield getAccountIdentifier(address, message.network),\n                beaconId: message.beaconId,\n                origin: {\n                    type: connectionInfo.origin,\n                    id: connectionInfo.id\n                },\n                address,\n                publicKey,\n                network: message.network,\n                scopes: message.scopes,\n                connectedAt: new Date().getTime()\n            };\n            yield this.accountManager.addAccount(accountInfo);\n            yield this.setActiveAccount(accountInfo);\n            const { beaconId, network, scopes } = message;\n            const output = { beaconId, publicKey, address, network, scopes };\n            yield this.notifySuccess(request, {\n                account: accountInfo,\n                output,\n                connectionContext: connectionInfo\n            });\n            return output;\n        });\n    }\n    /**\n     * Sign request\n     */\n    requestSignPayload(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.payload) {\n                throw this.sendInternalError('Payload must be provided');\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw this.sendInternalError('No active account!');\n            }\n            const request = {\n                type: BeaconMessageType.SignPayloadRequest,\n                payload: input.payload,\n                sourceAddress: input.sourceAddress || activeAccount.address\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw this.handleRequestError(request, requestError);\n            }));\n            const { beaconId, signature } = message;\n            const output = { beaconId, signature };\n            yield this.notifySuccess(request, {\n                account: activeAccount,\n                output,\n                connectionContext: connectionInfo\n            });\n            return output;\n        });\n    }\n    /**\n     * Operation request\n     */\n    requestOperation(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.operationDetails) {\n                throw this.sendInternalError('Operation details must be provided');\n            }\n            const activeAccount = yield this.getActiveAccount();\n            if (!activeAccount) {\n                throw this.sendInternalError('No active account!');\n            }\n            const request = {\n                type: BeaconMessageType.OperationRequest,\n                network: input.network || activeAccount.network || { type: NetworkType.MAINNET },\n                operationDetails: input.operationDetails,\n                sourceAddress: activeAccount.address || ''\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw this.handleRequestError(request, requestError);\n            }));\n            const { beaconId, transactionHash } = message;\n            const output = { beaconId, transactionHash };\n            yield this.notifySuccess(request, {\n                account: activeAccount,\n                output,\n                connectionContext: connectionInfo\n            });\n            return { beaconId, transactionHash };\n        });\n    }\n    /**\n     * Broadcast request\n     */\n    requestBroadcast(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!input.signedTransaction) {\n                throw this.sendInternalError('Signed transaction must be provided');\n            }\n            const network = input.network || { type: NetworkType.MAINNET };\n            const request = {\n                type: BeaconMessageType.BroadcastRequest,\n                network,\n                signedTransaction: input.signedTransaction\n            };\n            const { message, connectionInfo } = yield this.makeRequest(request).catch((requestError) => __awaiter(this, void 0, void 0, function* () {\n                throw this.handleRequestError(request, requestError);\n            }));\n            const { beaconId, transactionHash } = message;\n            const output = { beaconId, transactionHash };\n            yield this.notifySuccess(request, { network, output, connectionContext: connectionInfo });\n            return { beaconId, transactionHash };\n        });\n    }\n    sendInternalError(errorMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.events.emit(BeaconEvent.INTERNAL_ERROR, errorMessage);\n            throw new Error(errorMessage);\n        });\n    }\n    removeAccountsForPeers(peersToRemove) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const accounts = yield this.accountManager.getAccounts();\n            const peerIdsToRemove = peersToRemove.map((peer) => peer.publicKey);\n            // Remove all accounts with origin of the specified peer\n            const accountsToRemove = accounts.filter((account) => peerIdsToRemove.includes(account.origin.id));\n            const accountIdentifiersToRemove = accountsToRemove.map((accountInfo) => accountInfo.accountIdentifier);\n            yield this.accountManager.removeAccounts(accountIdentifiersToRemove);\n            // Check if one of the accounts that was removed was the active account and if yes, set it to undefined\n            const activeAccount = yield this.getActiveAccount();\n            if (activeAccount) {\n                if (accountIdentifiersToRemove.includes(activeAccount.accountIdentifier)) {\n                    yield this.setActiveAccount(undefined);\n                }\n            }\n        });\n    }\n    handleRequestError(request, beaconError) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (beaconError.errorType) {\n                this.events\n                    .emit(messageEvents[request.type].error, beaconError)\n                    .catch((emitError) => console.warn(emitError));\n                throw BeaconError.getError(beaconError.errorType);\n            }\n            console.error('requestError', beaconError);\n            throw beaconError;\n        });\n    }\n    notifySuccess(request, response) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.events\n                .emit(messageEvents[request.type].success, response)\n                .catch((emitError) => console.warn(emitError));\n        });\n    }\n    makeRequest(requestInput, account) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('makeRequest');\n            yield this.init();\n            logger.log('makeRequest', 'after init');\n            yield this.connect();\n            logger.log('makeRequest', 'after connecting');\n            if (yield this.addRequestAndCheckIfRateLimited()) {\n                this.events\n                    .emit(BeaconEvent.LOCAL_RATE_LIMIT_REACHED)\n                    .catch((emitError) => console.warn(emitError));\n                throw new Error('rate limit reached');\n            }\n            if (!(yield this.checkPermissions(requestInput.type))) {\n                this.events.emit(BeaconEvent.NO_PERMISSIONS).catch((emitError) => console.warn(emitError));\n                throw new Error('No permissions to send this request to wallet!');\n            }\n            if (!this.beaconId) {\n                throw this.sendInternalError('BeaconID not defined');\n            }\n            const request = Object.assign({ id: generateGUID(), version: BEACON_VERSION, beaconId: yield this.beaconId }, requestInput);\n            const exposed = new ExposedPromise();\n            this.addOpenRequest(request.id, exposed);\n            const payload = yield new Serializer().serialize(request);\n            let origin;\n            if (account) {\n                origin = account.origin.id;\n            }\n            yield (yield this.transport).send(payload, origin);\n            this.events\n                .emit(messageEvents[requestInput.type].sent)\n                .catch((emitError) => console.warn(emitError));\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return exposed.promise; // TODO: fix type\n        });\n    }\n}\n//# sourceMappingURL=DAppClient.js.map"]},"metadata":{},"sourceType":"module"}