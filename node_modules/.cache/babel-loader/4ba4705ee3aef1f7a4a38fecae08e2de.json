{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { Logger } from '../utils/Logger';\nimport { StorageKey, TransportStatus, Transport, TransportType, P2PCommunicationClient, Origin } from '..';\nimport { BeaconEvent } from '../events';\nimport { PeerManager } from '../managers/PeerManager';\nconst logger = new Logger('Transport');\nexport class P2PTransport extends Transport {\n  constructor(name, keyPair, storage, events, isDapp) {\n    super(name);\n    this.type = TransportType.P2P;\n    this.isDapp = true; // Make sure we only listen once\n\n    this.listeningForChannelOpenings = false;\n    this.keyPair = keyPair;\n    this.storage = storage;\n    this.events = events;\n    this.isDapp = isDapp;\n    this.client = new P2PCommunicationClient(this.name, this.keyPair, 1, false);\n    this.peerManager = new PeerManager(storage);\n  }\n\n  static isAvailable() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return Promise.resolve(true);\n    });\n  }\n\n  connect() {\n    const _super = Object.create(null, {\n      connect: {\n        get: () => super.connect\n      }\n    });\n\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('connect');\n      this._isConnected = TransportStatus.CONNECTING;\n      yield this.client.start();\n      const knownPeers = yield this.peerManager.getPeers();\n\n      if (knownPeers.length > 0) {\n        logger.log('connect', `connecting to ${knownPeers.length} peers`);\n        const connectionPromises = knownPeers.map(peer => __awaiter(this, void 0, void 0, function* () {\n          return this.listen(peer.publicKey);\n        }));\n        yield Promise.all(connectionPromises);\n      } else {\n        if (this.isDapp) {\n          yield this.connectNewPeer();\n        }\n      }\n\n      yield _super.connect.call(this);\n    });\n  }\n\n  reconnect() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.isDapp) {\n        yield this.connectNewPeer();\n      }\n    });\n  }\n\n  connectNewPeer() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('connectNewPeer');\n      return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {\n        if (!this.listeningForChannelOpenings) {\n          yield this.client.listenForChannelOpening(publicKey => __awaiter(this, void 0, void 0, function* () {\n            logger.log('connectNewPeer', `new publicKey ${publicKey}`);\n            const newPeer = {\n              name: '',\n              publicKey,\n              relayServer: ''\n            };\n\n            if (!(yield this.peerManager.hasPeer(publicKey))) {\n              yield this.peerManager.addPeer(newPeer);\n              yield this.listen(publicKey);\n            }\n\n            this.events.emit(BeaconEvent.P2P_CHANNEL_CONNECT_SUCCESS, newPeer).catch(emitError => console.warn(emitError));\n            resolve();\n          }));\n          this.listeningForChannelOpenings = true;\n        }\n\n        this.events.emit(BeaconEvent.P2P_LISTEN_FOR_CHANNEL_OPEN, yield this.client.getHandshakeInfo()).catch(emitError => console.warn(emitError));\n      }));\n    });\n  }\n\n  getPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.peerManager.getPeers();\n    });\n  }\n\n  addPeer(newPeer) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!(yield this.peerManager.hasPeer(newPeer.publicKey))) {\n        logger.log('addPeer', newPeer);\n        yield this.peerManager.addPeer({\n          name: newPeer.name,\n          publicKey: newPeer.publicKey,\n          relayServer: newPeer.relayServer\n        });\n        yield this.client.openChannel(newPeer.publicKey, newPeer.relayServer); // TODO: Should we have a confirmation here?\n\n        yield this.listen(newPeer.publicKey); // TODO: Prevent channels from being opened multiple times\n      } else {\n        logger.log('addPeer', 'peer already added, skipping', newPeer);\n      }\n    });\n  }\n\n  removePeer(peerToBeRemoved) {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removePeer', peerToBeRemoved);\n      yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n\n      if (this.client) {\n        yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n      }\n    });\n  }\n\n  removeAllPeers() {\n    return __awaiter(this, void 0, void 0, function* () {\n      logger.log('removeAllPeers');\n      yield this.peerManager.removeAllPeers();\n      yield this.client.unsubscribeFromEncryptedMessages();\n    });\n  }\n\n  send(message, recipient) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const knownPeers = yield this.storage.get(StorageKey.TRANSPORT_P2P_PEERS);\n\n      if (recipient) {\n        if (!knownPeers.some(peer => peer.publicKey === recipient)) {\n          throw new Error('Recipient unknown');\n        }\n\n        return this.client.sendMessage(recipient, message);\n      } else {\n        // A broadcast request has to be sent everywhere.\n        const promises = knownPeers.map(peer => this.client.sendMessage(peer.publicKey, message));\n        return (yield Promise.all(promises))[0];\n      }\n    });\n  }\n\n  listen(publicKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.client.listenForEncryptedMessage(publicKey, message => {\n        const connectionContext = {\n          origin: Origin.P2P,\n          id: publicKey\n        };\n        this.notifyListeners(message, connectionContext).catch(error => {\n          throw error;\n        });\n      }).catch(error => {\n        throw error;\n      });\n    });\n  }\n\n}","map":{"version":3,"mappings":"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","names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Logger","StorageKey","TransportStatus","Transport","TransportType","P2PCommunicationClient","Origin","BeaconEvent","PeerManager","logger","P2PTransport","constructor","name","keyPair","storage","events","isDapp","type","P2P","listeningForChannelOpenings","client","peerManager","isAvailable","connect","_super","Object","create","get","log","_isConnected","CONNECTING","start","knownPeers","getPeers","length","connectionPromises","map","peer","listen","publicKey","all","connectNewPeer","call","reconnect","listenForChannelOpening","newPeer","relayServer","hasPeer","addPeer","emit","P2P_CHANNEL_CONNECT_SUCCESS","catch","emitError","console","warn","P2P_LISTEN_FOR_CHANNEL_OPEN","getHandshakeInfo","openChannel","removePeer","peerToBeRemoved","unsubscribeFromEncryptedMessage","removeAllPeers","unsubscribeFromEncryptedMessages","send","message","recipient","TRANSPORT_P2P_PEERS","some","Error","sendMessage","promises","listenForEncryptedMessage","connectionContext","origin","id","notifyListeners","error"],"sourceRoot":"","sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/@airgap/beacon-sdk/dist/esm/transports/P2PTransport.js"],"sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Logger } from '../utils/Logger';\nimport { StorageKey, TransportStatus, Transport, TransportType, P2PCommunicationClient, Origin } from '..';\nimport { BeaconEvent } from '../events';\nimport { PeerManager } from '../managers/PeerManager';\nconst logger = new Logger('Transport');\nexport class P2PTransport extends Transport {\n    constructor(name, keyPair, storage, events, isDapp) {\n        super(name);\n        this.type = TransportType.P2P;\n        this.isDapp = true;\n        // Make sure we only listen once\n        this.listeningForChannelOpenings = false;\n        this.keyPair = keyPair;\n        this.storage = storage;\n        this.events = events;\n        this.isDapp = isDapp;\n        this.client = new P2PCommunicationClient(this.name, this.keyPair, 1, false);\n        this.peerManager = new PeerManager(storage);\n    }\n    static isAvailable() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve(true);\n        });\n    }\n    connect() {\n        const _super = Object.create(null, {\n            connect: { get: () => super.connect }\n        });\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('connect');\n            this._isConnected = TransportStatus.CONNECTING;\n            yield this.client.start();\n            const knownPeers = yield this.peerManager.getPeers();\n            if (knownPeers.length > 0) {\n                logger.log('connect', `connecting to ${knownPeers.length} peers`);\n                const connectionPromises = knownPeers.map((peer) => __awaiter(this, void 0, void 0, function* () { return this.listen(peer.publicKey); }));\n                yield Promise.all(connectionPromises);\n            }\n            else {\n                if (this.isDapp) {\n                    yield this.connectNewPeer();\n                }\n            }\n            yield _super.connect.call(this);\n        });\n    }\n    reconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isDapp) {\n                yield this.connectNewPeer();\n            }\n        });\n    }\n    connectNewPeer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('connectNewPeer');\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                if (!this.listeningForChannelOpenings) {\n                    yield this.client.listenForChannelOpening((publicKey) => __awaiter(this, void 0, void 0, function* () {\n                        logger.log('connectNewPeer', `new publicKey ${publicKey}`);\n                        const newPeer = { name: '', publicKey, relayServer: '' };\n                        if (!(yield this.peerManager.hasPeer(publicKey))) {\n                            yield this.peerManager.addPeer(newPeer);\n                            yield this.listen(publicKey);\n                        }\n                        this.events\n                            .emit(BeaconEvent.P2P_CHANNEL_CONNECT_SUCCESS, newPeer)\n                            .catch((emitError) => console.warn(emitError));\n                        resolve();\n                    }));\n                    this.listeningForChannelOpenings = true;\n                }\n                this.events\n                    .emit(BeaconEvent.P2P_LISTEN_FOR_CHANNEL_OPEN, yield this.client.getHandshakeInfo())\n                    .catch((emitError) => console.warn(emitError));\n            }));\n        });\n    }\n    getPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.peerManager.getPeers();\n        });\n    }\n    addPeer(newPeer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!(yield this.peerManager.hasPeer(newPeer.publicKey))) {\n                logger.log('addPeer', newPeer);\n                yield this.peerManager.addPeer({\n                    name: newPeer.name,\n                    publicKey: newPeer.publicKey,\n                    relayServer: newPeer.relayServer\n                });\n                yield this.client.openChannel(newPeer.publicKey, newPeer.relayServer); // TODO: Should we have a confirmation here?\n                yield this.listen(newPeer.publicKey); // TODO: Prevent channels from being opened multiple times\n            }\n            else {\n                logger.log('addPeer', 'peer already added, skipping', newPeer);\n            }\n        });\n    }\n    removePeer(peerToBeRemoved) {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removePeer', peerToBeRemoved);\n            yield this.peerManager.removePeer(peerToBeRemoved.publicKey);\n            if (this.client) {\n                yield this.client.unsubscribeFromEncryptedMessage(peerToBeRemoved.publicKey);\n            }\n        });\n    }\n    removeAllPeers() {\n        return __awaiter(this, void 0, void 0, function* () {\n            logger.log('removeAllPeers');\n            yield this.peerManager.removeAllPeers();\n            yield this.client.unsubscribeFromEncryptedMessages();\n        });\n    }\n    send(message, recipient) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const knownPeers = yield this.storage.get(StorageKey.TRANSPORT_P2P_PEERS);\n            if (recipient) {\n                if (!knownPeers.some((peer) => peer.publicKey === recipient)) {\n                    throw new Error('Recipient unknown');\n                }\n                return this.client.sendMessage(recipient, message);\n            }\n            else {\n                // A broadcast request has to be sent everywhere.\n                const promises = knownPeers.map((peer) => this.client.sendMessage(peer.publicKey, message));\n                return (yield Promise.all(promises))[0];\n            }\n        });\n    }\n    listen(publicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.client\n                .listenForEncryptedMessage(publicKey, (message) => {\n                const connectionContext = {\n                    origin: Origin.P2P,\n                    id: publicKey\n                };\n                this.notifyListeners(message, connectionContext).catch((error) => {\n                    throw error;\n                });\n            })\n                .catch((error) => {\n                throw error;\n            });\n        });\n    }\n}\n//# sourceMappingURL=P2PTransport.js.map"]},"metadata":{},"sourceType":"module"}