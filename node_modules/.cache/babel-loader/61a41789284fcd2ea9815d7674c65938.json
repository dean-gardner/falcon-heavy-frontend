{"ast":null,"code":"/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n  var length = arguments.length;\n  var scheduler = async;\n\n  if (isScheduler(arguments[arguments.length - 1])) {\n    scheduler = arguments[arguments.length - 1];\n    length--;\n  }\n\n  var bufferCreationInterval = null;\n\n  if (length >= 2) {\n    bufferCreationInterval = arguments[1];\n  }\n\n  var maxBufferSize = Number.POSITIVE_INFINITY;\n\n  if (length >= 3) {\n    maxBufferSize = arguments[2];\n  }\n\n  return function bufferTimeOperatorFunction(source) {\n    return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n  };\n}\n\nvar BufferTimeOperator = /*@__PURE__*/function () {\n  function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    this.bufferTimeSpan = bufferTimeSpan;\n    this.bufferCreationInterval = bufferCreationInterval;\n    this.maxBufferSize = maxBufferSize;\n    this.scheduler = scheduler;\n  }\n\n  BufferTimeOperator.prototype.call = function (subscriber, source) {\n    return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n  };\n\n  return BufferTimeOperator;\n}();\n\nvar Context = /*@__PURE__*/function () {\n  function Context() {\n    this.buffer = [];\n  }\n\n  return Context;\n}();\n\nvar BufferTimeSubscriber = /*@__PURE__*/function (_super) {\n  tslib_1.__extends(BufferTimeSubscriber, _super);\n\n  function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n    var _this = _super.call(this, destination) || this;\n\n    _this.bufferTimeSpan = bufferTimeSpan;\n    _this.bufferCreationInterval = bufferCreationInterval;\n    _this.maxBufferSize = maxBufferSize;\n    _this.scheduler = scheduler;\n    _this.contexts = [];\n\n    var context = _this.openContext();\n\n    _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n\n    if (_this.timespanOnly) {\n      var timeSpanOnlyState = {\n        subscriber: _this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    } else {\n      var closeState = {\n        subscriber: _this,\n        context: context\n      };\n      var creationState = {\n        bufferTimeSpan: bufferTimeSpan,\n        bufferCreationInterval: bufferCreationInterval,\n        subscriber: _this,\n        scheduler: scheduler\n      };\n\n      _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n\n      _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n    }\n\n    return _this;\n  }\n\n  BufferTimeSubscriber.prototype._next = function (value) {\n    var contexts = this.contexts;\n    var len = contexts.length;\n    var filledBufferContext;\n\n    for (var i = 0; i < len; i++) {\n      var context_1 = contexts[i];\n      var buffer = context_1.buffer;\n      buffer.push(value);\n\n      if (buffer.length == this.maxBufferSize) {\n        filledBufferContext = context_1;\n      }\n    }\n\n    if (filledBufferContext) {\n      this.onBufferFull(filledBufferContext);\n    }\n  };\n\n  BufferTimeSubscriber.prototype._error = function (err) {\n    this.contexts.length = 0;\n\n    _super.prototype._error.call(this, err);\n  };\n\n  BufferTimeSubscriber.prototype._complete = function () {\n    var _a = this,\n        contexts = _a.contexts,\n        destination = _a.destination;\n\n    while (contexts.length > 0) {\n      var context_2 = contexts.shift();\n      destination.next(context_2.buffer);\n    }\n\n    _super.prototype._complete.call(this);\n  };\n\n  BufferTimeSubscriber.prototype._unsubscribe = function () {\n    this.contexts = null;\n  };\n\n  BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n    this.closeContext(context);\n    var closeAction = context.closeAction;\n    closeAction.unsubscribe();\n    this.remove(closeAction);\n\n    if (!this.closed && this.timespanOnly) {\n      context = this.openContext();\n      var bufferTimeSpan = this.bufferTimeSpan;\n      var timeSpanOnlyState = {\n        subscriber: this,\n        context: context,\n        bufferTimeSpan: bufferTimeSpan\n      };\n      this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n    }\n  };\n\n  BufferTimeSubscriber.prototype.openContext = function () {\n    var context = new Context();\n    this.contexts.push(context);\n    return context;\n  };\n\n  BufferTimeSubscriber.prototype.closeContext = function (context) {\n    this.destination.next(context.buffer);\n    var contexts = this.contexts;\n    var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n\n    if (spliceIndex >= 0) {\n      contexts.splice(contexts.indexOf(context), 1);\n    }\n  };\n\n  return BufferTimeSubscriber;\n}(Subscriber);\n\nfunction dispatchBufferTimeSpanOnly(state) {\n  var subscriber = state.subscriber;\n  var prevContext = state.context;\n\n  if (prevContext) {\n    subscriber.closeContext(prevContext);\n  }\n\n  if (!subscriber.closed) {\n    state.context = subscriber.openContext();\n    state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n  }\n}\n\nfunction dispatchBufferCreation(state) {\n  var bufferCreationInterval = state.bufferCreationInterval,\n      bufferTimeSpan = state.bufferTimeSpan,\n      subscriber = state.subscriber,\n      scheduler = state.scheduler;\n  var context = subscriber.openContext();\n  var action = this;\n\n  if (!subscriber.closed) {\n    subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, {\n      subscriber: subscriber,\n      context: context\n    }));\n    action.schedule(state, bufferCreationInterval);\n  }\n}\n\nfunction dispatchBufferClose(arg) {\n  var subscriber = arg.subscriber,\n      context = arg.context;\n  subscriber.closeContext(context);\n}","map":{"version":3,"mappings":"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","names":["tslib_1","async","Subscriber","isScheduler","bufferTime","bufferTimeSpan","length","arguments","scheduler","bufferCreationInterval","maxBufferSize","Number","POSITIVE_INFINITY","bufferTimeOperatorFunction","source","lift","BufferTimeOperator","prototype","call","subscriber","subscribe","BufferTimeSubscriber","Context","buffer","_super","__extends","destination","_this","contexts","context","openContext","timespanOnly","timeSpanOnlyState","add","closeAction","schedule","dispatchBufferTimeSpanOnly","closeState","creationState","dispatchBufferClose","dispatchBufferCreation","_next","value","len","filledBufferContext","i","context_1","push","onBufferFull","_error","err","_complete","_a","context_2","shift","next","_unsubscribe","closeContext","unsubscribe","remove","closed","spliceIndex","indexOf","splice","state","prevContext","action","arg"],"sources":["D:/work/projects/plenty/falcon-heavy-frontend/node_modules/rxjs/_esm5/internal/operators/bufferTime.js"],"sourcesContent":["/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { async } from '../scheduler/async';\nimport { Subscriber } from '../Subscriber';\nimport { isScheduler } from '../util/isScheduler';\nexport function bufferTime(bufferTimeSpan) {\n    var length = arguments.length;\n    var scheduler = async;\n    if (isScheduler(arguments[arguments.length - 1])) {\n        scheduler = arguments[arguments.length - 1];\n        length--;\n    }\n    var bufferCreationInterval = null;\n    if (length >= 2) {\n        bufferCreationInterval = arguments[1];\n    }\n    var maxBufferSize = Number.POSITIVE_INFINITY;\n    if (length >= 3) {\n        maxBufferSize = arguments[2];\n    }\n    return function bufferTimeOperatorFunction(source) {\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\n    };\n}\nvar BufferTimeOperator = /*@__PURE__*/ (function () {\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        this.bufferTimeSpan = bufferTimeSpan;\n        this.bufferCreationInterval = bufferCreationInterval;\n        this.maxBufferSize = maxBufferSize;\n        this.scheduler = scheduler;\n    }\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\n    };\n    return BufferTimeOperator;\n}());\nvar Context = /*@__PURE__*/ (function () {\n    function Context() {\n        this.buffer = [];\n    }\n    return Context;\n}());\nvar BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BufferTimeSubscriber, _super);\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\n        var _this = _super.call(this, destination) || this;\n        _this.bufferTimeSpan = bufferTimeSpan;\n        _this.bufferCreationInterval = bufferCreationInterval;\n        _this.maxBufferSize = maxBufferSize;\n        _this.scheduler = scheduler;\n        _this.contexts = [];\n        var context = _this.openContext();\n        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\n        if (_this.timespanOnly) {\n            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n        else {\n            var closeState = { subscriber: _this, context: context };\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\n            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\n        }\n        return _this;\n    }\n    BufferTimeSubscriber.prototype._next = function (value) {\n        var contexts = this.contexts;\n        var len = contexts.length;\n        var filledBufferContext;\n        for (var i = 0; i < len; i++) {\n            var context_1 = contexts[i];\n            var buffer = context_1.buffer;\n            buffer.push(value);\n            if (buffer.length == this.maxBufferSize) {\n                filledBufferContext = context_1;\n            }\n        }\n        if (filledBufferContext) {\n            this.onBufferFull(filledBufferContext);\n        }\n    };\n    BufferTimeSubscriber.prototype._error = function (err) {\n        this.contexts.length = 0;\n        _super.prototype._error.call(this, err);\n    };\n    BufferTimeSubscriber.prototype._complete = function () {\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\n        while (contexts.length > 0) {\n            var context_2 = contexts.shift();\n            destination.next(context_2.buffer);\n        }\n        _super.prototype._complete.call(this);\n    };\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\n        this.contexts = null;\n    };\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\n        this.closeContext(context);\n        var closeAction = context.closeAction;\n        closeAction.unsubscribe();\n        this.remove(closeAction);\n        if (!this.closed && this.timespanOnly) {\n            context = this.openContext();\n            var bufferTimeSpan = this.bufferTimeSpan;\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\n        }\n    };\n    BufferTimeSubscriber.prototype.openContext = function () {\n        var context = new Context();\n        this.contexts.push(context);\n        return context;\n    };\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\n        this.destination.next(context.buffer);\n        var contexts = this.contexts;\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\n        if (spliceIndex >= 0) {\n            contexts.splice(contexts.indexOf(context), 1);\n        }\n    };\n    return BufferTimeSubscriber;\n}(Subscriber));\nfunction dispatchBufferTimeSpanOnly(state) {\n    var subscriber = state.subscriber;\n    var prevContext = state.context;\n    if (prevContext) {\n        subscriber.closeContext(prevContext);\n    }\n    if (!subscriber.closed) {\n        state.context = subscriber.openContext();\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\n    }\n}\nfunction dispatchBufferCreation(state) {\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\n    var context = subscriber.openContext();\n    var action = this;\n    if (!subscriber.closed) {\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\n        action.schedule(state, bufferCreationInterval);\n    }\n}\nfunction dispatchBufferClose(arg) {\n    var subscriber = arg.subscriber, context = arg.context;\n    subscriber.closeContext(context);\n}\n//# sourceMappingURL=bufferTime.js.map\n"]},"metadata":{},"sourceType":"module"}